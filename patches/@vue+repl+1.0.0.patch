# generated by patch-package 6.4.14
#
# declared package:
#   @vue/repl: 1.0.0
#
diff --git a/node_modules/@vue/repl/dist/repl.d.ts b/node_modules/@vue/repl/dist/repl.d.ts
index 526f787..acdcccd 100644
--- a/node_modules/@vue/repl/dist/repl.d.ts
+++ b/node_modules/@vue/repl/dist/repl.d.ts
@@ -13,131 +13,131 @@ import { vueCompilerSfc } from 'vue/compiler-sfc';
 export declare function compileFile(store: Store, { filename, code, compiled }: File_2): Promise<void>;
 
 declare class File_2 {
-    filename: string;
-    code: string;
-    hidden: boolean;
-    compiled: {
-        js: string;
-        css: string;
-        ssr: string;
-    };
-    constructor(filename: string, code?: string, hidden?: boolean);
+  filename: string;
+  code: string;
+  hidden: boolean;
+  compiled: {
+    js: string;
+    css: string;
+    ssr: string;
+  };
+  constructor(filename: string, code?: string, hidden?: boolean);
 }
 export { File_2 as File }
 
 export declare type OutputModes = 'preview' | 'js' | 'css' | 'ssr';
 
-export declare const Repl: DefineComponent<    {
-store: {
-type: PropType<Store>;
-} & {
-default: () => ReplStore;
-};
-autoResize: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-showCompileOutput: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-showImportMap: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-clearConsole: {
-type: PropType<boolean>;
-} & {
-default: boolean;
-};
-sfcOptions: {
-type: PropType<SFCOptions>;
-};
-layout: {
-type: PropType<string>;
-};
+export declare const Repl: DefineComponent<{
+  store: {
+    type: PropType<Store>;
+  } & {
+    default: () => ReplStore;
+  };
+  autoResize: {
+    type: PropType<boolean>;
+  } & {
+    default: boolean;
+  };
+  showCompileOutput: {
+    type: PropType<boolean>;
+  } & {
+    default: boolean;
+  };
+  showImportMap: {
+    type: PropType<boolean>;
+  } & {
+    default: boolean;
+  };
+  clearConsole: {
+    type: PropType<boolean>;
+  } & {
+    default: boolean;
+  };
+  sfcOptions: {
+    type: PropType<SFCOptions>;
+  };
+  layout: {
+    type: PropType<string>;
+  };
 }, () => void, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
-store?: unknown;
-autoResize?: unknown;
-showCompileOutput?: unknown;
-showImportMap?: unknown;
-clearConsole?: unknown;
-sfcOptions?: unknown;
-layout?: unknown;
+  store?: unknown;
+  autoResize?: unknown;
+  showCompileOutput?: unknown;
+  showImportMap?: unknown;
+  clearConsole?: unknown;
+  sfcOptions?: unknown;
+  layout?: unknown;
 } & {
-store: Store;
-showCompileOutput: boolean;
-autoResize: boolean;
-showImportMap: boolean;
-clearConsole: boolean;
+  store: Store;
+  showCompileOutput: boolean;
+  autoResize: boolean;
+  showImportMap: boolean;
+  clearConsole: boolean;
 } & {
-layout?: string | undefined;
-sfcOptions?: SFCOptions | undefined;
+  layout?: string | undefined;
+  sfcOptions?: SFCOptions | undefined;
 }>, {
-store: Store;
-showCompileOutput: boolean;
-autoResize: boolean;
-showImportMap: boolean;
-clearConsole: boolean;
+  store: Store;
+  showCompileOutput: boolean;
+  autoResize: boolean;
+  showImportMap: boolean;
+  clearConsole: boolean;
 }>;
 
 export declare class ReplStore implements Store {
-    state: StoreState;
-    compiler: typeof defaultCompiler;
-    options?: SFCOptions;
-    initialShowOutput: boolean;
-    initialOutputMode: OutputModes;
-    private defaultVueRuntimeURL;
-    private pendingCompiler;
-    constructor({ serializedState, defaultVueRuntimeURL, showOutput, outputMode }?: {
-        serializedState?: string;
-        showOutput?: boolean;
-        outputMode?: OutputModes | string;
-        defaultVueRuntimeURL?: string;
-    });
-    setActive(filename: string): void;
-    addFile(fileOrFilename: string | File_2): void;
-    deleteFile(filename: string): void;
-    serialize(): string;
-    getFiles(): Record<string, string>;
-    setFiles(newFiles: Record<string, string>, mainFile?: string): Promise<void>;
-    private initImportMap;
-    getImportMap(): any;
-    setImportMap(map: {
-        imports: Record<string, string>;
-        scopes?: Record<string, Record<string, string>>;
-    }): void;
-    setVueVersion(version: string): Promise<void>;
-    resetVueVersion(): void;
+  state: StoreState;
+  compiler: typeof defaultCompiler;
+  options?: SFCOptions;
+  initialShowOutput: boolean;
+  initialOutputMode: OutputModes;
+  private defaultVueRuntimeURL;
+  private pendingCompiler;
+  constructor({ serializedState, defaultVueRuntimeURL, showOutput, outputMode }?: {
+    serializedState?: string;
+    showOutput?: boolean;
+    outputMode?: OutputModes | string;
+    defaultVueRuntimeURL?: string;
+  });
+  setActive(filename: string): void;
+  addFile(fileOrFilename: string | File_2): void;
+  deleteFile(filename: string): void;
+  serialize(): string;
+  getFiles(): Record<string, string>;
+  setFiles(newFiles: Record<string, string>, mainFile?: string): Promise<void>;
+  private initImportMap;
+  getImportMap(): any;
+  setImportMap(map: {
+    imports: Record<string, string>;
+    scopes?: Record<string, Record<string, string>>;
+  }): void;
+  setVueVersion(version: string): Promise<void>;
+  resetVueVersion(): void;
 }
 
 export declare interface SFCOptions {
-    script?: Omit<SFCScriptCompileOptions, 'id'>;
-    style?: SFCAsyncStyleCompileOptions;
-    template?: SFCTemplateCompileOptions;
+  script?: Omit<SFCScriptCompileOptions, 'id'>;
+  style?: SFCAsyncStyleCompileOptions;
+  template?: SFCTemplateCompileOptions;
 }
 
 export declare interface Store {
-    state: StoreState;
-    options?: SFCOptions;
-    compiler: vueCompilerSfc;
-    setActive: (filename: string) => void;
-    addFile: (filename: string | File_2) => void;
-    deleteFile: (filename: string) => void;
-    getImportMap: () => any;
-    initialShowOutput: boolean;
-    initialOutputMode: OutputModes;
+  state: StoreState;
+  options?: SFCOptions;
+  compiler: vueCompilerSfc;
+  setActive: (filename: string) => void;
+  addFile: (filename: string | File_2) => void;
+  deleteFile: (filename: string) => void;
+  getImportMap: () => any;
+  initialShowOutput: boolean;
+  initialOutputMode: OutputModes;
 }
 
 export declare interface StoreState {
-    mainFile: string;
-    files: Record<string, File_2>;
-    activeFile: File_2;
-    errors: (string | Error)[];
-    vueRuntimeURL: string;
+  mainFile: string;
+  files: Record<string, File_2>;
+  activeFile: File_2;
+  errors: (string | Error)[];
+  vueRuntimeURL: string;
 }
 
 export { }
diff --git a/node_modules/@vue/repl/dist/vue-repl.js b/node_modules/@vue/repl/dist/vue-repl.js
index b839875..efcbd1f 100644
--- a/node_modules/@vue/repl/dist/vue-repl.js
+++ b/node_modules/@vue/repl/dist/vue-repl.js
@@ -15818,7 +15818,7 @@ const _sfc_main$3 = /* @__PURE__ */ defineComponent({
   }
 });
 var Editor = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-759ba5e9"]]);
-var srcdoc = "<!doctype html>\n<html>\n	<head>\n		<style>\n			body {\n				font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n				Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;\n			}\n		</style>\n		<style id=\"__sfc-styles\"></style>\n		<script>\n			(() => {\n				let scriptEls = []\n\n				window.process = { env: {} }\n				window.__modules__ = {}\n\n				window.__export__ = (mod, key, get) => {\n					Object.defineProperty(mod, key, {\n						enumerable: true,\n						configurable: true,\n						get\n					})\n				}\n\n				window.__dynamic_import__ = key => {\n					return Promise.resolve(window.__modules__[key])\n				}\n\n				async function handle_message(ev) {\n					let { action, cmd_id } = ev.data;\n					const send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n					const send_reply = (payload) => send_message({ ...payload, cmd_id });\n					const send_ok = () => send_reply({ action: 'cmd_ok' });\n					const send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n					if (action === 'eval') {\n						try {\n							if (scriptEls.length) {\n								scriptEls.forEach(el => {\n									document.head.removeChild(el)\n								})\n								scriptEls.length = 0\n							}\n\n							let { script: scripts } = ev.data.args\n							if (typeof scripts === 'string') scripts = [scripts]\n\n							for (const script of scripts) {\n								const scriptEl = document.createElement('script')\n								scriptEl.setAttribute('type', 'module')\n								// send ok in the module script to ensure sequential evaluation\n								// of multiple proxy.eval() calls\n								const done = new Promise((resolve) => {\n									window.__next__ = resolve\n								})\n								scriptEl.innerHTML = script + `\\nwindow.__next__()`\n								document.head.appendChild(scriptEl)\n								scriptEl.onrror = err => send_error(err.message, err.stack)\n								scriptEls.push(scriptEl)\n								await done\n							}\n							send_ok()\n						} catch (e) {\n							send_error(e.message, e.stack);\n						}\n					}\n\n					if (action === 'catch_clicks') {\n						try {\n							const top_origin = ev.origin;\n							document.body.addEventListener('click', event => {\n								if (event.which !== 1) return;\n								if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n								if (event.defaultPrevented) return;\n\n								// ensure target is a link\n								let el = event.target;\n								while (el && el.nodeName !== 'A') el = el.parentNode;\n								if (!el || el.nodeName !== 'A') return;\n\n								if (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n								event.preventDefault();\n\n								if (el.href.startsWith(top_origin)) {\n									const url = new URL(el.href);\n									if (url.hash[0] === '#') {\n										window.location.hash = url.hash;\n										return;\n									}\n								}\n\n								window.open(el.href, '_blank');\n							});\n							send_ok();\n						} catch(e) {\n							send_error(e.message, e.stack);\n						}\n					}\n				}\n\n				window.addEventListener('message', handle_message, false);\n\n				window.onerror = function (msg, url, lineNo, columnNo, error) {\n					if (msg.includes('module specifier \u201Cvue\u201D')) {\n						// firefox only error, ignore\n						return false\n					}\n					try {\n						parent.postMessage({ action: 'error', value: error }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'error', value: msg }, '*');\n					}\n				}\n\n				window.addEventListener(\"unhandledrejection\", event => {\n					if (event.reason.message.includes('Cross-origin')) {\n						event.preventDefault()\n						return\n					}\n					try {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason.message }, '*');\n					}\n				});\n\n				let previous = { level: null, args: null };\n\n				['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {\n					const original = console[level];\n					console[level] = (...args) => {\n						const msg = String(args[0])\n						if (\n							msg.includes('You are running a development build of Vue') ||\n							msg.includes('You are running the esm-bundler build of Vue')\n						) {\n							return\n						}\n						const stringifiedArgs = stringify(args);\n						if (\n							previous.level === level &&\n							previous.args &&\n							previous.args === stringifiedArgs\n						) {\n							parent.postMessage({ action: 'console', level, duplicate: true }, '*');\n						} else {\n							previous = { level, args: stringifiedArgs };\n\n							try {\n								parent.postMessage({ action: 'console', level, args }, '*');\n							} catch (err) {\n								parent.postMessage({ action: 'console', level, args: args.map(a => {\n									return a instanceof Error ? a.message : String(a)\n								}) }, '*');\n							}\n						}\n\n						original(...args);\n					}\n				});\n\n				[\n					{ method: 'group', action: 'console_group' },\n					{ method: 'groupEnd', action: 'console_group_end' },\n					{ method: 'groupCollapsed', action: 'console_group_collapsed' },\n				].forEach((group_action) => {\n					const original = console[group_action.method];\n					console[group_action.method] = (label) => {\n						parent.postMessage({ action: group_action.action, label }, '*');\n\n						original(label);\n					};\n				});\n\n				const timers = new Map();\n				const original_time = console.time;\n				const original_timelog = console.timeLog;\n				const original_timeend = console.timeEnd;\n\n				console.time = (label = 'default') => {\n					original_time(label);\n					timers.set(label, performance.now());\n				}\n				console.timeLog = (label = 'default') => {\n					original_timelog(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n				}\n				console.timeEnd = (label = 'default') => {\n					original_timeend(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n					timers.delete(label);\n				};\n\n				const original_assert = console.assert;\n				console.assert = (condition, ...args) => {\n					if (condition) {\n						const stack = new Error().stack;\n						parent.postMessage({ action: 'console', level: 'assert', args, stack }, '*');\n					}\n					original_assert(condition, ...args);\n				};\n\n				const counter = new Map();\n				const original_count = console.count;\n				const original_countreset = console.countReset;\n\n				console.count = (label = 'default') => {\n					counter.set(label, (counter.get(label) || 0) + 1);\n					parent.postMessage({ action: 'console', level: 'system-log', args: `${label}: ${counter.get(label)}` }, '*');\n					original_count(label);\n				};\n\n				console.countReset = (label = 'default') => {\n					if (counter.has(label)) {\n						counter.set(label, 0);\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: `Count for '${label}' does not exist` }, '*');\n					}\n					original_countreset(label);\n				};\n\n				const original_trace = console.trace;\n\n				console.trace = (...args) => {\n					const stack = new Error().stack;\n					parent.postMessage({ action: 'console', level: 'trace', args, stack }, '*');\n					original_trace(...args);\n				};\n\n				function stringify(args) {\n					try {\n						return JSON.stringify(args);\n					} catch (error) {\n						return null;\n					}\n				}\n			})()\n		<\/script>\n\n		<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support (all except Chrome 89+) -->\n		<script async src=\"https://unpkg.com/es-module-shims@0.10.1/dist/es-module-shims.min.js\"><\/script>\n		<script type=\"importmap\"><!--IMPORT_MAP--><\/script>\n	</head>\n	<body></body>\n</html>";
+var srcdoc = "<!doctype html>\n<html>\n	<head>\n		<style>\n			body {\n				font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n				Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;\n			}\n		</style>\n		<style id=\"__sfc-styles\"></style>\n		<script>\n			(() => {\n				let scriptEls = []\n\n				window.process = { env: {} }\n				window.__modules__ = {}\n\n				window.__export__ = (mod, key, get) => {\n					Object.defineProperty(mod, key, {\n						enumerable: true,\n						configurable: true,\n						get\n					})\n				}\n\n				window.__dynamic_import__ = key => {\n					return Promise.resolve(window.__modules__[key])\n				}\n\n				async function handle_message(ev) {\n					let { action, cmd_id } = ev.data;\n					const send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n					const send_reply = (payload) => send_message({ ...payload, cmd_id });\n					const send_ok = () => send_reply({ action: 'cmd_ok' });\n					const send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n					if (action === 'eval') {\n						try {\n							if (scriptEls.length) {\n								scriptEls.forEach(el => {\n									document.head.removeChild(el)\n								})\n								scriptEls.length = 0\n							}\n\n							let { script: scripts } = ev.data.args\n							if (typeof scripts === 'string') scripts = [scripts]\n\n							for (const script of scripts) {\n								const scriptEl = document.createElement('script')\n								scriptEl.setAttribute('type', 'module')\n								// send ok in the module script to ensure sequential evaluation\n								// of multiple proxy.eval() calls\n								const done = new Promise((resolve) => {\n									window.__next__ = resolve\n								})\n								scriptEl.innerHTML = script + `\\nwindow.__next__()`\n								document.head.appendChild(scriptEl)\n								scriptEl.onrror = err => send_error(err.message, err.stack)\n								scriptEls.push(scriptEl)\n								await done\n							}\n							send_ok()\n						} catch (e) {\n							send_error(e.message, e.stack);\n						}\n					}\n\n					if (action === 'catch_clicks') {\n						try {\n							const top_origin = ev.origin;\n							document.body.addEventListener('click', event => {\n								if (event.which !== 1) return;\n								if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n								if (event.defaultPrevented) return;\n\n								// ensure target is a link\n								let el = event.target;\n								while (el && el.nodeName !== 'A') el = el.parentNode;\n								if (!el || el.nodeName !== 'A') return;\n\n								if (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n								event.preventDefault();\n\n								if (el.href.startsWith(top_origin)) {\n									const url = new URL(el.href);\n									if (url.hash[0] === '#') {\n										window.location.hash = url.hash;\n										return;\n									}\n								}\n\n								window.open(el.href, '_blank');\n							});\n							send_ok();\n						} catch(e) {\n							send_error(e.message, e.stack);\n						}\n					}\n				}\n\n				window.addEventListener('message', handle_message, false);\n\n				window.onerror = function (msg, url, lineNo, columnNo, error) {\n					if (msg.includes('module specifier \u201Cvue\u201D')) {\n						// firefox only error, ignore\n						return false\n					}\n					try {\n						parent.postMessage({ action: 'error', value: error }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'error', value: msg }, '*');\n					}\n				}\n\n				window.addEventListener(\"unhandledrejection\", event => {\n					if (event.reason.message.includes('Cross-origin')) {\n						event.preventDefault()\n						return\n					}\n					try {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason }, '*');\n					} catch (e) {\n						parent.postMessage({ action: 'unhandledrejection', value: event.reason.message }, '*');\n					}\n				});\n\n				let previous = { level: null, args: null };\n\n				['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {\n					const original = console[level];\n					console[level] = (...args) => {\n						const msg = String(args[0])\n						if (\n							msg.includes('You are running a development build of Vue') ||\n							msg.includes('You are running the esm-bundler build of Vue')\n						) {\n							return\n						}\n						const stringifiedArgs = stringify(args);\n						if (\n							previous.level === level &&\n							previous.args &&\n							previous.args === stringifiedArgs\n						) {\n							parent.postMessage({ action: 'console', level, duplicate: true }, '*');\n						} else {\n							previous = { level, args: stringifiedArgs };\n\n							try {\n								parent.postMessage({ action: 'console', level, args }, '*');\n							} catch (err) {\n								parent.postMessage({ action: 'console', level, args: args.map(a => {\n									return a instanceof Error ? a.message : String(a)\n								}) }, '*');\n							}\n						}\n\n						original(...args);\n					}\n				});\n\n				[\n					{ method: 'group', action: 'console_group' },\n					{ method: 'groupEnd', action: 'console_group_end' },\n					{ method: 'groupCollapsed', action: 'console_group_collapsed' },\n				].forEach((group_action) => {\n					const original = console[group_action.method];\n					console[group_action.method] = (label) => {\n						parent.postMessage({ action: group_action.action, label }, '*');\n\n						original(label);\n					};\n				});\n\n				const timers = new Map();\n				const original_time = console.time;\n				const original_timelog = console.timeLog;\n				const original_timeend = console.timeEnd;\n\n				console.time = (label = 'default') => {\n					original_time(label);\n					timers.set(label, performance.now());\n				}\n				console.timeLog = (label = 'default') => {\n					original_timelog(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n				}\n				console.timeEnd = (label = 'default') => {\n					original_timeend(label);\n					const now = performance.now();\n					if (timers.has(label)) {\n						parent.postMessage({ action: 'console', level: 'system-log', args: [`${label}: ${now - timers.get(label)}ms`] }, '*');\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] }, '*');\n					}\n					timers.delete(label);\n				};\n\n				const original_assert = console.assert;\n				console.assert = (condition, ...args) => {\n					if (condition) {\n						const stack = new Error().stack;\n						parent.postMessage({ action: 'console', level: 'assert', args, stack }, '*');\n					}\n					original_assert(condition, ...args);\n				};\n\n				const counter = new Map();\n				const original_count = console.count;\n				const original_countreset = console.countReset;\n\n				console.count = (label = 'default') => {\n					counter.set(label, (counter.get(label) || 0) + 1);\n					parent.postMessage({ action: 'console', level: 'system-log', args: `${label}: ${counter.get(label)}` }, '*');\n					original_count(label);\n				};\n\n				console.countReset = (label = 'default') => {\n					if (counter.has(label)) {\n						counter.set(label, 0);\n					} else {\n						parent.postMessage({ action: 'console', level: 'system-warn', args: `Count for '${label}' does not exist` }, '*');\n					}\n					original_countreset(label);\n				};\n\n				const original_trace = console.trace;\n\n				console.trace = (...args) => {\n					const stack = new Error().stack;\n					parent.postMessage({ action: 'console', level: 'trace', args, stack }, '*');\n					original_trace(...args);\n				};\n\n				function stringify(args) {\n					try {\n						return JSON.stringify(args);\n					} catch (error) {\n						return null;\n					}\n				}\n			})()\n		<\/script>\n\n		<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support (all except Chrome 89+) -->\n		<script async src=\"./es-module-shims.min.js\"><\/script>\n		<script type=\"importmap\"><!--IMPORT_MAP--><\/script>\n	</head>\n	<body></body>\n</html>";
 let uid = 1;
 class PreviewProxy {
   constructor(iframe, handlers) {
