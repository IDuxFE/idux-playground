import { computed, shallowRef, ref, toRaw, watch, unref, Fragment, Comment, Text, isVNode, effectScope, onScopeDispose, defineComponent, createVNode, Teleport, inject, onBeforeUnmount, onMounted, provide, watchEffect, reactive, normalizeClass, cloneVNode, getCurrentInstance, shallowReactive, Transition, mergeProps, withDirectives, vShow, toRef, customRef, nextTick, onUnmounted, normalizeStyle, resolveComponent, openBlock, createBlock, withCtx, renderSlot, createElementBlock, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, TransitionGroup, withKeys, onUpdated, toRefs, h as h$1, isProxy } from 'vue';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

var freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

var root$1 = root;

/** Built-in value references. */
var Symbol$1 = root$1.Symbol;

var Symbol$2 = Symbol$1;

/** Used for built-in method references. */
var objectProto$h = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$h.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$f.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$g.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString$1(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$3 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray$1 = isArray;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger$1(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

var coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$f = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$f.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$e).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root$1, 'WeakMap');

var WeakMap$2 = WeakMap$1;

/** Used to store function metadata. */
var metaMap = WeakMap$2 && new WeakMap$2;

var metaMap$1 = metaMap;

/**
 * The base implementation of `setData` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap$1 ? identity : function(func, data) {
  metaMap$1.set(func, data);
  return func;
};

var baseSetData$1 = baseSetData;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var baseCreate$1 = baseCreate;

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate$1(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$6 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$6,
      Ctor = createCtor(func);

  function wrapper() {
    var fn = (this && this !== root$1 && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$4 = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax$4(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$3 = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax$3(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate$1(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap$1 ? noop : function(func) {
  return metaMap$1.get(func);
};

var getData$1 = getData;

/** Used to lookup unminified function names. */
var realNames = {};

var realNames$1 = realNames;

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$e.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames$1[result],
      length = hasOwnProperty$d.call(realNames$1, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate$1(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray$1(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$c.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData$1(other);
  return !!data && func === data[0];
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = shortOut(baseSetData$1);

var setData$1 = setData;

/** Used to match wrap detail comments. */
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

var baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString$1);

var setToString$1 = setToString;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$5 = 1,
    WRAP_BIND_KEY_FLAG$4 = 2,
    WRAP_CURRY_FLAG$5 = 8,
    WRAP_CURRY_RIGHT_FLAG$2 = 16,
    WRAP_PARTIAL_FLAG$2 = 32,
    WRAP_PARTIAL_RIGHT_FLAG$2 = 64,
    WRAP_ARY_FLAG$2 = 128,
    WRAP_REARG_FLAG$1 = 256,
    WRAP_FLIP_FLAG$1 = 512;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', WRAP_ARY_FLAG$2],
  ['bind', WRAP_BIND_FLAG$5],
  ['bindKey', WRAP_BIND_KEY_FLAG$4],
  ['curry', WRAP_CURRY_FLAG$5],
  ['curryRight', WRAP_CURRY_RIGHT_FLAG$2],
  ['flip', WRAP_FLIP_FLAG$1],
  ['partial', WRAP_PARTIAL_FLAG$2],
  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG$2],
  ['rearg', WRAP_REARG_FLAG$1]
];

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
function setWrapToString(wrapper, reference, bitmask) {
  var source = (reference + '');
  return setToString$1(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$4 = 1,
    WRAP_BIND_KEY_FLAG$3 = 2,
    WRAP_CURRY_BOUND_FLAG$1 = 4,
    WRAP_CURRY_FLAG$4 = 8,
    WRAP_PARTIAL_FLAG$1 = 32,
    WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$4,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$4 | WRAP_BIND_KEY_FLAG$3);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData$1(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString(result, func, bitmask);
}

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$2 = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin$2(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER$1 = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array[index] = PLACEHOLDER$1;
      result[resIndex++] = index;
    }
  }
  return result;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$3 = 1,
    WRAP_BIND_KEY_FLAG$2 = 2,
    WRAP_CURRY_FLAG$3 = 8,
    WRAP_CURRY_RIGHT_FLAG$1 = 16,
    WRAP_ARY_FLAG$1 = 128,
    WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$1,
      isBind = bitmask & WRAP_BIND_FLAG$3,
      isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
      isCurried = bitmask & (WRAP_CURRY_FLAG$3 | WRAP_CURRY_RIGHT_FLAG$1),
      isFlip = bitmask & WRAP_FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root$1 && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root$1 && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$2 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$2,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root$1 && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$1 = 1,
    WRAP_BIND_KEY_FLAG$1 = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG$2 = 8,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$1 = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (WRAP_BIND_FLAG$1 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG);

  var isCombo =
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG$2)) ||
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$2));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & WRAP_BIND_FLAG$1) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & WRAP_BIND_FLAG$1 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

/** Error message constants. */
var FUNC_ERROR_TEXT$3 = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG$1 = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax$2(toInteger$1(ary), 0);
  arity = arity === undefined ? arity : toInteger$1(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData$1(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined
    ? (isBindKey ? 0 : func.length)
    : nativeMax$2(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG$1 || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }
  var setter = data ? baseSetData$1 : setData$1;
  return setWrapToString(setter(result, newData), func, bitmask);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$b.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$b;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$a.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$a.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments$1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

var isBuffer$1 = isBuffer;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$4 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$5 = '[object Map]',
    numberTag$4 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$4 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] =
typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal$1.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

var nodeUtil$1 = nodeUtil;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

var isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$9.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

var nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

var nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map');

var Map$2 = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$2 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

var getPrototype$1 = getPrototype;

/** `Object#toString` result references. */
var objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$4 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange$2 = '\\ud800-\\udfff',
    rsComboMarksRange$3 = '\\u0300-\\u036f',
    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$2 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$3 + rsVarRange$2 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$2 = '\\u0300-\\u036f',
    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

var upperFirst$1 = upperFirst;

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst$1(toString(string).toLowerCase());
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

var deburrLetter$1 = deburrLetter;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboRange$1 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

var camelCase$1 = camelCase;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root$1.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var getSymbols$1 = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};

var getSymbolsIn$1 = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root$1, 'DataView');

var DataView$1 = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root$1, 'Promise');

var Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root$1, 'Set');

var Set$2 = Set$1;

/** `Object#toString` result references. */
var mapTag$4 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$4 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$3 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3) ||
    (Map$2 && getTag(new Map$2) != mapTag$4) ||
    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
    (Set$2 && getTag(new Set$2) != setTag$4) ||
    (WeakMap$2 && getTag(new WeakMap$2) != weakMapTag$1)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$3;
        case mapCtorString: return mapTag$4;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$4;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$3.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array = root$1.Uint8Array;

var Uint8Array$1 = Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$3 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$3 = '[object Map]',
    numberTag$3 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$3 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);

    case boolTag$3:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$3:
      return new Ctor;

    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);

    case regexpTag$2:
      return cloneRegExp(object);

    case setTag$3:
      return new Ctor;

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate$1(getPrototype$1(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$2;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

var isMap$1 = isMap;

/** `Object#toString` result references. */
var setTag$2 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$2;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

var isSet$1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$1 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
cloneableTags[boolTag$2] = cloneableTags[dateTag$1] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag$1:
    case dateTag:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray$1(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray$1(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

var baseFor$1 = baseFor;

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root$1.Date.now();
};

var now$1 = now;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray$1(srcValue),
        isBuff = !isArr && isBuffer$1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

var kebabCase$1 = kebabCase;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

var merge$1 = merge;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce$1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function t(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}function n(){return (n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);}return e}).apply(this,arguments)}function r(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t;}function i(e,t){if(null==e)return {};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t.indexOf(n=o[r])>=0||(i[n]=e[n]);return i}function o(e){return 1==(null!=(t=e)&&"object"==typeof t&&!1===Array.isArray(t))&&"[object Object]"===Object.prototype.toString.call(e);var t;}var u=Object.prototype,a=u.toString,f=u.hasOwnProperty,c=/^\s*function (\w+)/;function l(e){var t,n=null!==(t=null==e?void 0:e.type)&&void 0!==t?t:e;if(n){var r=n.toString().match(c);return r?r[1]:""}return ""}var s=function(e){var t,n;return !1!==o(e)&&"function"==typeof(t=e.constructor)&&!1!==o(n=t.prototype)&&!1!==n.hasOwnProperty("isPrototypeOf")},v=function(e){return e},y=v;if("production"!==process.env.NODE_ENV){var p="undefined"!=typeof console;y=p?function(e){console.warn("[VueTypes warn]: "+e);}:v;}var d=function(e,t){return f.call(e,t)},h=Number.isInteger||function(e){return "number"==typeof e&&isFinite(e)&&Math.floor(e)===e},b=Array.isArray||function(e){return "[object Array]"===a.call(e)},O=function(e){return "[object Function]"===a.call(e)},g=function(e){return s(e)&&d(e,"_vueTypes_name")},m=function(e){return s(e)&&(d(e,"type")||["_vueTypes_name","validator","default","required"].some(function(t){return d(e,t)}))};function j(e,t){return Object.defineProperty(e.bind(t),"__original",{value:e})}function _(e,t,n){var r;void 0===n&&(n=!1);var i=!0,o="";r=s(e)?e:{type:e};var u=g(r)?r._vueTypes_name+" - ":"";if(m(r)&&null!==r.type){if(void 0===r.type||!0===r.type)return i;if(!r.required&&void 0===t)return i;b(r.type)?(i=r.type.some(function(e){return !0===_(e,t,!0)}),o=r.type.map(function(e){return l(e)}).join(" or ")):i="Array"===(o=l(r))?b(t):"Object"===o?s(t):"String"===o||"Number"===o||"Boolean"===o||"Function"===o?function(e){if(null==e)return "";var t=e.constructor.toString().match(c);return t?t[1]:""}(t)===o:t instanceof r.type;}if(!i){var a=u+'value "'+t+'" should be of type "'+o+'"';return !1===n?(y(a),!1):a}if(d(r,"validator")&&O(r.validator)){var f=y,v=[];if(y=function(e){v.push(e);},i=r.validator(t),y=f,!i){var p=(v.length>1?"* ":"")+v.join("\n* ");return v.length=0,!1===n?(y(p),i):p}}return i}function T(e,t){var n=Object.defineProperties(t,{_vueTypes_name:{value:e,writable:!0},isRequired:{get:function(){return this.required=!0,this}},def:{value:function(e){return void 0!==e||this.default?O(e)||!0===_(this,e,!0)?(this.default=b(e)?function(){return [].concat(e)}:s(e)?function(){return Object.assign({},e)}:e,this):(y(this._vueTypes_name+' - invalid default value: "'+e+'"'),this):this}}}),r=n.validator;return O(r)&&(n.validator=j(r,n)),n}function w(e,t){var n=T(e,t);return Object.defineProperty(n,"validate",{value:function(e){return O(this.validator)&&y(this._vueTypes_name+" - calling .validate() will overwrite the current custom validator function. Validator info:\n"+JSON.stringify(this)),this.validator=j(e,this),this}})}function k(e,t,n){var r,o,u=(r=t,o={},Object.getOwnPropertyNames(r).forEach(function(e){o[e]=Object.getOwnPropertyDescriptor(r,e);}),Object.defineProperties({},o));if(u._vueTypes_name=e,!s(n))return u;var a,f,c=n.validator,l=i(n,["validator"]);if(O(c)){var v=u.validator;v&&(v=null!==(f=(a=v).__original)&&void 0!==f?f:a),u.validator=j(v?function(e){return v.call(this,e)&&c.call(this,e)}:c,u);}return Object.assign(u,l)}function P(e){return e.replace(/^(?!\s*$)/gm,"  ")}var x=function(){return w("any",{})},A=function(){return w("function",{type:Function})},E=function(){return w("boolean",{type:Boolean})},N=function(){return w("string",{type:String})},q=function(){return w("number",{type:Number})},S=function(){return w("array",{type:Array})},V=function(){return w("object",{type:Object})},F=function(){return T("integer",{type:Number,validator:function(e){return h(e)}})},D=function(){return T("symbol",{validator:function(e){return "symbol"==typeof e}})};function L(e,t){if(void 0===t&&(t="custom validation failed"),"function"!=typeof e)throw new TypeError("[VueTypes error]: You must provide a function as argument");return T(e.name||"<<anonymous function>>",{validator:function(n){var r=e(n);return r||y(this._vueTypes_name+" - "+t),r}})}function Y(e){if(!b(e))throw new TypeError("[VueTypes error]: You must provide an array as argument.");var t='oneOf - value should be one of "'+e.join('", "')+'".',n=e.reduce(function(e,t){if(null!=t){var n=t.constructor;-1===e.indexOf(n)&&e.push(n);}return e},[]);return T("oneOf",{type:n.length>0?n:void 0,validator:function(n){var r=-1!==e.indexOf(n);return r||y(t),r}})}function B(e){if(!b(e))throw new TypeError("[VueTypes error]: You must provide an array as argument");for(var t=!1,n=[],r=0;r<e.length;r+=1){var i=e[r];if(m(i)){if(g(i)&&"oneOf"===i._vueTypes_name){n=n.concat(i.type);continue}if(O(i.validator)&&(t=!0),!0!==i.type&&i.type){n=n.concat(i.type);continue}}n.push(i);}return n=n.filter(function(e,t){return n.indexOf(e)===t}),T("oneOfType",t?{type:n,validator:function(t){var n=[],r=e.some(function(e){var r=_(g(e)&&"oneOf"===e._vueTypes_name?e.type||null:e,t,!0);return "string"==typeof r&&n.push(r),!0===r});return r||y("oneOfType - provided value does not match any of the "+n.length+" passed-in validators:\n"+P(n.join("\n"))),r}}:{type:n})}function I(e){return T("arrayOf",{type:Array,validator:function(t){var n,r=t.every(function(t){return !0===(n=_(e,t,!0))});return r||y("arrayOf - value validation error:\n"+P(n)),r}})}function J(e){return T("instanceOf",{type:e})}function M(e){return T("objectOf",{type:Object,validator:function(t){var n,r=Object.keys(t).every(function(r){return !0===(n=_(e,t[r],!0))});return r||y("objectOf - value validation error:\n"+P(n)),r}})}function R(e){var t=Object.keys(e),n=t.filter(function(t){var n;return !!(null===(n=e[t])||void 0===n?void 0:n.required)}),r=T("shape",{type:Object,validator:function(r){var i=this;if(!s(r))return !1;var o=Object.keys(r);if(n.length>0&&n.some(function(e){return -1===o.indexOf(e)})){var u=n.filter(function(e){return -1===o.indexOf(e)});return y(1===u.length?'shape - required property "'+u[0]+'" is not defined.':'shape - required properties "'+u.join('", "')+'" are not defined.'),!1}return o.every(function(n){if(-1===t.indexOf(n))return !0===i._vueTypes_isLoose||(y('shape - shape definition does not include a "'+n+'" property. Allowed keys: "'+t.join('", "')+'".'),!1);var o=_(e[n],r[n],!0);return "string"==typeof o&&y('shape - "'+n+'" property validation error:\n '+P(o)),!0===o})}});return Object.defineProperty(r,"_vueTypes_isLoose",{writable:!0,value:!1}),Object.defineProperty(r,"loose",{get:function(){return this._vueTypes_isLoose=!0,this}}),r}var $=function(){function e(){}return e.extend=function(e){var t=this;if(b(e))return e.forEach(function(e){return t.extend(e)}),this;var n=e.name,r=e.validate,o=void 0!==r&&r,u=e.getter,a=void 0!==u&&u,f=i(e,["name","validate","getter"]);if(d(this,n))throw new TypeError('[VueTypes error]: Type "'+n+'" already defined');var c,l=f.type;return g(l)?(delete f.type,Object.defineProperty(this,n,a?{get:function(){return k(n,l,f)}}:{value:function(){var e,t=k(n,l,f);return t.validator&&(t.validator=(e=t.validator).bind.apply(e,[t].concat([].slice.call(arguments)))),t}})):(c=a?{get:function(){var e=Object.assign({},f);return o?w(n,e):T(n,e)},enumerable:!0}:{value:function(){var e,t,r=Object.assign({},f);return e=o?w(n,r):T(n,r),r.validator&&(e.validator=(t=r.validator).bind.apply(t,[e].concat([].slice.call(arguments)))),e},enumerable:!0},Object.defineProperty(this,n,c))},t(e,null,[{key:"any",get:function(){return x()}},{key:"func",get:function(){return A().def(this.defaults.func)}},{key:"bool",get:function(){return E().def(this.defaults.bool)}},{key:"string",get:function(){return N().def(this.defaults.string)}},{key:"number",get:function(){return q().def(this.defaults.number)}},{key:"array",get:function(){return S().def(this.defaults.array)}},{key:"object",get:function(){return V().def(this.defaults.object)}},{key:"integer",get:function(){return F().def(this.defaults.integer)}},{key:"symbol",get:function(){return D()}}]),e}();function z(e){var i;return void 0===e&&(e={func:function(){},bool:!0,string:"",number:0,array:function(){return []},object:function(){return {}},integer:0}),(i=function(i){function o(){return i.apply(this,arguments)||this}return r(o,i),t(o,null,[{key:"sensibleDefaults",get:function(){return n({},this.defaults)},set:function(t){this.defaults=!1!==t?n({},!0!==t?t:e):{};}}]),o}($)).defaults=n({},e),i}$.defaults={},$.custom=L,$.oneOf=Y,$.instanceOf=J,$.oneOfType=B,$.arrayOf=I,$.objectOf=M,$.shape=R,$.utils={validate:function(e,t){return !0===_(t,e,!0)},toType:function(e,t,n){return void 0===n&&(n=!1),n?w(e,t):T(e,t)}};(function(e){function t(){return e.apply(this,arguments)||this}return r(t,e),t})(z());

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */

(process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
(process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};

var resizeObservers = [];

var hasActiveObservations = function () {
    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
};

var hasSkippedObservations = function () {
    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
};

var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    }
    else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};

var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

var freeze = function (obj) { return Object.freeze(obj); };

var ResizeObserverSize = (function () {
    function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
    }
    return ResizeObserverSize;
}());

var DOMRectReadOnly = (function () {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
    }
    DOMRectReadOnly.prototype.toJSON = function () {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
    };
    DOMRectReadOnly.fromRect = function (rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}());

var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
var isHidden = function (target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement$1 = function (obj) {
    var _a, _b;
    if (obj instanceof Element) {
        return true;
    }
    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
    switch (target.tagName) {
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};

var global$1 = typeof window !== 'undefined' ? window : {};

var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = (/msie|trident/i).test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
var size = function (inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) { inlineSize = 0; }
    if (blockSize === void 0) { blockSize = 0; }
    if (switchSizes === void 0) { switchSizes = false; }
    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
    if (forceRecalculation === void 0) { forceRecalculation = false; }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};

var ResizeObserverEntry = (function () {
    function ResizeObserverEntry(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
    }
    return ResizeObserverEntry;
}());

var calculateDepthForNode = function (node) {
    if (isHidden(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while (parent) {
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};

var broadcastActiveObservations = function () {
    var shallowestDepth = Infinity;
    var callbacks = [];
    resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};

var gatherActiveObservationsAtDepth = function (depth) {
    resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if (calculateDepthForNode(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                }
                else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};

var process$1 = function () {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
        deliverResizeLoopError();
    }
    return depth > 0;
};

var trigger;
var callbacks = [];
var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
var queueMicroTask = function (callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = { characterData: true };
        new MutationObserver(function () { return notify(); }).observe(el_1, config);
        trigger = function () { el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++); };
    }
    callbacks.push(callback);
    trigger();
};

var queueResizeObserver = function (cb) {
    queueMicroTask(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};

var watching = 0;
var isWatching = function () { return !!watching; };
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events$1 = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function (timeout) {
    if (timeout === void 0) { timeout = 0; }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function () {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function () { return _this.schedule(); };
    }
    Scheduler.prototype.run = function (timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = CATCH_PERIOD; }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function () {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = process$1();
            }
            finally {
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                }
                else if (timeout > 0) {
                    _this.run(timeout);
                }
                else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function () {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function () {
        var _this = this;
        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
        document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function () {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events$1.forEach(function (name) { return global$1.addEventListener(name, _this.listener, true); });
        }
    };
    Scheduler.prototype.stop = function () {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events$1.forEach(function (name) { return global$1.removeEventListener(name, _this.listener, true); });
            this.stopped = true;
        }
    };
    return Scheduler;
}());
var scheduler = new Scheduler();
var updateCount = function (n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};

var skipNotifyOnElement = function (target) {
    return !isSVG(target)
        && !isReplacedElement(target)
        && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = (function () {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function () {
        var size = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize
            || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}());

var ResizeObserverDetail = (function () {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}());

var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
    for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController = (function () {
    function ResizeObserverController() {
    }
    ResizeObserverController.connect = function (resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function (resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
        }
    };
    ResizeObserverController.unobserve = function (resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
        }
    };
    ResizeObserverController.disconnect = function (resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}());

var ResizeObserver = (function () {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
    }
    ResizeObserver.prototype.observe = function (target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement$1(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function (target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement$1(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function () {
        ResizeObserverController.disconnect(this);
    };
    ResizeObserver.toString = function () {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}());

class IxPropTypes {
  static get any() {
    return w("any", { default: void 0 });
  }
  static get bool() {
    return w("boolean", {
      type: Boolean,
      default: void 0
    });
  }
  static get string() {
    return w("string", {
      type: String,
      default: void 0
    });
  }
  static get number() {
    return w("number", {
      type: Number,
      default: void 0
    });
  }
  static get integer() {
    return w("integer", {
      type: Number,
      validator(value) {
        return Number.isInteger(value);
      },
      default: void 0
    });
  }
  static get symbol() {
    return T("symbol", {
      validator(value) {
        return typeof value === "symbol";
      },
      default: void 0
    });
  }
  static object() {
    return V();
  }
  static func() {
    return A();
  }
  static array() {
    return S();
  }
  static oneOfType(arr) {
    const type = B(arr);
    type.default = void 0;
    return type;
  }
  static oneOf(arr) {
    return Y(arr);
  }
  static get vNode() {
    return w("vNode", {
      type: Object,
      validator: (value) => isVNode(value)
    });
  }
  static maxLength(max) {
    return w("maxLength", {
      type: String,
      validator: (value) => value.length <= max
    });
  }
  static minLength(min) {
    return w("minLength", {
      type: String,
      validator: (value) => value.length >= min
    });
  }
  static max(max) {
    return w("max", {
      type: Number,
      validator: (value) => value <= max
    });
  }
  static min(min) {
    return w("min", {
      type: Number,
      validator: (value) => value >= min
    });
  }
  static range(min, max) {
    return w("range", {
      type: Number,
      validator: (value) => value >= min && value <= max
    });
  }
  static emit() {
    return B([A(), S()]);
  }
}
IxPropTypes.custom = L;
IxPropTypes.instanceOf = J;
IxPropTypes.arrayOf = I;
IxPropTypes.objectOf = M;
IxPropTypes.shape = R;
function callEmit(funcs, ...args) {
  if (!funcs) {
    return;
  }
  if (Array.isArray(funcs)) {
    funcs.forEach((fn) => fn(...args));
  } else {
    return funcs(...args);
  }
}
IxPropTypes.oneOf([String, Number, Symbol]);
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    if (scope && --subscribers <= 0) {
      scope.stop();
      state = scope = void 0;
    }
  };
  return (...args) => {
    subscribers++;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    onScopeDispose(dispose);
    return state;
  };
}
function useState$1(defaultOrFactory, shallow = true) {
  const defaultValue = isFunction(defaultOrFactory) ? defaultOrFactory() : defaultOrFactory;
  const state = shallow ? shallowRef(defaultValue) : ref(defaultValue);
  const setState = (value) => {
    if (value !== toRaw(state.value)) {
      state.value = value;
    }
  };
  return [computed(() => state.value), setState];
}
function useControlledProp(props, key, defaultOrFactory) {
  const tempProp = ref(props[key]);
  watch(() => props[key], (value) => tempProp.value = value);
  const state = computed(() => {
    var _a, _b;
    return (_b = (_a = props[key]) != null ? _a : tempProp.value) != null ? _b : isFunction(defaultOrFactory) ? defaultOrFactory() : defaultOrFactory;
  });
  const setState = (value) => {
    if (value !== toRaw(state.value)) {
      tempProp.value = value;
      callEmit(props[`onUpdate:${key}`], value);
    }
  };
  return [state, setState];
}
function hasOwnProperty(val, key) {
  return Object.prototype.hasOwnProperty.call(val, key);
}
function isNumeric(val) {
  return !isNaN(parseFloat(val)) && isFinite(val);
}
function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}
const isHTMLElement$1 = (val) => toRawType(val).startsWith("HTML");
function convertArray(value) {
  if (isNil(value)) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function convertNumber(value, fallback = 0) {
  return isNumeric(value) ? Number(value) : fallback;
}
function convertCssPixel(value) {
  if (isNil(value)) {
    return "";
  }
  return typeof value === "string" ? value : `${value}px`;
}
function convertElement(element) {
  const elementOrInstance = unref(element);
  if (!elementOrInstance) {
    return void 0;
  }
  return isHTMLElement$1(elementOrInstance) ? elementOrInstance : elementOrInstance.$el;
}
function on(el, type, listener, options) {
  if (el && type && listener) {
    el.addEventListener(type, listener, options);
  }
}
function off(el, type, listener, options) {
  if (el && type && listener) {
    el.removeEventListener(type, listener, options);
  }
}
const resizeMap = /* @__PURE__ */ new Map();
function onResize(el, listener, options) {
  if (!el || !listener) {
    return;
  }
  if (resizeMap.has(el)) {
    resizeMap.get(el).listeners.push(listener);
  } else {
    const listeners = [listener];
    const ro = new ResizeObserver((entries) => {
      entries.forEach((entry) => listeners.forEach((fn) => fn(entry)));
    });
    ro.observe(el, options);
    resizeMap.set(el, { listeners, ro });
  }
}
function offResize(el, listener) {
  if (!el || !listener || !resizeMap.has(el)) {
    return;
  }
  const { listeners, ro } = resizeMap.get(el);
  const listenerIndex = listeners.indexOf(listener);
  if (listenerIndex > -1) {
    listeners.splice(listenerIndex, 1);
    if (listeners.length === 0) {
      ro.disconnect();
      resizeMap.delete(el);
    }
  }
}
function addClass(el, className) {
  const cls = isString(className) ? [className] : className;
  el.classList.add(...cls);
}
function removeClass(el, className) {
  const cls = isString(className) ? [className] : className;
  el.classList.remove(...cls);
}
const rAF = requestAnimationFrame || ((cb) => setTimeout(cb, 1e3 / 60));
const cancelRAF = cancelAnimationFrame || clearTimeout;
function throttleRAF(fn) {
  let id = null;
  const frameCb = (...args) => {
    id = null;
    fn(...args);
  };
  const requestCb = (...args) => {
    if (id === null) {
      id = rAF(() => frameCb(...args));
    }
  };
  requestCb.cancel = () => {
    if (id !== null) {
      (cancelAnimationFrame || clearTimeout)(id);
    }
  };
  return requestCb;
}
function isStyleVisible(element) {
  const { display, visibility, opacity } = getComputedStyle(element);
  return display !== "none" && visibility !== "hidden" && visibility !== "collapse" && opacity !== "0";
}
function isAttributeVisible(element) {
  let box;
  if (element instanceof HTMLElement) {
    if (element.offsetParent) {
      return true;
    }
    box = element.getBoundingClientRect();
  } else if (element.getBBox) {
    box = element.getBBox();
  }
  if (box && box.width && box.height) {
    return true;
  }
  return false;
}
function isVisibleElement(element) {
  if (!element) {
    return false;
  }
  return isStyleVisible(element) && isAttributeVisible(element);
}
function getMouseClientXY(ev) {
  let clientX;
  let clientY;
  if (ev.type.startsWith("touch")) {
    clientY = ev.touches[0].clientY;
    clientX = ev.touches[0].clientX;
  } else {
    clientY = ev.clientY;
    clientX = ev.clientX;
  }
  return {
    clientX,
    clientY
  };
}
const easeInOutCubic = (elapsed, initialValue, amountOfChange, duration) => {
  if (duration <= 0) {
    return amountOfChange + initialValue;
  }
  if ((elapsed /= duration / 2) < 1) {
    return amountOfChange / 2 * elapsed * elapsed * elapsed + initialValue;
  }
  return amountOfChange / 2 * ((elapsed -= 2) * elapsed * elapsed + 2) + initialValue;
};
const logWrapper = (location, args, log) => {
  log(`[@idux/${location}]:`, ...args);
};
const info = (location, ...args) => logWrapper(location, args, console.log);
const warn = (location, ...args) => logWrapper(location, args, console.warn);
const error = (location, ...args) => logWrapper(location, args, console.error);
const Logger = { info, warn, error };
const throwError = (location, message) => {
  throw new Error(`[@idux/${location}]: ${message}`);
};
const NoopFunction = () => {
};
const NoopObject = Object.freeze({});
const NoopArray = Object.freeze([]);
const getOffset = (el, target = window) => {
  if (!el || !el.getClientRects().length) {
    return { top: 0, left: 0 };
  }
  let { top, left } = el.getBoundingClientRect();
  if (target === window) {
    const doc = el.ownerDocument.documentElement;
    top = top - doc.clientTop;
    left = left - doc.clientLeft;
  } else {
    const targetRect = target.getBoundingClientRect();
    top = top - targetRect.top;
    left = left - targetRect.left;
  }
  return { top, left };
};
let nodeId = 0;
function uniqueId(prefix = "ix") {
  return `${prefix}-${nodeId++}`;
}
const TEMPLATE = "template";
const isComment = (node) => node.type === Comment;
const isFragment = (node) => node.type === Fragment;
const isTemplate = (node) => node.type === TEMPLATE;
const isText = (node) => node.type === Text;
function getChildren(node, depth) {
  if (isComment(node)) {
    return;
  }
  if (isFragment(node) || isTemplate(node)) {
    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;
  }
  return node;
}
function getFirstValidNode(nodes, maxDepth = 3) {
  if (isNil(nodes) || Array.isArray(nodes) && !nodes.length) {
    return;
  }
  if (Array.isArray(nodes) && nodes.length > 0) {
    return getChildren(nodes[0], maxDepth);
  }
  return getChildren(nodes, maxDepth);
}
function hasSlot(slots, key = "default") {
  return !isNil(slots[key]);
}
function isEmptyNode(node) {
  return !node || isComment(node) || isFragment(node) && node.children.length === 0 || isText(node) && node.children.trim() === "";
}
function flattenNode(nodes, filterOptions = {}) {
  const result = [];
  convertArray(nodes).forEach((node) => {
    if (Array.isArray(node)) {
      result.push(...flattenNode(node, filterOptions));
    } else if (isFragment(node)) {
      result.push(...flattenNode(node.children, filterOptions));
    } else {
      const { empty = true, key } = filterOptions;
      if (empty && isEmptyNode(node)) {
        return;
      }
      const keys = convertArray(key);
      if (keys.length && isVNode(node) && !keys.some((key2) => node.type[key2])) {
        return;
      }
      result.push(node);
    }
  });
  return result;
}

const documentHandlerMap = /* @__PURE__ */ new Map();
on(document, "click", (event) => {
  documentHandlerMap.forEach(({ exclude, handler }) => {
    const target = event.target;
    if (exclude.some((item) => item === target || item.contains(target))) {
      return;
    }
    handler(event);
  });
});
function createHandler(el, binding) {
  const exclude = [el];
  let handler = NoopFunction;
  if (isFunction(binding)) {
    handler = binding;
  } else if (isObject(binding)) {
    exclude.push(...binding.exclude.filter(Boolean));
    handler = binding.handler;
  }
  documentHandlerMap.set(el, { exclude, handler });
}
const clickOutside = {
  mounted(el, binding) {
    createHandler(el, binding.value);
  },
  updated(el, binding) {
    createHandler(el, binding.value);
  },
  unmounted(el) {
    documentHandlerMap.delete(el);
  }
};

const targetHashmap = {};
function covertTarget$1(target) {
  const temp = isFunction(target) ? target() : target;
  if (!isString(temp)) {
    return temp;
  }
  if (targetHashmap[temp]) {
    return targetHashmap[temp];
  }
  let element = document.querySelector(temp);
  if (!element) {
    element = document.createElement("div");
    element.classList.add(temp);
    document.body.appendChild(element);
  }
  targetHashmap[temp] = element;
  return element;
}
const portalTargetDef = IxPropTypes.oneOfType([
  String,
  HTMLElement,
  IxPropTypes.func()
]);
const portalProps = {
  disabled: IxPropTypes.bool,
  target: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]).isRequired,
  load: IxPropTypes.bool.def(true)
};
var Portal = defineComponent({
  name: "CdkPortal",
  props: portalProps,
  setup(props, {
    slots
  }) {
    const loaded = ref(props.load);
    watch(() => props.load, (load) => {
      if (!loaded.value) {
        loaded.value = load;
      }
    });
    const target = computed(() => loaded.value && covertTarget$1(props.target));
    return () => {
      const _target = target.value;
      if (!_target) {
        return null;
      }
      return createVNode(Teleport, {
        "to": _target,
        "disabled": props.disabled
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    };
  }
});
const CdkPortal = Portal;

function getScroll(target = window) {
  if (target === window) {
    return {
      scrollTop: target.pageYOffset || document.documentElement.scrollTop,
      scrollLeft: target.pageXOffset || document.documentElement.scrollLeft
    };
  } else {
    const { scrollTop, scrollLeft } = target;
    return { scrollTop, scrollLeft };
  }
}
const scrollToTop = (options = {}) => {
  const { top, amountOfChange, target = window, duration = 450, easing = easeInOutCubic, callback } = options;
  if (isNil(top) && isNil(amountOfChange)) {
    return;
  }
  const { scrollTop } = getScroll(target);
  const startTime = Date.now();
  const frameFunc = () => {
    const time = Date.now() - startTime;
    const elapsed = time > duration ? duration : time;
    const _amountOfChange = amountOfChange != null ? amountOfChange : top - scrollTop;
    const nextScrollTop = easing(elapsed, scrollTop, _amountOfChange, duration);
    if (target === window) {
      target.scrollTo(window.pageXOffset, nextScrollTop);
    } else {
      target.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      rAF(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  rAF(frameFunc);
};
let cachedScrollBarSize;
function getScrollBarSize(target) {
  if (isUndefined(document)) {
    return 0;
  }
  if (target) {
    const { width } = getComputedStyle(target, "::-webkit-scrollbar");
    const match = width.match(/^(.*)px$/);
    const value = Number(match == null ? void 0 : match[1]);
    if (!Number.isNaN(value)) {
      return value;
    }
  }
  if (cachedScrollBarSize === void 0) {
    const inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    const outer = document.createElement("div");
    const outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    const widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    let widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cachedScrollBarSize = widthContained - widthScroll;
  }
  return cachedScrollBarSize;
}
const defaultClassName = "cdk-scroll-block";
const cacheStrategy = /* @__PURE__ */ new Map();
const cacheStyle = /* @__PURE__ */ new Map();
let uuid = 0;
class BlockScrollStrategy {
  constructor(options = {}) {
    this.uid = uuid++;
    const { target = document.documentElement, className = defaultClassName } = options;
    this.target = target;
    this.className = className;
  }
  enable() {
    if (!this.isScrolled()) {
      return;
    }
    const { uid, target, className } = this;
    if (cacheStrategy.has(uid)) {
      return;
    }
    if (!Array.from(cacheStrategy.values()).some((item) => item.target === target)) {
      const scrollBarSize = getScrollBarSize(target === document.documentElement ? void 0 : target);
      cacheStyle.set(target, {
        width: target.style.width,
        overflow: target.style.overflow,
        overflowX: target.style.overflowX,
        overflowY: target.style.overflowY
      });
      target.style.width = scrollBarSize !== 0 ? `calc(100% - ${scrollBarSize}px)` : "";
      target.style.overflow = "hidden";
      target.style.overflowX = "hidden";
      target.style.overflowY = "hidden";
    }
    this.addClassName();
    cacheStrategy.set(uid, { target, className });
  }
  disable() {
    const { uid, target, className } = this;
    const currStrategy = cacheStrategy.get(uid);
    if (!currStrategy) {
      return;
    }
    cacheStrategy.delete(uid);
    const strategyArray = Array.from(cacheStrategy.values());
    if (!strategyArray.some((item) => item.target === target && item.className === className)) {
      removeClass(target, className);
    }
    if (!strategyArray.some((item) => item.target === target)) {
      const style = cacheStyle.get(target);
      target.style.width = style.width;
      target.style.overflow = style.overflow;
      target.style.overflowX = style.overflowX;
      target.style.overflowY = style.overflowY;
      cacheStyle.delete(target);
    }
  }
  update(options) {
    var _a, _b;
    const { uid, target, className } = this;
    const currStrategy = cacheStrategy.get(uid);
    if (currStrategy) {
      this.disable();
    }
    this.target = (_a = options.target) != null ? _a : target;
    this.className = (_b = options.className) != null ? _b : className;
    if (currStrategy) {
      currStrategy.target = this.target;
      currStrategy.className = this.className;
      this.enable();
    }
  }
  isScrolled() {
    const { target } = this;
    return target === document.documentElement && document.body.scrollWidth > window.innerWidth || target.scrollHeight > target.clientHeight;
  }
  addClassName() {
    const { target, className } = this;
    if (!target.classList.contains(className)) {
      addClass(target, className);
    }
  }
}
function useGetKey(props) {
  return computed(() => {
    const itemKey = props.itemKey;
    if (isString(itemKey)) {
      return (item) => {
        const key = item[itemKey];
        if (process.env.NODE_ENV !== "production" && key === void 0) {
          Logger.warn("cdk/scroll", "Each item in data should have a unique `key` prop.");
        }
        return key;
      };
    }
    return itemKey;
  });
}
function useHeights() {
  const itemMap = /* @__PURE__ */ new Map();
  const heights = /* @__PURE__ */ new Map();
  const heightsUpdateMark = ref(0);
  let heightUpdateId = 0;
  const collectHeights = () => {
    heightUpdateId += 1;
    const currentId = heightUpdateId;
    Promise.resolve().then(() => {
      if (currentId !== heightUpdateId) {
        return;
      }
      itemMap.forEach((element, key) => {
        if (element && element.offsetParent) {
          const { offsetHeight } = element;
          if (heights.get(key) !== offsetHeight) {
            heights.set(key, offsetHeight);
          }
        }
      });
      heightsUpdateMark.value++;
    });
  };
  const setItem = (key, item) => {
    const element = convertElement(item);
    if (element) {
      itemMap.set(key, element);
      collectHeights();
    } else {
      itemMap.delete(key);
    }
  };
  return { heights, collectHeights, heightsUpdateMark, setItem };
}
function useOriginScroll(scrolledTop, scrolledBottom) {
  let lock = false;
  let lockTimeout;
  const lockScroll = () => {
    clearTimeout(lockTimeout);
    lock = true;
    lockTimeout = setTimeout(() => lock = false, 50);
  };
  return (deltaY, smoothOffset = false) => {
    const originScroll = deltaY < 0 && scrolledTop.value || deltaY > 0 && scrolledBottom.value;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeout);
      lock = false;
    } else if (!originScroll || lock) {
      lockScroll();
    }
    return !lock && originScroll;
  };
}
const keepInRange = (maxScrollHeight, newScrollTop) => {
  let newTop = Math.max(newScrollTop, 0);
  if (!Number.isNaN(maxScrollHeight)) {
    newTop = Math.min(newTop, maxScrollHeight);
  }
  return newTop;
};
function useScrollPlacement(props, holderRef, scrollTop, scrollHeight, changeScrollTop) {
  const maxScrollHeight = computed(() => {
    const height = scrollHeight.value;
    return height > 0 ? height - props.height : NaN;
  });
  const scrolledTop = computed(() => scrollTop.value <= 0);
  const scrolledBottom = computed(() => scrollTop.value >= maxScrollHeight.value);
  watchEffect(() => {
    if (scrolledBottom.value) {
      callEmit(props.onScrolledBottom);
    }
  });
  const syncScrollTop = (newTop) => {
    const value = isFunction(newTop) ? newTop(scrollTop.value) : newTop;
    const alignedTop = keepInRange(maxScrollHeight.value, value);
    const holderElement = holderRef.value;
    if (holderElement) {
      holderElement.scrollTop = alignedTop;
    }
    changeScrollTop(alignedTop);
  };
  return { scrolledTop, scrolledBottom, syncScrollTop };
}
function useScrollState(props, fillerRef, useVirtual, getKey, scrollTop, heightUpdatedMark, heights) {
  const scrollHeight = ref(0);
  const scrollOffset = ref();
  const startIndex = ref(0);
  const endIndex = ref(0);
  watch([
    useVirtual,
    () => props.dataSource,
    () => props.itemHeight,
    () => props.height,
    getKey,
    scrollTop,
    heightUpdatedMark
  ], ([virtual, dataSource, itemHeight, height, getKey2, scrollTop2]) => {
    const {
      scrollHeight: totalHeight,
      offset,
      start,
      end
    } = calcState(fillerRef, virtual, dataSource, itemHeight, height, getKey2, scrollTop2, heights);
    scrollHeight.value = totalHeight;
    scrollOffset.value = offset;
    startIndex.value = start;
    endIndex.value = end;
  }, { immediate: true });
  return { scrollHeight, scrollOffset, startIndex, endIndex };
}
function calcState(fillerRef, virtual, dataSource, itemHeight, height, getKey, scrollTop, heights) {
  var _a, _b;
  const dataLength = dataSource.length;
  if (!virtual || dataLength === 0 || itemHeight * dataLength <= height) {
    return { scrollHeight: virtual ? (_b = (_a = fillerRef.value) == null ? void 0 : _a.offsetHeight) != null ? _b : 0 : 0, start: 0, end: dataLength - 1 };
  }
  let scrollHeight = 0;
  let offset;
  let start;
  let end;
  for (let index = 0; index < dataLength; index += 1) {
    const item = dataSource[index];
    const key = getKey(item);
    const cacheHeight = heights.get(key);
    const currentItemBottom = scrollHeight + (cacheHeight === void 0 ? itemHeight : cacheHeight);
    if (currentItemBottom >= scrollTop && start === void 0) {
      start = index;
      offset = scrollHeight;
    }
    if (currentItemBottom > scrollTop + height && end === void 0) {
      end = index;
    }
    scrollHeight = currentItemBottom;
  }
  if (start === void 0) {
    start = 0;
    offset = 0;
  }
  if (end === void 0) {
    end = dataLength - 1;
  }
  end = Math.min(end + 1, dataLength);
  return { scrollHeight, offset, start, end };
}
function useScrollTo(props, holderRef, getKey, heights, collectHeight, setScrollVisible, syncScrollTop) {
  let refId;
  return (option) => {
    if (isNil(option)) {
      setScrollVisible(true);
      return;
    }
    cancelRAF(refId);
    const { dataSource, itemHeight } = props;
    if (typeof option === "number") {
      syncScrollTop(option);
    } else if (typeof option === "object") {
      const { align, offset = 0 } = option;
      let index;
      if ("index" in option) {
        index = option.index;
      } else {
        index = dataSource.findIndex((item) => getKey.value(item) === option.key);
      }
      const syncScroll = (times, targetAlign) => {
        const holderElement = holderRef.value;
        if (times < 0 || !holderElement) {
          return;
        }
        const height = holderElement.clientHeight;
        let needCollectHeight = false;
        let newTargetAlign = targetAlign;
        if (height > 0) {
          const mergedAlign = targetAlign || align;
          let stackTop = 0;
          let itemTop = 0;
          let itemBottom = 0;
          for (let i = 0; i <= index; i++) {
            const itemKey = getKey.value(dataSource[i]);
            itemTop = stackTop;
            const cacheHeight = heights.get(itemKey);
            itemBottom = itemTop + (isNil(cacheHeight) ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i === index && isNil(cacheHeight)) {
              needCollectHeight = true;
            }
          }
          let targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset;
              break;
            default: {
              const { scrollTop } = holderElement;
              const scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== holderElement.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        refId = rAF(() => {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll(times - 1, newTargetAlign);
        });
      };
      syncScroll(3);
    }
  };
}
function useScrollVisible(props, scrollHeight) {
  const [visible, setScrollVisible] = useState$1(false);
  const scrollVisible = computed(() => {
    if (props.height >= scrollHeight.value) {
      return false;
    }
    return visible.value;
  });
  return { scrollVisible, setScrollVisible };
}
const virtualScrollToken = Symbol("virtualScrollToken");
var Holder = defineComponent({
  setup(_, {
    slots
  }) {
    const {
      props,
      slots: virtualScrollSlots,
      holderRef,
      fillerRef,
      useVirtual,
      collectHeights,
      scrollHeight,
      scrollOffset,
      scrollTop,
      scrollMoving,
      syncScrollTop,
      originScroll
    } = inject(virtualScrollToken);
    const style = computed(() => {
      const {
        height,
        fullHeight
      } = props;
      if (height <= 0) {
        return void 0;
      }
      return {
        [fullHeight ? "height" : "maxHeight"]: height + "px",
        overflowY: useVirtual.value ? "hidden" : "auto",
        overflowAnchor: "none",
        pointerEvents: useVirtual.value && scrollMoving.value ? "none" : void 0
      };
    });
    const fillerStyle = computed(() => {
      if (scrollOffset.value === void 0) {
        return void 0;
      }
      return {
        height: `${scrollHeight.value}px`,
        position: "relative",
        overflow: "hidden"
      };
    });
    const contentStyle = computed(() => {
      const offset = scrollOffset.value;
      if (offset === void 0) {
        return {
          display: "flex",
          flexDirection: "column"
        };
      }
      return {
        display: "flex",
        flexDirection: "column",
        transform: `translateY(${offset}px)`,
        position: "absolute",
        left: 0,
        right: 0,
        top: 0
      };
    });
    const handleScroll = (evt) => {
      const {
        scrollTop: newScrollTop
      } = evt.currentTarget;
      if (newScrollTop !== scrollTop.value) {
        syncScrollTop(newScrollTop);
      }
      callEmit(props.onScroll, evt);
    };
    const {
      handleWheel,
      handleTouchStart
    } = useEvents$1$1(holderRef, syncScrollTop, originScroll);
    const {
      contentRef
    } = useContentResize(collectHeights);
    return () => {
      var _a;
      const virtual = useVirtual.value;
      const children = slots.default();
      const contentRender = (_a = virtualScrollSlots.content) != null ? _a : props.contentRender;
      return createVNode("div", {
        "ref": holderRef,
        "class": "cdk-virtual-scroll-holder",
        "style": style.value,
        "onScroll": handleScroll,
        "onWheel": virtual ? handleWheel : void 0,
        "onTouchstart": virtual ? handleTouchStart : void 0
      }, [createVNode("div", {
        "ref": fillerRef,
        "class": "cdk-virtual-scroll-filler",
        "style": fillerStyle.value
      }, [createVNode("div", {
        "ref": contentRef,
        "class": "cdk-virtual-scroll-content",
        "style": contentStyle.value
      }, [contentRender ? contentRender(children) : children])])]);
    };
  }
});
const SMOOTH_PTG = 14 / 15;
function useEvents$1$1(holderRef, syncScrollTop, originScroll) {
  let offset = 0;
  let rafId;
  function handleWheel(evt) {
    cancelRAF(rafId);
    const {
      deltaY
    } = evt;
    offset += deltaY;
    if (originScroll(deltaY)) {
      return;
    }
    evt.preventDefault();
    rafId = rAF(() => {
      syncScrollTop((top) => top + offset);
      offset = 0;
    });
  }
  let touched = false;
  let touchY = 0;
  let intervalId;
  const handleTouchStart = (evt) => {
    const element = evt.target;
    removeEvents(element);
    if (evt.touches.length === 1 && !touched) {
      touched = true;
      touchY = Math.ceil(evt.touches[0].pageY);
      on(element, "touchmove", handleTouchMove);
      on(element, "touchend", handleTouchEnd);
    }
  };
  const touchMoveCallBack = (deltaY, smoothOffset) => {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    handleWheel({
      preventDefault() {
      },
      deltaY
    });
    return true;
  };
  const handleTouchMove = (evt) => {
    if (touched) {
      const currentY = Math.ceil(evt.touches[0].pageY);
      let offsetY = touchY - currentY;
      touchY = currentY;
      if (touchMoveCallBack(offsetY)) {
        evt.preventDefault();
      }
      clearInterval(intervalId);
      intervalId = setInterval(() => {
        offsetY *= SMOOTH_PTG;
        if (!touchMoveCallBack(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalId);
        }
      }, 16);
    }
  };
  const handleTouchEnd = (evt) => {
    touched = false;
    removeEvents(evt.target);
  };
  const removeEvents = (element) => {
    off(element, "touchmove", handleTouchMove);
    off(element, "touchend", handleTouchEnd);
  };
  onBeforeUnmount(() => {
    cancelRAF(rafId);
    clearInterval(intervalId);
    removeEvents(holderRef.value);
  });
  return {
    handleWheel,
    handleTouchStart
  };
}
function useContentResize(collectHeights) {
  const contentRef = ref();
  const onContentResize = throttle(collectHeights, 16);
  onMounted(() => onResize(contentRef.value, onContentResize));
  onBeforeUnmount(() => offResize(contentRef.value, onContentResize));
  return {
    contentRef
  };
}
const Item$3 = (_, {
  slots
}) => {
  const [firstChild] = slots.default();
  return firstChild;
};
var ScrollBar = defineComponent({
  setup() {
    const {
      props,
      scrollTop,
      scrollHeight,
      syncScrollTop,
      scrollMoving,
      changeScrollMoving,
      scrollVisible
    } = inject(virtualScrollToken);
    const thumbHight = useThumbHight(props);
    const enableScrollRange = useEnableScrollRange(props, scrollHeight);
    const enableHeightRange = useEnableHeightRange(props, thumbHight);
    const thumbTop = useThumbTop(scrollTop, enableScrollRange, enableHeightRange);
    const {
      scrollBarRef,
      handleScrollbarMouseDown,
      handleScrollbarTouchStart,
      thumbRef,
      handleThumbMouseDown,
      handleThumbMouseMove,
      handleThumbMouseUp
    } = useEvents$5(enableScrollRange, enableHeightRange, thumbTop, scrollMoving, changeScrollMoving, syncScrollTop);
    const style = useStyle$1(scrollVisible);
    const thumbClass = useThumbClass(scrollMoving);
    const thumbStyle = useThumbStyle(thumbHight, thumbTop);
    return () => createVNode("div", {
      "ref": scrollBarRef,
      "class": "cdk-virtual-scroll-bar",
      "style": style.value,
      "onMousedown": handleScrollbarMouseDown,
      "onTouchstart": handleScrollbarTouchStart
    }, [createVNode("div", {
      "ref": thumbRef,
      "class": thumbClass.value,
      "style": thumbStyle.value,
      "onMousedown": handleThumbMouseDown,
      "onTouchstart": handleThumbMouseDown,
      "onTouchmove": handleThumbMouseMove,
      "onTouchend": handleThumbMouseUp
    }, null)]);
  }
});
const getPageY = (evt) => {
  return "touches" in evt ? evt.touches[0].pageY : evt.pageY;
};
const minHight = 20;
const useThumbHight = (props) => {
  return computed(() => {
    const {
      height,
      dataSource
    } = props;
    let baseHeight = height / dataSource.length * 10;
    baseHeight = Math.max(baseHeight, minHight);
    baseHeight = Math.min(baseHeight, height / 2);
    return Math.floor(baseHeight);
  });
};
const useEnableScrollRange = (props, scrollHeight) => {
  return computed(() => scrollHeight.value - props.height);
};
const useEnableHeightRange = (props, thumbHight) => {
  return computed(() => props.height - thumbHight.value || 0);
};
const useThumbTop = (scrollTop, enableScrollRange, enableHeightRange) => {
  return computed(() => {
    const _scrollTop = scrollTop.value;
    if (_scrollTop === 0 || enableScrollRange.value === 0) {
      return 0;
    }
    const ptg = _scrollTop / enableScrollRange.value;
    return ptg * enableHeightRange.value;
  });
};
const useEvents$5 = (enableScrollRange, enableHeightRange, thumbTop, scrollMoving, changeScrollMoving, syncScrollTop) => {
  let pageY = 0;
  let startTop = 0;
  const scrollBarRef = ref();
  const thumbRef = ref();
  let rafId;
  const handleScrollbarTouchStart = (evt) => {
    evt.preventDefault();
  };
  const handleScrollbarMouseDown = (evt) => {
    evt.stopPropagation();
    evt.preventDefault();
  };
  const handleThumbMouseDown = (evt) => {
    changeScrollMoving(true);
    pageY = getPageY(evt);
    startTop = thumbTop.value;
    patchEvents();
    evt.stopPropagation();
    evt.preventDefault();
  };
  const handleThumbMouseMove = (evt) => {
    cancelRAF(rafId);
    if (scrollMoving.value) {
      const offsetY = getPageY(evt) - pageY;
      const newTop = startTop + offsetY;
      const ptg = enableHeightRange.value ? newTop / enableHeightRange.value : 0;
      const newScrollTop = Math.ceil(ptg * enableScrollRange.value);
      rafId = rAF(() => syncScrollTop(newScrollTop));
    }
  };
  const handleThumbMouseUp = () => {
    changeScrollMoving(false);
    removeEvents();
  };
  const patchEvents = () => {
    on(window, "mousemove", handleThumbMouseMove);
    on(window, "mouseup", handleThumbMouseUp);
  };
  const removeEvents = () => {
    off(window, "mousemove", handleThumbMouseMove);
    off(window, "mouseup", handleThumbMouseUp);
    cancelRAF(rafId);
  };
  onBeforeUnmount(() => {
    removeEvents();
    cancelRAF(rafId);
  });
  return {
    scrollBarRef,
    handleScrollbarMouseDown,
    handleScrollbarTouchStart,
    thumbRef,
    handleThumbMouseDown,
    handleThumbMouseMove,
    handleThumbMouseUp
  };
};
const useStyle$1 = (visible) => {
  return computed(() => {
    return {
      width: "8px",
      top: 0,
      bottom: 0,
      right: 0,
      position: "absolute",
      display: visible.value ? void 0 : "none"
    };
  });
};
const useThumbClass = (scrollMoving) => {
  return computed(() => {
    return {
      "cdk-virtual-scroll-thumb": true,
      "cdk-virtual-scroll-thumb-moving": scrollMoving.value
    };
  });
};
const useThumbStyle = (thumbHight, thumbTop) => {
  return computed(() => {
    return {
      width: "100%",
      height: thumbHight.value + "px",
      top: thumbTop.value + "px",
      left: 0,
      position: "absolute",
      background: "rgba(0, 0, 0, 0.5)",
      borderRadius: "99px",
      cursor: "pointer",
      userSelect: "none"
    };
  });
};
const virtualListProps = {
  contentRender: IxPropTypes.func(),
  dataSource: IxPropTypes.array().def(() => []),
  fullHeight: IxPropTypes.bool.def(false),
  height: IxPropTypes.number.def(0),
  itemHeight: IxPropTypes.number.def(0),
  itemKey: IxPropTypes.oneOfType([String, IxPropTypes.func()]).isRequired,
  itemRender: IxPropTypes.func(),
  virtual: IxPropTypes.bool.def(true),
  onScroll: IxPropTypes.emit(),
  onScrolledChange: IxPropTypes.emit(),
  onScrolledBottom: IxPropTypes.emit()
};
var VirtualScroll = defineComponent({
  name: "CdkVirtualScroll",
  props: virtualListProps,
  setup(props, {
    expose,
    slots
  }) {
    const useVirtual = computed(() => props.virtual && props.height > 0 && props.itemHeight > 0);
    const getKey = useGetKey(props);
    const {
      heights,
      collectHeights,
      heightsUpdateMark,
      setItem
    } = useHeights();
    const holderRef = ref();
    const fillerRef = ref();
    const [scrollTop, changeScrollTop] = useState$1(0);
    const [scrollMoving, changeScrollMoving] = useState$1(false);
    const {
      scrollHeight,
      scrollOffset,
      startIndex,
      endIndex
    } = useScrollState(props, fillerRef, useVirtual, getKey, scrollTop, heightsUpdateMark, heights);
    const {
      scrollVisible,
      setScrollVisible
    } = useScrollVisible(props, scrollHeight);
    const {
      scrolledTop,
      scrolledBottom,
      syncScrollTop
    } = useScrollPlacement(props, holderRef, scrollTop, scrollHeight, changeScrollTop);
    const originScroll = useOriginScroll(scrolledTop, scrolledBottom);
    provide(virtualScrollToken, {
      props,
      slots,
      holderRef,
      fillerRef,
      useVirtual,
      collectHeights,
      scrollTop,
      scrollHeight,
      scrollOffset,
      scrollVisible,
      setScrollVisible,
      scrollMoving,
      changeScrollMoving,
      syncScrollTop,
      originScroll
    });
    const scrollTo = useScrollTo(props, holderRef, getKey, heights, collectHeights, setScrollVisible, syncScrollTop);
    expose({
      scrollTo
    });
    const mergedData = computed(() => props.dataSource.slice(startIndex.value, endIndex.value + 1));
    watch(mergedData, (data) => callEmit(props.onScrolledChange, startIndex.value, endIndex.value, data));
    let stopWatchScrollMoving;
    const clearWatch = () => {
      if (stopWatchScrollMoving) {
        stopWatchScrollMoving();
        stopWatchScrollMoving = void 0;
      }
    };
    const handleMouseEnter = () => {
      clearWatch();
      if (!scrollMoving.value) {
        setScrollVisible(true);
      }
    };
    const handleMouseLeave = () => {
      clearWatch();
      if (!scrollMoving.value) {
        setScrollVisible(false);
      } else {
        stopWatchScrollMoving = watch(scrollMoving, () => {
          setScrollVisible(false);
        });
      }
    };
    return () => {
      var _a;
      const getKeyFn = getKey.value;
      const start = startIndex.value;
      const itemRender = (_a = slots.item) != null ? _a : props.itemRender;
      const children = mergedData.value.map((item, index) => {
        const key = getKeyFn(item);
        return createVNode(Item$3, {
          "key": key,
          "ref": (instance) => setItem(key, instance)
        }, {
          default: () => [itemRender == null ? void 0 : itemRender({
            item,
            index: start + index
          })]
        });
      });
      return createVNode("div", {
        "class": "cdk-virtual-scroll",
        "style": {
          position: "relative"
        },
        "onMouseenter": handleMouseEnter,
        "onMouseleave": handleMouseLeave
      }, [createVNode(Holder, null, {
        default: () => [children]
      }), useVirtual.value && createVNode(ScrollBar, null, null)]);
    };
  }
});
const CdkVirtualScroll = VirtualScroll;

const version$2 = '1.0.0-alpha.6';

const components$2 = [CdkPortal, CdkVirtualScroll];
const directives$2 = {
    clickOutside,
};
const install$3 = (app) => {
    components$2.forEach(component => {
        var _a;
        app.component((_a = component.name) !== null && _a !== void 0 ? _a : component.displayName, component);
    });
    Object.keys(directives$2).forEach(key => {
        app.directive(key, directives$2[key]);
    });
};
var index$2 = {
    install: install$3,
    version: version$2,
};

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name addQuarters
 * @category Quarter Helpers
 * @summary Add the specified number of year quarters to the given date.
 *
 * @description
 * Add the specified number of year quarters to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of quarters to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the quarters added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 1 quarter to 1 September 2014:
 * const result = addQuarters(new Date(2014, 8, 1), 1)
 * //=> Mon Dec 01 2014 00:00:00
 */

function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months = amount * 3;
  return addMonths(dirtyDate, months);
}

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */

function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */

function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * var result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 * 
 * @example
 * // Are 4 September and 4 October in the same day?
 * var result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 * 
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * var result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name getQuarter
 * @category Quarter Helpers
 * @summary Get the year quarter of the given date.
 *
 * @description
 * Get the year quarter of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which quarter is 2 July 2014?
 * const result = getQuarter(new Date(2014, 6, 2))
 * //=> 3
 */

function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a minute
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */

function startOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setSeconds(0, 0);
  return date;
}

/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */

function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */

function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * var result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */

function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfQuarter
 * @category Quarter Helpers
 * @summary Return the end of a year quarter for the given date.
 *
 * @description
 * Return the end of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a quarter for 2 September 2014 11:55:00:
 * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

var formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance$1 = function (token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale$1[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

var formatDistance$2 = formatDistance$1;

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats$1 = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats$1 = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats$1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: 'full'
  })
};
var formatLong$3 = formatLong$2;

var formatRelativeLocale$1 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative$1 = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale$1[token];
};

var formatRelative$2 = formatRelative$1;

function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues$1 = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues$1 = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues$1 = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues$1 = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues$1 = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues$1 = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber$1 = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize$2 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: 'wide'
  })
};
var localize$3 = localize$2;

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern$1 = /\d+/i;
var matchEraPatterns$1 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns$1 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns$1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns$1 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns$1 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns$1 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns$1 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns$1 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: 'any'
  })
};
var match$3 = match$2;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale$1 = {
  code: 'en-US',
  formatDistance: formatDistance$2,
  formatLong: formatLong$3,
  formatRelative: formatRelative$2,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var enUS$1 = locale$1;

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$2 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$2 = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return formatters$3.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return formatters$3.d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return formatters$3.m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$1 = formatters;

function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format$1(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || enUS$1;
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$1).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }

    var formatter = formatters$1[firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}

function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  dirtyObject = dirtyObject || {};

  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }

  return target;
}

/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */

function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}

/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */

function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */

function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */

function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}

/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */

function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */

function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}

/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */

function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the local week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(dirtyDate, options) {
  var _options$locale, _options$locale$optio;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var localeFirstWeekContainsDate = options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = (options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the start of a week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */

function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var MILLISECONDS_IN_SECOND = 1000;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  }

  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}

function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}

function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}

function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
  }
}

function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
  }
}

function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */


var parsers = {
  // Era
  G: {
    priority: 140,
    parse: function (string, token, match, _options) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(string, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(string, {
            width: 'wide'
          }) || match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
      }
    },
    set: function (date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['R', 'u', 't', 'T']
  },
  // Year
  y: {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return parseNDigits(4, string, valueCallback);

        case 'yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Local week-numbering year
  Y: {
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return parseNDigits(4, string, valueCallback);

        case 'Yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week-numbering year
  R: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'R') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Extended year
  u: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'u') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Quarter
  Q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone quarter
  q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Month
  M: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone month
  L: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Local week of year
  w: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, string);

        case 'wo':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week of year
  I: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, string);

        case 'Io':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Day of the month
  d: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, string);

        case 'do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Day of year
  D: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, string);

        case 'Do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
  },
  // Day of week
  E: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
  },
  // Local day of week
  e: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'eo':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'eee':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
  },
  // Stand-alone local day of week
  c: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'co':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'ccc':
          return match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
  },
  // ISO day of week
  i: {
    priority: 90,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, string);
        // 2nd

        case 'io':
          return match.ordinalNumber(string, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // T

        case 'iiiii':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tu

        case 'iiiiii':
          return match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tuesday

        case 'iiii':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function (date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
  },
  // AM or PM
  a: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['b', 'B', 'H', 'k', 't', 'T']
  },
  // AM, PM, midnight
  b: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'B', 'H', 'k', 't', 'T']
  },
  // in the morning, in the afternoon, in the evening, at night
  B: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 't', 'T']
  },
  // Hour [1-12]
  h: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, string);

        case 'ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['H', 'K', 'k', 't', 'T']
  },
  // Hour [0-23]
  H: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, string);

        case 'Ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
  },
  // Hour [0-11]
  K: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, string);

        case 'Ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['h', 'H', 'k', 't', 'T']
  },
  // Hour [1-24]
  k: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, string);

        case 'ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function (date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
  },
  // Minute
  m: {
    priority: 60,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, string);

        case 'mo':
          return match.ordinalNumber(string, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Second
  s: {
    priority: 50,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, string);

        case 'so':
          return match.ordinalNumber(string, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Fraction of second
  S: {
    priority: 30,
    parse: function (string, token, _match, _options) {
      var valueCallback = function (value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return parseNDigits(token.length, string, valueCallback);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Timezone (ISO-8601. +00:00 is `'Z'`)
  X: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'x']
  },
  // Timezone (ISO-8601)
  x: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'X']
  },
  // Seconds timestamp
  t: {
    priority: 40,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  },
  // Milliseconds timestamp
  T: {
    priority: 20,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  }
};
var parsers$1 = parsers;

var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Old `parse` was renamed to `toDate`.
 *   Now `parse` is a new function which parses a string using a provided format.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward (toDate no longer accepts a string)
 *   toDate(1392098430000) // Unix to timestamp
 *   toDate(new Date(2014, 1, 11, 11, 30, 30)) // Cloning the date
 *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
 *   ```
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale = options.locale || enUS$1;

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, subFnOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }

    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }

    var firstCharacter = token[0];
    var parser = parsers$1[firstCharacter];

    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;

      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;

        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;

          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }

        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }

      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);

      if (!parseResult) {
        return new Date(NaN);
      }

      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      } // Replace two single quote characters with one single quote character


      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      } // Cut token from string, or, if string doesn't match the token, return Invalid Date


      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  } // Check if the remaining input contains something other than whitespace


  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);

  if (isNaN(date)) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};

  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];

    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }

    var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]); // Result is date
    } else {
      utcDate = result;
    }
  }

  return utcDate;
}

function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }

  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */

function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}

/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same hour (and same day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * var result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 * 
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * var result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */

function isSameHour(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}

/**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Boolean} the dates are in the same week (and month and year)
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * var result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * var result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 * 
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * var result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameWeek(dirtyDateLeft, dirtyDateRight, dirtyOptions) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfWeek(dirtyDateLeft, dirtyOptions);
  var dateRightStartOfWeek = startOfWeek(dirtyDateRight, dirtyOptions);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

/**
 * @name isSameMinute
 * @category Minute Helpers
 * @summary Are the given dates in the same minute (and hour and day)?
 *
 * @description
 * Are the given dates in the same minute (and hour and day)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same minute (and hour and day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
 * var result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 4, 6, 30, 15)
 * )
 * //=> true
 * 
 * @example
 * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
 * var result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 5, 6, 30)
 * )
 * //=> false
 */

function isSameMinute(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfMinute = startOfMinute(dirtyDateLeft);
  var dateRightStartOfMinute = startOfMinute(dirtyDateRight);
  return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
}

/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * var result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * var result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */

function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

/**
 * @name isSameQuarter
 * @category Quarter Helpers
 * @summary Are the given dates in the same quarter (and year)?
 *
 * @description
 * Are the given dates in the same quarter (and year)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same quarter (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 1 January 2014 and 8 March 2014 in the same quarter?
 * var result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
 * //=> true
 * 
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same quarter?
 * var result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */

function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}

/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a second
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */

function startOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMilliseconds(0);
  return date;
}

/**
 * @name isSameSecond
 * @category Second Helpers
 * @summary Are the given dates in the same second (and hour and day)?
 *
 * @description
 * Are the given dates in the same second (and hour and day)?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same second (and hour and day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
 * var result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 30, 15),
 *   new Date(2014, 8, 4, 6, 30, 15, 500)
 * )
 * //=> true
 * 
 * @example
 * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
 * var result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 4, 6, 1, 15)
 * )
 * //=> false
 * 
 * @example
 * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
 * var result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 5, 6, 0, 15)
 * )
 * //=> false
 */

function isSameSecond(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfSecond = startOfSecond(dirtyDateLeft);
  var dateRightStartOfSecond = startOfSecond(dirtyDateRight);
  return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
}

/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * var result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */

function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */

function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} dayOfMonth - the day of the month of the new date
 * @returns {Date} the new date with the day of the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * var result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */

function setDate(dirtyDate, dirtyDayOfMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = toInteger(dirtyDayOfMonth);
  date.setDate(dayOfMonth);
  return date;
}

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} day - the day of the week of the new date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the new date with the day of the week set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * var result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * var result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var delta = 7 - weekStartsOn;
  var diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date, diff);
}

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} hours - the hours of the new date
 * @returns {Date} the new date with the hours set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * var result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */

function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} minutes - the minutes of the new date
 * @returns {Date} the new date with the minutes set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */

function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} quarter - the quarter of the new date
 * @returns {Date} the new date with the quarter set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */

function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return setMonth(date, date.getMonth() + diff * 3);
}

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} seconds - the seconds of the new date
 * @returns {Date} the new date with the seconds set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */

function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} week - the week of the new date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the new date with the local week set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * var result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * var result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getWeek(date, options) - week;
  date.setDate(date.getDate() - diff * 7);
  return date;
}

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */

function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  date.setFullYear(year);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfUTCWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfUTCWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xSeconds: {
    one: '1 ',
    other: '{{count}} '
  },
  halfAMinute: '',
  lessThanXMinutes: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMinutes: {
    one: '1 ',
    other: '{{count}} '
  },
  xHours: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXHours: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xDays: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXWeeks: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xWeeks: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXMonths: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMonths: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xYears: {
    one: '1 ',
    other: '{{count}} '
  },
  overXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  almostXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return result + '';
    } else {
      return result + '';
    }
  }

  return result;
}

var dateFormats = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: 'yyyy-MM-dd',
  short: 'yy-MM-dd'
};
var timeFormats = {
  full: 'zzzz a h:mm:ss',
  long: 'z a h:mm:ss',
  medium: 'a h:mm:ss',
  short: 'a h:mm'
};
var dateTimeFormats = {
  full: '{{date}} {{time}}',
  long: '{{date}} {{time}}',
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

function checkWeek(_date, _baseDate, _options, baseFormat) {
  if (isSameUTCWeek(_date, _baseDate, _options)) {
    return baseFormat; // in same week
  } else if (_date.getTime() > _baseDate.getTime()) {
    return "''" + baseFormat; // in next week
  }

  return "''" + baseFormat; // in last week
}

var formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: 'PP p'
};
function formatRelative(token, _date, _baseDate, _options) {
  var format = formatRelativeLocale[token];

  if (typeof format === 'function') {
    return format(_date, _baseDate, _options, 'eeee p');
  }

  return format;
}

var eraValues = {
  narrow: ['', ''],
  abbreviated: ['', ''],
  wide: ['', '']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['', '', '', ''],
  wide: ['', '', '', '']
};
var monthValues = {
  narrow: ['', '', '', '', '', '', '', '', '', '', '', ''],
  abbreviated: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  wide: ['', '', '', '', '', '', '', '', '', '', '', '']
};
var dayValues = {
  narrow: ['', '', '', '', '', '', ''],
  short: ['', '', '', '', '', '', ''],
  abbreviated: ['', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '']
};
var dayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};

function ordinalNumber(dirtyNumber, dirtyOptions) {
  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'
  var number = Number(dirtyNumber);
  var options = dirtyOptions || {};
  var unit = String(options.unit);

  switch (unit) {
    case 'date':
      return number.toString() + '';

    case 'hour':
      return number.toString() + '';

    case 'minute':
      return number.toString() + '';

    case 'second':
      return number.toString() + '';

    default:
      return ' ' + number.toString();
  }
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

var matchOrdinalNumberPattern = /^(\s*)?\d+(|||)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
var parseEraPatterns = {
  any: [/^()/i, /^()/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseQuarterPatterns = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
var matchMonthPatterns = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
var parseMonthPatterns = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^(?!(|))/i, /^/i, /^/i],
  any: [/^|1/i, /^|2/i, /^|3/i, /^|4/i, /^|5/i, /^|6/i, /^|7/i, /^|8/i, /^|9/i, /^(?!(|))|10/i, /^|11/i, /^|12/i]
};
var matchDayPatterns = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseDayPatterns = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
var matchDayPeriodPatterns = {
  any: /^(?|?||[]|?||?||)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

/**
 * @type {Locale}
 * @category Locales
 * @summary Chinese Simplified locale.
 * @language Chinese Simplified
 * @iso-639-2 zho
 * @author Changyu Geng [@KingMario]{@link https://github.com/KingMario}
 * @author Song Shuoyun [@fnlctrl]{@link https://github.com/fnlctrl}
 * @author sabrinaM [@sabrinamiao]{@link https://github.com/sabrinamiao}
 * @author Carney Wu [@cubicwork]{@link https://github.com/cubicwork}
 * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
 */

var locale = {
  code: 'zh-CN',
  formatDistance: formatDistance,
  formatLong: formatLong$1,
  formatRelative: formatRelative,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
var zhCN$1 = locale;

const zhCN = {
  type: "zh-CN",
  date: zhCN$1,
  datePicker: {
    today: "\u4ECA\u5929",
    ok: "\u786E\u5B9A",
    clear: "\u6E05\u9664",
    month: "\u6708",
    year: "\u5E74",
    monthSelect: "\u9009\u62E9\u6708\u4EFD",
    yearSelect: "\u9009\u62E9\u5E74\u4EFD",
    monthFormat: "MMM",
    yearFormat: "yyyy\u5E74",
    previousMonth: "\u4E0A\u4E2A\u6708",
    nextMonth: "\u4E0B\u4E2A\u6708",
    previousYear: "\u4E0A\u4E00\u5E74",
    nextYear: "\u4E0B\u4E00\u5E74",
    previousDecade: "\u4E0A\u4E00\u5E74\u4EE3",
    nextDecade: "\u4E0B\u4E00\u5E74\u4EE3",
    datePlaceholder: "\u8BF7\u9009\u62E9\u65E5\u671F",
    yearPlaceholder: "\u8BF7\u9009\u62E9\u5E74\u4EFD",
    quarterPlaceholder: "\u8BF7\u9009\u62E9\u5B63\u5EA6",
    monthPlaceholder: "\u8BF7\u9009\u62E9\u6708\u4EFD",
    weekPlaceholder: "\u8BF7\u9009\u62E9\u5468"
  },
  dateRangePicker: {
    datePlaceholder: ["\u5F00\u59CB\u65E5\u671F", "\u7ED3\u675F\u65E5\u671F"],
    weekPlaceholder: ["\u5F00\u59CB\u5468", "\u7ED3\u675F\u5468"],
    monthPlaceholder: ["\u5F00\u59CB\u6708\u4EFD", "\u7ED3\u675F\u6708\u4EFD"],
    quarterPlaceholder: ["\u5F00\u59CB\u5B63\u5EA6", "\u7ED3\u675F\u5B63\u5EA6"],
    yearPlaceholder: ["\u5F00\u59CB\u5E74\u4EFD", "\u7ED3\u675F\u5E74\u4EFD"]
  },
  empty: {
    description: "\u6682\u65E0\u6570\u636E"
  },
  modal: {
    cancelText: "\u53D6\u6D88",
    okText: "\u786E\u5B9A",
    justOkText: "\u6211\u77E5\u9053\u4E86"
  },
  popconfirm: {
    cancelText: "\u53D6\u6D88",
    okText: "\u786E\u5B9A"
  },
  pagination: {
    itemsPerPage: "\u6761/\u9875",
    jumpTo: "\u524D\u5F80",
    page: "\u9875",
    prev: "\u4E0A\u4E00\u9875",
    next: "\u4E0B\u4E00\u9875",
    prev5: "\u5411\u524D 5 \u9875",
    next5: "\u5411\u540E 5 \u9875",
    totalPrefix: "\u5171",
    totalSuffix: "\u6761"
  },
  table: {
    expand: "\u5C55\u5F00\u884C",
    collapse: "\u6536\u8D77\u884C",
    filterTitle: "\u7B5B\u9009",
    filterConfirm: "\u786E\u5B9A",
    filterReset: "\u91CD\u7F6E",
    filterEmptyText: "\u65E0\u7B5B\u9009\u9879",
    selectAll: "\u5168\u9009\u6240\u6709",
    selectInvert: "\u53CD\u9009\u6240\u6709",
    selectNone: "\u6E05\u7A7A\u6240\u6709",
    selectPageAll: "\u5168\u9009\u5F53\u9875",
    selectPageInvert: "\u53CD\u9009\u5F53\u9875",
    sortDesc: "\u70B9\u51FB\u964D\u5E8F",
    sortAsc: "\u70B9\u51FB\u5347\u5E8F",
    sortCancel: "\u53D6\u6D88\u6392\u5E8F"
  },
  timePicker: {
    okText: "\u786E\u5B9A",
    placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4"
  },
  timeRangePicker: {
    okText: "\u786E\u5B9A",
    separator: "\u81F3",
    placeholder: ["\u8D77\u59CB\u65F6\u95F4", "\u7ED3\u675F\u65F6\u95F4"]
  },
  upload: {
    uploading: "\u6B63\u5728\u4E0A\u4F20...",
    error: "\u4E0A\u4F20\u5931\u8D25",
    cancel: "\u53D6\u6D88\u4E0A\u4F20",
    preview: "\u9884\u89C8\u6587\u4EF6",
    remove: "\u5220\u9664\u6587\u4EF6",
    retry: "\u91CD\u65B0\u4E0A\u4F20",
    download: "\u4E0B\u8F7D\u6587\u4EF6"
  }
};
const currentType = ref("zh-CN");
const localeMap = { "zh-CN": zhCN };
function getLocale(key) {
  return computed(() => {
    let currLocale = localeMap[currentType.value];
    if (!currLocale) {
      currLocale = zhCN;
    }
    return key ? currLocale[key] : currLocale;
  });
}

const DATE_CONFIG_TOKEN = Symbol("DATE_CONFIG_TOKEN");
let defaultDateConfig;
function useDateConfig() {
  const config = inject(DATE_CONFIG_TOKEN, null);
  if (config) {
    return config;
  }
  if (!defaultDateConfig) {
    defaultDateConfig = createDefaultDateConfig();
  }
  return defaultDateConfig;
}
function createDefaultDateConfig() {
  const locale = getLocale("date");
  const now = () => new Date();
  const parse$1 = (dateString, format2) => parse(dateString, format2, now(), { locale: locale.value });
  return {
    now,
    weekStartsOn: () => {
      var _a;
      return ((_a = locale.value.options) == null ? void 0 : _a.weekStartsOn) || 1;
    },
    get: (date, type) => {
      switch (type) {
        case "year":
          return getYear(date);
        case "quarter":
          return getQuarter(date);
        case "month":
          return getMonth(date);
        case "week":
          return getWeek(date, { locale: locale.value });
        case "date":
          return getDate(date);
        case "day":
          return getDay(date);
        case "hour":
          return getHours(date);
        case "minute":
          return getMinutes(date);
        case "second":
          return getSeconds(date);
      }
    },
    set: (date, amount, type) => {
      switch (type) {
        case "year":
          return setYear(date, amount);
        case "quarter":
          return setQuarter(date, amount);
        case "month":
          return setMonth(date, amount);
        case "week":
          return setWeek(date, amount, { locale: locale.value });
        case "date":
          return setDate(date, amount);
        case "day":
          return setDay(date, amount, { locale: locale.value });
        case "hour":
          return setHours(date, amount);
        case "minute":
          return setMinutes(date, amount);
        case "second":
          return setSeconds(date, amount);
      }
    },
    add: (date, amount, type) => {
      switch (type) {
        case "year":
          return addYears(date, amount);
        case "quarter":
          return addQuarters(date, amount);
        case "month":
          return addMonths(date, amount);
        case "week":
          return addWeeks(date, amount);
        case "date":
        case "day":
          return addDays(date, amount);
      }
    },
    startOf: (date, type) => {
      switch (type) {
        case "year":
          return startOfYear(date);
        case "quarter":
          return startOfQuarter(date);
        case "month":
          return startOfMonth(date);
        case "week":
          return startOfWeek(date, { locale: locale.value });
        case "date":
        case "day":
          return startOfDay(date);
      }
    },
    endOf: (date, type) => {
      switch (type) {
        case "year":
          return endOfYear(date);
        case "quarter":
          return endOfQuarter(date);
        case "month":
          return endOfMonth(date);
        case "week":
          return endOfWeek(date, { locale: locale.value });
        case "date":
        case "day":
          return endOfDay(date);
      }
    },
    isSame: (date, dateToCompare, type) => {
      switch (type) {
        case "year":
          return isSameYear(date, dateToCompare);
        case "quarter":
          return isSameQuarter(date, dateToCompare);
        case "month":
          return isSameMonth(date, dateToCompare);
        case "week":
          return isSameWeek(date, dateToCompare, { locale: locale.value });
        case "date":
        case "day":
          return isSameDay(date, dateToCompare);
        case "hour":
          return isSameHour(date, dateToCompare);
        case "minute":
          return isSameMinute(date, dateToCompare);
        case "second":
          return isSameSecond(date, dateToCompare);
      }
    },
    isValid: (date) => isValid(date),
    format: (date, format$1$1) => format$1(date, format$1$1, { locale: locale.value }),
    parse: parse$1,
    convert: (date, format2) => {
      if (isNil(date)) {
        return now();
      }
      return isString(date) ? parse$1(date, format2) : toDate(date);
    },
    getLocalizedLabels: (type, length, width) => {
      const localize = locale.value.localize;
      switch (type) {
        case "month":
          return Array.from({ length }).map((_, i) => localize.month(i, { width }));
        case "day":
          return Array.from({ length }).map((_, i) => localize.day(i, { width }));
        case "dayPeriod":
          return Array.from({ length }).map((_, i) => localize.dayPeriod(i, { width }));
      }
    }
  };
}
function numFormatter(value, precision) {
  const separator = ".";
  const numReg = /^(\d+)(\.(\d+))?$/;
  const numMatchRet = String(value).match(numReg);
  if (!numMatchRet) {
    return {
      value: String(value),
      int: "",
      decimal: ""
    };
  } else {
    const int = String(numMatchRet[1]);
    let decimal = String(numMatchRet[3] || "").slice(0, precision).padEnd(precision, "0");
    decimal = decimal.length > 0 ? `${separator}${decimal}` : "";
    return {
      value: `${int}${decimal}`,
      int,
      decimal
    };
  }
}
const common$1 = { prefixCls: "ix" };
const icon = {};
const tag = {};
const divider = {
  dashed: false,
  labelPlacement: "center",
  plain: false,
  size: "md"
};
const space = { size: "md", wrap: true };
const row = { wrap: true };
const dropdown = {
  autoAdjust: true,
  destroyOnHide: false,
  offset: [0, 8],
  placement: "bottomStart",
  showArrow: false,
  trigger: "hover"
};
const menu = {
  indent: 24,
  offset: [0, 8],
  suffix: "right",
  theme: "light"
};
const pagination = {
  pageSize: 10,
  pageSizes: [10, 20, 50, 100],
  showQuickJumper: false,
  showSizeChanger: false,
  showTitle: true,
  showTotal: true,
  simple: false,
  size: "md"
};
const form = {
  colonless: false,
  labelAlign: "end",
  layout: "horizontal",
  size: "md"
};
const checkbox = { size: "md" };
const datePicker = {
  allowInput: true,
  borderless: false,
  clearable: false,
  clearIcon: "close-circle",
  size: "md",
  suffix: "calendar"
};
const dateRangePicker = { separator: "swap-right" };
const inputNumber = {
  keyboard: true,
  size: "md"
};
const input = {
  borderless: false,
  clearable: false,
  clearIcon: "close-circle",
  size: "md"
};
const rate = {
  allowHalf: false,
  clearable: false,
  count: 5,
  icon: "star-filled",
  size: "md"
};
const radio = {
  size: "md"
};
const select = {
  borderless: false,
  childrenKey: "children",
  labelKey: "label",
  size: "md",
  suffix: "down",
  valueKey: "value"
};
const textarea = {
  autoRows: false,
  clearable: false,
  clearIcon: "close-circle",
  resize: "vertical",
  showCount: false,
  size: "md"
};
const timePicker = {
  borderless: false,
  clearable: true,
  clearIcon: "close-circle",
  size: "md",
  suffix: "clock-circle",
  allowInput: true,
  format: "HH:mm:ss"
};
const timeRangePicker = {
  borderless: false,
  clearable: true,
  clearIcon: "close-circle",
  size: "md",
  suffix: "clock-circle",
  allowInput: true,
  format: "HH:mm:ss"
};
const treeSelect = {
  size: "md",
  suffix: "down",
  childrenKey: "children",
  labelKey: "label",
  nodeKey: "key"
};
const upload$1 = {
  multiple: false,
  dragable: false,
  directory: false,
  name: "file",
  withCredentials: false,
  requestMethod: "post"
};
const uploadFiles = {
  type: "text",
  icon: {
    file: "paper-clip",
    remove: "delete",
    retry: "edit"
  }
};
const avatar = {
  gap: 4,
  icon: "user",
  shape: "circle",
  size: "md"
};
const badge = { showZero: false, dot: false, overflowCount: 99 };
const card = {
  borderless: false,
  hoverable: false,
  size: "md"
};
const empty = {
  icon: "empty"
};
const list = {
  size: "md",
  borderless: true
};
const collapse = {
  accordion: false,
  borderless: false,
  expandIcon: "right",
  ghost: false
};
const image = {
  preview: true
};
const imageViewer = {
  loop: true,
  maskClosable: true,
  zoom: [0.5, 2]
};
const statistic = {
  precision: 0,
  formatter: numFormatter
};
const table = {
  borderless: true,
  rowKey: "key",
  size: "md",
  extra: { icon: "ellipsis" },
  pagination: { position: "bottomEnd" },
  columnBase: {
    align: "start",
    sortable: { nextTooltip: false, orders: ["ascend", "descend"] },
    filterable: { multiple: true, footer: true }
  },
  columnExpandable: { icon: "right" }
};
const tooltip = {
  autoAdjust: true,
  delay: 100,
  destroyOnHide: false,
  placement: "top",
  trigger: "hover"
};
const tree = {
  blocked: false,
  expandIcon: "right",
  nodeKey: "key",
  showLine: false
};
const popover = {
  autoAdjust: true,
  delay: 100,
  destroyOnHide: false,
  placement: "top",
  showArrow: true,
  trigger: "hover",
  closeIcon: "close"
};
const message = {
  destroyOnHover: false,
  duration: 3e3,
  maxCount: 5,
  icon: {
    success: "check-circle-filled",
    error: "close-circle-filled",
    info: "info-circle-filled",
    warning: "exclamation-circle-filled",
    loading: "loading"
  }
};
const notification = {
  destroyOnHover: false,
  duration: 4500,
  maxCount: 5,
  offset: 24,
  placement: "topEnd"
};
const modal = {
  centered: false,
  closable: true,
  closeIcon: "close",
  closeOnEsc: true,
  mask: true,
  maskClosable: true,
  width: 520
};
const alert = {
  closable: false,
  icon: {
    success: "check-circle",
    error: "info-circle",
    info: "bulb",
    warning: "exclamation-circle"
  }
};
const skeleton = {
  animated: true
};
const carousel = {
  autoplayTime: 0,
  dotPlacement: "bottom",
  showArrow: false,
  trigger: "click"
};
const drawer = {
  closable: true,
  closeOnEsc: true,
  closeIcon: "close",
  height: 256,
  mask: true,
  maskClosable: true,
  width: 480
};
const result = { status: "info" };
const spin = {
  tip: "",
  tipAlign: "vertical",
  size: "md"
};
const popconfirm = {
  autoAdjust: true,
  delay: 100,
  destroyOnHide: false,
  placement: "top",
  trigger: "click"
};
const progress = {
  strokeLinecap: "round",
  size: "md",
  format: (percent) => percent + "%"
};
const stepper = {
  clickable: false,
  labelPlacement: "end",
  size: "md"
};
const backTop = {
  duration: 450,
  visibilityHeight: 400
};
const anchor = {
  bounds: 5,
  hideLinkBall: false
};
const defaultConfig$1 = {
  common: common$1,
  icon,
  tag,
  divider,
  space,
  row,
  dropdown,
  menu,
  pagination,
  form,
  checkbox,
  datePicker,
  dateRangePicker,
  input,
  inputNumber,
  rate,
  radio,
  select,
  textarea,
  timePicker,
  timeRangePicker,
  treeSelect,
  upload: upload$1,
  uploadFiles,
  avatar,
  badge,
  card,
  empty,
  carousel,
  list,
  collapse,
  image,
  imageViewer,
  statistic,
  table,
  tooltip,
  tree,
  popover,
  alert,
  skeleton,
  message,
  notification,
  modal,
  drawer,
  result,
  spin,
  progress,
  popconfirm,
  stepper,
  backTop,
  anchor
};
const tokens$1 = Object.keys(defaultConfig$1).map((key) => [key, Symbol(key)]);
const tokenMap$1 = new Map(tokens$1);
function useGlobalConfig$1(compName, config) {
  const token = tokenMap$1.get(compName);
  const currConfig = inject(token, defaultConfig$1[compName]);
  if (!config) {
    return currConfig;
  }
  const cloneConfig = reactive(merge$1(cloneDeep(currConfig), config));
  provide(token, cloneConfig);
  return [cloneConfig, (config2) => merge$1(cloneConfig, config2)];
}

const iconProps = {
  name: IxPropTypes.string,
  iconfont: IxPropTypes.bool.def(false),
  rotate: IxPropTypes.oneOfType([Boolean, Number, String]),
  color: IxPropTypes.string,
  size: IxPropTypes.oneOfType([String, Number])
};
var __defProp$u = Object.defineProperty;
var __getOwnPropSymbols$A = Object.getOwnPropertySymbols;
var __hasOwnProp$A = Object.prototype.hasOwnProperty;
var __propIsEnum$A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$u = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$A.call(b, prop))
      __defNormalProp$u(a, prop, b[prop]);
  if (__getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(b)) {
      if (__propIsEnum$A.call(b, prop))
        __defNormalProp$u(a, prop, b[prop]);
    }
  return a;
};
var __async$1$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const iconDefinitions = /* @__PURE__ */ new Map();
const iconCache = /* @__PURE__ */ new Map();
function clearSVGElement(el) {
  var _a;
  const children = el.childNodes;
  const length = children.length;
  for (let i = length - 1; i >= 0; i--) {
    const child = children[i];
    if (((_a = child.tagName) == null ? void 0 : _a.toLowerCase()) === "svg") {
      child.remove();
    }
  }
}
function loadSVGElement(iconName, loadIconDynamically) {
  return __async$1$2(this, null, function* () {
    const cached = iconCache.get(iconName);
    if (cached) {
      const svg2 = yield cached;
      if (svg2) {
        return svg2.cloneNode(true);
      } else {
        iconCache.delete(iconName);
        return null;
      }
    }
    const svg = createSVGElement(iconName, loadIconDynamically);
    iconCache.set(iconName, svg);
    return svg;
  });
}
function loadSvgElementFormScript(iconName) {
  return __async$1$2(this, null, function* () {
    let svg = null;
    const cachedName = `IDUX_CACHED_ICON_FONT_` + iconName;
    const cached = iconCache.get(cachedName);
    if (cached) {
      svg = yield cached;
    }
    if (!svg) {
      svg = covertSVGElement(`<svg><use xlink:href="#${iconName}"></svg>`);
      setSVGAttribute(svg, iconName);
      iconCache.set(cachedName, svg);
    }
    return svg.cloneNode(true);
  });
}
function createSVGElement(iconName, loadIconDynamically) {
  return __async$1$2(this, null, function* () {
    let svg = null;
    const icon = yield loadIconDefinition(iconName, loadIconDynamically);
    if (icon) {
      svg = covertSVGElement(icon.svg);
      if (svg) {
        setSVGAttribute(svg, iconName);
        iconCache.set(iconName, svg);
      } else {
        process.env.NODE_ENV !== "production" && Logger.warn("components/icon", `The icon [${iconName}] create failed.`);
      }
    }
    return svg;
  });
}
function loadIconDefinition(iconName, loadIconDynamically) {
  return __async$1$2(this, null, function* () {
    let icon = iconDefinitions.get(iconName);
    if (!icon) {
      if (loadIconDynamically) {
        const svg = yield loadIconDynamically(iconName);
        if (validSVGString(svg)) {
          icon = { name: iconName, svg };
          iconDefinitions.set(iconName, icon);
        } else {
          process.env.NODE_ENV !== "production" && Logger.warn("components/icon", `The dynamically loaded icon [${iconName}] is invalid.`);
          return;
        }
      } else {
        process.env.NODE_ENV !== "production" && Logger.warn("components/icon", `The icon [${iconName}] load failed.`);
      }
    }
    return icon;
  });
}
function validSVGString(svg) {
  return !!svg && svg.includes("<svg");
}
function covertSVGElement(svg) {
  const div = document.createElement("div");
  div.innerHTML = svg;
  return div.querySelector("svg");
}
const defaultSVGAttributes = {
  viewBox: "0 0 1024 1024",
  focusable: "false",
  "aria-hidden": "true"
};
function setSVGAttribute(svg, iconName) {
  Object.entries(defaultSVGAttributes).forEach(([key, value]) => {
    if (!svg.hasAttribute(key)) {
      svg.setAttribute(key, value);
    }
  });
  svg.setAttribute("data-icon", iconName);
}
function covertSVGNode(child) {
  const node = getFirstValidNode(child);
  if (!node || node.type !== "svg") {
    Logger.warn("components/icon", "The children must is svg element");
    return;
  }
  return cloneVNode(node, __spreadValues$u(__spreadValues$u({}, defaultSVGAttributes), node.props));
}
var __async$a = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Icon = defineComponent({
  name: "IxIcon",
  props: iconProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-icon`);
    const config = useGlobalConfig$1("icon");
    const root = ref();
    onMounted(() => appendChild(props, config, root.value));
    watch([() => props.name, () => props.iconfont], () => {
      const rootElement = root.value;
      if (!rootElement) {
        return;
      }
      clearSVGElement(rootElement);
      appendChild(props, config, rootElement);
    });
    const classes = computed(() => {
      const {
        name,
        rotate
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${name}`]: !!name,
        [`${prefixCls}-spinning`]: rotate === true
      });
    });
    const style = computed(() => {
      const {
        rotate,
        color,
        size
      } = props;
      return {
        color,
        fontSize: convertCssPixel(size),
        transform: isNumeric(rotate) ? `rotate(${rotate}deg)` : void 0
      };
    });
    return () => {
      var _a;
      const {
        name
      } = props;
      if (name) {
        return createVNode("i", {
          "ref": root,
          "class": classes.value,
          "style": style.value,
          "role": "img",
          "aria-label": name
        }, null);
      } else {
        return createVNode("i", {
          "ref": root,
          "class": classes.value,
          "style": style.value,
          "role": "img"
        }, [covertSVGNode((_a = slots.default) == null ? void 0 : _a.call(slots))]);
      }
    };
  }
});
function appendChild(props, config, rootElement) {
  return __async$a(this, null, function* () {
    const {
      name,
      iconfont
    } = props;
    if (name) {
      const svgElement = iconfont ? yield loadSvgElementFormScript(name) : yield loadSVGElement(name, config.loadIconDynamically);
      if (svgElement) {
        rootElement.appendChild(svgElement);
      }
    }
  });
}
const addIconDefinitions = (icons) => {
  icons.forEach((icon) => iconDefinitions.set(icon.name, icon));
};
const Bulb = {
  name: "bulb",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a320 320 0 0 1 192.064 576L704 691.2a12.8 12.8 0 0 1-12.8 12.8H332.8a12.8 12.8 0 0 1-12.8-12.8V640A320 320 0 0 1 512 64zm0 64a256 256 0 0 0-165.248 451.52l11.648 9.28L384 608l-.064 31.936h256.128v-32l25.6-19.2A256 256 0 0 0 512 128zM396.8 896h230.4q12.8 0 12.8 12.8v38.4q0 12.8-12.8 12.8H396.8q-12.8 0-12.8-12.8v-38.4q0-12.8 12.8-12.8z"/><path d="M691.2 640c7.04 0 12.8 5.76 12.8 12.8v166.4a12.8 12.8 0 0 1-12.8 12.8H332.8a12.8 12.8 0 0 1-12.8-12.8V652.8c0-7.04 5.76-12.8 12.8-12.8h358.4zM640 704H384v64h256v-64zM458.752 211.648l13.184 37.568a11.392 11.392 0 0 1-6.208 14.208 160.64 160.64 0 0 0-85.12 86.272 11.776 11.776 0 0 1-14.72 7.04l-38.976-12.8A11.264 11.264 0 0 1 320 329.024 224.64 224.64 0 0 1 441.6 204.16l.576-.192a12.8 12.8 0 0 1 16.64 7.68z"/></svg>'
};
const CaretDownFilled = {
  name: "caret-down-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"/></svg>'
};
const CaretUpFilled = {
  name: "caret-up-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M858.9 689 530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z"/></svg>'
};
const CheckCircleFilled = {
  name: "check-circle-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zm258.133 287.68a12.8 12.8 0 0 0-18.133 0L453.824 649.835l-1.77 1.493a12.8 12.8 0 0 1-16.32-1.493l-162.987-163.03a12.8 12.8 0 0 0-18.134 0l-27.136 27.158a12.8 12.8 0 0 0 0 18.112l208.299 208.277a12.8 12.8 0 0 0 18.09 0l343.425-343.424a12.8 12.8 0 0 0 0-18.09z"/></svg>'
};
const CheckCircle = {
  name: "check-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768zM272.704 486.784l163.008 163.072a12.8 12.8 0 0 0 18.112 0l298.24-298.176a12.8 12.8 0 0 1 18.048 0l27.136 27.136a12.8 12.8 0 0 1 0 18.112L453.824 740.352a12.8 12.8 0 0 1-18.048 0l-208.32-208.256a12.8 12.8 0 0 1 0-18.112l27.136-27.2a12.8 12.8 0 0 1 18.112 0z"/></svg>'
};
const Check = {
  name: "check",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M167.29 445.278 437.84 715.83a10.779 10.779 0 0 0 15.2 0l403.886-403.78a10.779 10.779 0 0 1 15.253 0l22.85 22.852a10.779 10.779 0 0 1 0 15.252L453.094 792.091a10.779 10.779 0 0 1-15.252 0L129.13 483.38a10.779 10.779 0 0 1 0-15.251l22.906-22.852a10.779 10.779 0 0 1 15.252 0z"/></svg>'
};
const ClockCircle = {
  name: "clock-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768z"/><path d="M512 268.8v291.456c0 7.04 5.76 12.8 12.8 12.8h166.4c7.04 0 12.8 5.76 12.8 12.8v38.4a12.8 12.8 0 0 1-12.8 12.8H460.8a12.8 12.8 0 0 1-12.8-12.8V268.8c0-7.04 5.76-12.8 12.8-12.8h38.4c7.04 0 12.8 5.76 12.8 12.8z"/></svg>'
};
const CloseCircleFilled = {
  name: "close-circle-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zm168.021 252.096a12.8 12.8 0 0 0-18.09 0L512.384 465.643 365.12 318.379a12.8 12.8 0 0 0-18.112 0l-27.136 27.157a12.8 12.8 0 0 0 0 18.09l147.264 147.265-149.419 149.418a12.8 12.8 0 0 0 0 18.091l27.158 27.157a12.8 12.8 0 0 0 18.09 0L512.384 556.14l149.419 149.418a12.8 12.8 0 0 0 18.09 0l27.158-27.136a12.8 12.8 0 0 0 0-18.112L557.632 510.891l149.547-149.547a12.8 12.8 0 0 0 0-18.09z"/></svg>'
};
const CloseCircle = {
  name: "close-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768z"/><path d="M707.2 343.232a12.8 12.8 0 0 1 0 18.112L557.632 510.848l149.44 149.44a12.8 12.8 0 0 1 0 18.112l-27.2 27.136a12.8 12.8 0 0 1-18.048 0L512.384 556.16 362.944 705.6a12.8 12.8 0 0 1-18.048 0l-27.2-27.136a12.8 12.8 0 0 1 0-18.112L467.2 510.848l-147.264-147.2a12.8 12.8 0 0 1 0-18.112l27.136-27.136a12.8 12.8 0 0 1 18.112 0l147.264 147.2 149.568-149.504a12.8 12.8 0 0 1 18.048 0l27.2 27.136z"/></svg>'
};
const Close = {
  name: "close",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M191.68 146.432 877.568 832.32a12.8 12.8 0 0 1 0 18.112l-27.136 27.136a12.8 12.8 0 0 1-18.112 0L146.432 191.68a12.8 12.8 0 0 1 0-18.112l27.136-27.136a12.8 12.8 0 0 1 18.112 0z"/><path d="m850.432 146.432 27.136 27.136a12.8 12.8 0 0 1 0 18.112L191.68 877.568a12.8 12.8 0 0 1-18.112 0l-27.136-27.136a12.8 12.8 0 0 1 0-18.112L832.32 146.432a12.8 12.8 0 0 1 18.112 0z"/></svg>'
};
const DoubleLeft = {
  name: "double-left",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m167.104 521.024 388.48 388.544a12.8 12.8 0 0 0 18.176 0l27.136-27.136a12.8 12.8 0 0 0 0-18.112L257.6 521.024a12.8 12.8 0 0 1 0-18.048L600.96 159.68a12.8 12.8 0 0 0 0-18.112l-27.136-27.136a12.8 12.8 0 0 0-18.112 0l-388.48 388.48a12.8 12.8 0 0 0 0 18.112zm192 0 388.48 388.544a12.8 12.8 0 0 0 18.176 0l27.136-27.136a12.8 12.8 0 0 0 0-18.112L449.6 521.024a12.8 12.8 0 0 1 0-18.048L792.896 159.68a12.8 12.8 0 0 0 0-18.112l-27.136-27.136a12.8 12.8 0 0 0-18.112 0l-388.48 388.48a12.8 12.8 0 0 0 0 18.112z"/></svg>'
};
const DoubleRight = {
  name: "double-right",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m856.896 521.024-388.48 388.544a12.8 12.8 0 0 1-18.176 0l-27.136-27.136a12.8 12.8 0 0 1 0-18.112L766.4 521.024a12.8 12.8 0 0 0 0-18.048L423.04 159.68a12.8 12.8 0 0 1 0-18.112l27.136-27.136a12.8 12.8 0 0 1 18.112 0l388.48 388.48a12.8 12.8 0 0 1 0 18.112zm-192 0-388.48 388.544a12.8 12.8 0 0 1-18.176 0l-27.136-27.136a12.8 12.8 0 0 1 0-18.112L574.4 521.024a12.8 12.8 0 0 0 0-18.048L231.04 159.68a12.8 12.8 0 0 1 0-18.112l27.136-27.136a12.8 12.8 0 0 1 18.112 0l388.48 388.48a12.8 12.8 0 0 1 0 18.112z"/></svg>'
};
const Down = {
  name: "down",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m502.976 728.896-388.544-388.48a12.8 12.8 0 0 1 0-18.176l27.136-27.136a12.8 12.8 0 0 1 18.112 0L502.976 638.4a12.8 12.8 0 0 0 18.048 0L864.32 295.104a12.8 12.8 0 0 1 18.112 0l27.136 27.136a12.8 12.8 0 0 1 0 18.112l-388.48 388.48a12.8 12.8 0 0 1-18.112 0z"/></svg>'
};
const Ellipsis = {
  name: "ellipsis",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><defs><style/></defs><path d="M768 448a64 64 0 1 0 0 128 64 64 0 1 0 0-128Zm-256 0a64 64 0 1 0 0 128 64 64 0 1 0 0-128Zm-256 0a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"/></svg>'
};
const Empty$2 = {
  name: "empty",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><defs><style/></defs><path d="M961.991 628.895h.01V849.5c0 31.066-25.184 56.25-56.25 56.25h-787.5C87.185 905.75 62 880.566 62 849.5V628.895h.01a36.879 36.879 0 0 1 5.25-18.1l118.856-198.028c10.175-16.954 28.515-27.33 48.307-27.33h555.149c19.792 0 38.131 10.376 48.307 27.33l118.856 198.027a36.718 36.718 0 0 1 5.255 18.1zm-312.198-4.38c.362 0 .724-.005 1.084-.015h252.416a7.031 7.031 0 0 0 6.028-10.65L801.65 434.458a14.084 14.084 0 0 0-12.077-6.833h-555.15a14.083 14.083 0 0 0-12.076 6.833L114.675 613.85a7.031 7.031 0 0 0 6.029 10.65h253.505c13.108 0 24.435 9.047 27.39 21.739C411.727 697.968 457.307 737 512.002 737c37.814 0 71.271-18.657 91.668-47.268a111.935 111.935 0 0 0 18.56-42.63c2.632-13.134 14.168-22.588 27.564-22.588zM512.001 118.25c11.65 0 21.094 9.444 21.094 21.094v89.648c0 11.65-9.444 21.094-21.094 21.094s-21.094-9.444-21.094-21.094v-89.648c0-11.65 9.444-21.094 21.094-21.094zm266.341 65.892c8.237 8.238 8.237 21.593 0 29.831l-63.391 63.392c-8.238 8.237-21.594 8.237-29.831 0-8.238-8.238-8.238-21.594 0-29.831l63.391-63.392c8.237-8.238 21.593-8.238 29.831 0zm-532.682 0c8.238-8.238 21.594-8.238 29.832 0l63.39 63.392c8.238 8.237 8.238 21.593 0 29.83-8.237 8.238-21.593 8.238-29.831 0l-63.391-63.39c-8.237-8.239-8.237-21.594 0-29.832z"/></svg>'
};
const ExclamationCircleFilled = {
  name: "exclamation-circle-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zm.853 656.939a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM531.2 256h-38.4a12.8 12.8 0 0 0-12.8 12.8v358.4a12.8 12.8 0 0 0 12.8 12.8h38.4a12.8 12.8 0 0 0 12.8-12.8V268.8a12.8 12.8 0 0 0-12.8-12.8z"/></svg>'
};
const ExclamationCircle = {
  name: "exclamation-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768z"/><path d="M492.8 384h38.4q12.8 0 12.8 12.8v358.4q0 12.8-12.8 12.8h-38.4q-12.8 0-12.8-12.8V396.8q0-12.8 12.8-12.8Zm20.032-175.04q48 0 48 48t-48 48q-48 0-48-48t48-48Z"/></svg>'
};
const FilterFilled = {
  name: "filter-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M46.976 118.997a14.208 14.208 0 0 1-4.31-10.197V14.336C42.667 6.443 49.28 0 57.345 0h909.312c8.107 0 14.677 6.443 14.677 14.336V108.8c0 3.84-1.536 7.51-4.309 10.197l-347.69 340.054v450.133a14.293 14.293 0 0 1-8.107 12.885l-205.312 100.395a14.933 14.933 0 0 1-14.336-.64 14.293 14.293 0 0 1-6.912-12.288V459.008L46.976 118.955z"/></svg>'
};
const InfoCircleFilled = {
  name: "info-circle-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 0 1 0-96 48.01 48.01 0 0 1 0 96z"/></svg>'
};
const InfoCircle = {
  name: "info-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768zm-19.2 128h38.4q12.8 0 12.8 12.8v358.4q0 12.8-12.8 12.8h-38.4q-12.8 0-12.8-12.8V268.8q0-12.8 12.8-12.8Zm20.032 464.96q48 0 48 48t-48 48q-48 0-48-48t48-48Z"/></svg>'
};
const Left = {
  name: "left",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m295.104 502.976 388.48-388.544a12.8 12.8 0 0 1 18.176 0l27.136 27.136a12.8 12.8 0 0 1 0 18.112L385.6 502.976a12.8 12.8 0 0 0 0 18.048L728.896 864.32a12.8 12.8 0 0 1 0 18.112l-27.136 27.136a12.8 12.8 0 0 1-18.112 0l-388.48-388.48a12.8 12.8 0 0 1 0-18.112z"/></svg>'
};
const Loading$1 = {
  name: "loading",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m527.424 64.32 3.712.064a448 448 0 0 1 430.912 432.32v2.368a12.8 12.8 0 0 1-12.8 13.056h-38.336a12.8 12.8 0 0 1-12.8-13.632A384 384 0 0 0 528.64 128.384h-1.792a12.8 12.8 0 0 1-12.608-12.8V77.12a12.8 12.8 0 0 1 13.12-12.8z"/></svg>'
};
const MenuFold = {
  name: "menu-fold",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M896 140.8v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zM372.992 495.36 152.64 632.32a12.8 12.8 0 0 1-19.52-10.88V347.52a12.8 12.8 0 0 1 19.52-10.88L372.992 473.6a12.8 12.8 0 0 1 0 21.76z"/></svg>'
};
const MenuUnfold = {
  name: "menu-unfold",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M896 140.8v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H524.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h358.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zM142.912 473.6l220.352-136.96a12.8 12.8 0 0 1 19.52 10.88v273.92a12.8 12.8 0 0 1-19.52 10.88L142.912 495.36a12.8 12.8 0 0 1 0-21.76z"/></svg>'
};
const Menu$1 = {
  name: "menu",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M896 140.8v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8zm0 128v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8z"/></svg>'
};
const Minus = {
  name: "minus",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M896 492.8v38.4a12.8 12.8 0 0 1-12.8 12.8H140.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h742.4c7.04 0 12.8 5.76 12.8 12.8z"/></svg>'
};
const Plus = {
  name: "plus",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M499.2 64c7.04 0 12.8 5.76 12.8 12.8l-.064 372.352 370.048.064c7.04 0 12.8 5.76 12.8 12.8v38.4a12.8 12.8 0 0 1-12.8 12.8l-370.048-.064L512 883.2a12.8 12.8 0 0 1-12.8 12.8h-38.4a12.8 12.8 0 0 1-12.8-12.8l-.064-370.048-372.352.064a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8l372.352-.064L448 76.8c0-7.04 5.76-12.8 12.8-12.8h38.4z"/></svg>'
};
const QuestionCircleFilled = {
  name: "question-circle-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zm.853 656.939a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM512 192a192.021 192.021 0 0 0-191.019 172.48 144.576 144.576 0 0 0-.469 6.72 12.8 12.8 0 0 0 12.8 12.8h38.57a12.8 12.8 0 0 0 12.758-11.819c.213-2.773.448-5.077.725-6.933A128.021 128.021 0 0 1 640 384a128 128 0 0 1-128 128h-32v115.2a12.8 12.8 0 0 0 12.8 12.8h38.4a12.8 12.8 0 0 0 12.8-12.8v-53.867A192 192 0 0 0 512 192z"/></svg>'
};
const QuestionCircle = {
  name: "question-circle",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 64a384 384 0 1 0 0 768 384 384 0 0 0 0-768zm0 64a192 192 0 1 1 0 384v-64a128 128 0 1 0-128-128h-64a192 192 0 0 1 192-192zm-32 320h64v115.2a12.8 12.8 0 0 1-12.8 12.8h-38.4a12.8 12.8 0 0 1-12.8-12.8V512zm32.832 208.96q48 0 48 48t-48 48q-48 0-48-48t48-48Z"/></svg>'
};
const Right = {
  name: "right",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="m728.896 521.024-388.48 388.544a12.8 12.8 0 0 1-18.176 0l-27.136-27.136a12.8 12.8 0 0 1 0-18.112L638.4 521.024a12.8 12.8 0 0 0 0-18.048L295.04 159.68a12.8 12.8 0 0 1 0-18.112l27.136-27.136a12.8 12.8 0 0 1 18.112 0l388.48 388.48a12.8 12.8 0 0 1 0 18.112z"/></svg>'
};
const RotateLeft = {
  name: "rotate-left",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M768 396.8v550.4a12.8 12.8 0 0 1-12.8 12.8H76.8A12.8 12.8 0 0 1 64 947.2V396.8c0-7.04 5.76-12.8 12.8-12.8h678.4c7.04 0 12.8 5.76 12.8 12.8zM704 448H128v448h576V448zM462.208 319.616a12.8 12.8 0 0 1-9.088-21.888L665.28 85.824a12.8 12.8 0 0 1 21.888 9.024v160.768A288 288 0 0 1 960 529.664v.512a12.8 12.8 0 0 1-12.48 13.056h-39.68a11.904 11.904 0 0 1-11.072-7.68l-.768-3.584a224 224 0 0 0-211.392-212.416z"/></svg>'
};
const RotateRight = {
  name: "rotate-right",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M256 396.8v550.4c0 7.04 5.76 12.8 12.8 12.8h678.4a12.8 12.8 0 0 0 12.8-12.8V396.8a12.8 12.8 0 0 0-12.8-12.8H268.8a12.8 12.8 0 0 0-12.8 12.8zm64 51.2h576v448H320V448zm241.792-128.384a12.8 12.8 0 0 0 8.96-21.888L358.72 85.824a12.8 12.8 0 0 0-21.888 9.024v160.768A288 288 0 0 0 64 529.664v.512a12.8 12.8 0 0 0 12.48 13.056h39.68c4.992 0 9.344-3.2 11.072-7.68l.768-3.584a224 224 0 0 1 211.392-212.416z"/></svg>'
};
const Search = {
  name: "search",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M448 96a384 384 0 0 1 307.392 614.208l154.24 154.112a12.8 12.8 0 0 1 0 18.112l-27.2 27.136a12.8 12.8 0 0 1-18.112 0L712.832 758.08A384 384 0 1 1 448 96zm0 64a320 320 0 1 0 0 640 320 320 0 0 0 0-640zm0 128v64a160 160 0 0 0-159.68 149.504L288 512h-64a224 224 0 0 1 211.712-223.68L448 288z"/></svg>'
};
const StarFilled = {
  name: "star-filled",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M652.181 340.395 523.243 78.955a12.8 12.8 0 0 0-22.955 0L371.2 340.395a12.8 12.8 0 0 1-9.621 6.997L73.024 389.376A12.8 12.8 0 0 0 65.92 411.2l208.81 203.499a12.8 12.8 0 0 1 3.691 11.306L229.12 913.493a12.8 12.8 0 0 0 18.56 13.504l258.09-135.744a12.8 12.8 0 0 1 11.905 0l258.133 135.744a12.8 12.8 0 0 0 18.56-13.504l-49.323-287.381a12.8 12.8 0 0 1 3.691-11.328l208.853-203.563a12.8 12.8 0 0 0-7.104-21.824l-288.682-41.984a12.8 12.8 0 0 1-9.643-6.997z"/></svg>'
};
const TreeExpand = {
  name: "tree-expand",
  svg: '<svg viewBox="0 0 16 16" focusable="false"><path fill-rule="evenodd" d="M2.8 3c.11 0 .2.09.2.2V4h.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H3v3h2.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H5v3h1.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H4.2a.2.2 0 0 1-.2-.2V9H2.2a.2.2 0 0 1-.2-.2V3.2c0-.11.09-.2.2-.2h.6Zm11 9c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H8.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h5.6Zm-1-4c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h5.6Zm-1-4c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H5.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h6.6Z"/></svg>'
};
const TreeUnexpand = {
  name: "tree-unexpand",
  svg: '<svg viewBox="0 0 16 16" focusable="false"><path fill-rule="evenodd" d="M2.8 3c.11 0 .2.09.2.2V4h1.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H3v3h1.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H3v3h1.8c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H2.2a.2.2 0 0 1-.2-.2V3.2c0-.11.09-.2.2-.2h.6Zm11 9c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H6.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h7.6Zm0-4c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H6.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h7.6Zm0-4c.11 0 .2.09.2.2v.6a.2.2 0 0 1-.2.2H6.2a.2.2 0 0 1-.2-.2v-.6c0-.11.09-.2.2-.2h7.6Z"/></svg>'
};
const User = {
  name: "user",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M512 64a256 256 0 1 1 0 512 256 256 0 0 1 0-512zm0 64a192 192 0 1 0 0 384 192 192 0 0 0 0-384z"/><path d="M512 512c-224.768 0-407.872 146.24-415.744 369.088l-.192 20.48.512 13.376.448 7.872a44.8 44.8 0 0 0 44.672 42.112l740.48.64a44.8 44.8 0 0 0 44.8-42.048l.768-15.36L928 896c0-229.76-186.24-384-416-384zm0 64c194.432 0 352 125.568 352 320l-.128 5.568L160 900.864V896c0-194.432 157.568-320 352-320z"/></svg>'
};
const VerticalAlignTop = {
  name: "vertical-align-top",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M76.8 128h870.4q12.8 0 12.8 12.8v38.4q0 12.8-12.8 12.8H76.8Q64 192 64 179.2v-38.4Q64 128 76.8 128Zm416 256h38.4q12.8 0 12.8 12.8v550.4q0 12.8-12.8 12.8h-38.4q-12.8 0-12.8-12.8V396.8q0-12.8 12.8-12.8Z"/><path d="m522.944 273.472 136.96 220.352a12.8 12.8 0 0 1-10.88 19.584h-273.92a12.8 12.8 0 0 1-10.88-19.584l136.96-220.352a12.8 12.8 0 0 1 21.76 0z"/></svg>'
};
const ZoomIn = {
  name: "zoom-in",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M448 96a384 384 0 0 1 307.392 614.208l154.24 154.112a12.8 12.8 0 0 1 0 18.112l-27.2 27.136a12.8 12.8 0 0 1-18.112 0L712.832 758.08A384 384 0 1 1 448 96zm0 64a320 320 0 1 0 0 640 320 320 0 0 0 0-640z"/><path d="M428.8 255.68h38.4c7.04 0 12.8 5.76 12.8 12.8v422.4a12.8 12.8 0 0 1-12.8 12.8h-38.4a12.8 12.8 0 0 1-12.8-12.8v-422.4c0-7.04 5.76-12.8 12.8-12.8z"/><path d="M672 460.48v38.4a12.8 12.8 0 0 1-12.8 12.8H236.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h422.4c7.04 0 12.8 5.76 12.8 12.8z"/></svg>'
};
const ZoomOut = {
  name: "zoom-out",
  svg: '<svg viewBox="64 64 896 896" focusable="false"><path d="M448 96a384 384 0 0 1 307.392 614.208l154.24 154.112a12.8 12.8 0 0 1 0 18.112l-27.2 27.136a12.8 12.8 0 0 1-18.112 0L712.832 758.08A384 384 0 1 1 448 96zm0 64a320 320 0 1 0 0 640 320 320 0 0 0 0-640z"/><path d="M672 460.48v38.4a12.8 12.8 0 0 1-12.8 12.8H236.8a12.8 12.8 0 0 1-12.8-12.8v-38.4c0-7.04 5.76-12.8 12.8-12.8h422.4c7.04 0 12.8 5.76 12.8 12.8z"/></svg>'
};
const IDUX_ICON_DEPENDENCIES = [
  Bulb,
  CaretDownFilled,
  CaretUpFilled,
  Check,
  CheckCircle,
  CheckCircleFilled,
  ClockCircle,
  Close,
  CloseCircle,
  CloseCircleFilled,
  DoubleLeft,
  DoubleRight,
  Down,
  Ellipsis,
  Empty$2,
  ExclamationCircle,
  ExclamationCircleFilled,
  FilterFilled,
  InfoCircle,
  InfoCircleFilled,
  Left,
  Loading$1,
  Menu$1,
  MenuFold,
  MenuUnfold,
  Minus,
  Plus,
  QuestionCircle,
  QuestionCircleFilled,
  Right,
  RotateLeft,
  RotateRight,
  Search,
  StarFilled,
  User,
  TreeExpand,
  TreeUnexpand,
  VerticalAlignTop,
  ZoomIn,
  ZoomOut
];
const IxIcon = Icon;

const defaultName$1 = "\u6B64\u9879";
const zhCNMessages = {
  default: (_, control) => {
    const name = control.name;
    return `${name || ""}\u9A8C\u8BC1\u5931\u8D25`;
  },
  required: (_, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u5FC5\u586B`;
  },
  requiredTrue: (_, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u5FC5\u987B\u4E3A 'true'`;
  },
  email: (_, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u4E0D\u662F\u4E00\u4E2A\u6709\u6548\u7684\u90AE\u7BB1\u5730\u5740`;
  },
  min: (err, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u4E0D\u80FD\u5C0F\u4E8E ${err.min}`;
  },
  max: (err, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u4E0D\u80FD\u5927\u4E8E ${err.max}`;
  },
  minLength: (err, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u7684\u957F\u5EA6\u4E0D\u80FD\u5C0F\u4E8E ${err.minLength}, \u5F53\u524D\u957F\u5EA6\u4E3A ${err.actual}`;
  },
  maxLength: (err, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u7684\u957F\u5EA6\u4E0D\u80FD\u5C0F\u4E8E ${err.maxLength}, \u5F53\u524D\u957F\u5EA6\u4E3A ${err.actual}`;
  },
  pattern: (err, control) => {
    const name = control.name || defaultName$1;
    return `${name}\u4E0D\u80FD\u5339\u914D '${err.pattern}'`;
  }
};
var __defProp$1$c = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$f = Object.getOwnPropertySymbols;
var __hasOwnProp$1$f = Object.prototype.hasOwnProperty;
var __propIsEnum$1$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$c = (obj, key, value) => key in obj ? __defProp$1$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$f.call(b, prop))
      __defNormalProp$1$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$f)
    for (var prop of __getOwnPropSymbols$1$f(b)) {
      if (__propIsEnum$1$f.call(b, prop))
        __defNormalProp$1$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$k = (a, b) => __defProps$k(a, __getOwnPropDescs$k(b));
const emailRegexp = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const _Validators = class {
  static setMessages(messages) {
    _Validators.messages = __spreadValues$1$c(__spreadValues$1$c({}, _Validators.messages), messages);
  }
  static getError(key, control, errorContext = {}) {
    let message = void 0;
    const validMessage = _Validators.messages[key] || _Validators.messages.default || void 0;
    if (isFunction(validMessage)) {
      message = validMessage(errorContext, control);
    } else {
      message = validMessage;
    }
    return __spreadProps$k(__spreadValues$1$c({}, errorContext), { message });
  }
  static required(value, control) {
    if (isEmpty(value)) {
      return { required: _Validators.getError("required", control) };
    }
    return void 0;
  }
  static requiredTrue(value, control) {
    if (value === true) {
      return void 0;
    }
    return { requiredTrue: _Validators.getError("requiredTrue", control, { actual: value }) };
  }
  static email(value, control) {
    if (isEmpty(value) || emailRegexp.test(value)) {
      return void 0;
    }
    return { email: _Validators.getError("email", control, { actual: value }) };
  }
  static min(min) {
    return (value, control) => {
      if (isEmpty(value) || !isNumeric(value) || Number(value) >= min) {
        return void 0;
      }
      return { min: _Validators.getError("min", control, { min, actual: value }) };
    };
  }
  static max(max) {
    return (value, control) => {
      if (isEmpty(value) || !isNumeric(value) || Number(value) <= max) {
        return void 0;
      }
      return { max: _Validators.getError("max", control, { max, actual: value }) };
    };
  }
  static minLength(minLength) {
    return (value, control) => {
      if (isEmpty(value) || !hasLength(value) || value.length >= minLength) {
        return void 0;
      }
      return { minLength: _Validators.getError("minLength", control, { minLength, actual: value.length }) };
    };
  }
  static maxLength(maxLength) {
    return (value, control) => {
      if (isEmpty(value) || !hasLength(value) || value.length <= maxLength) {
        return void 0;
      }
      return { maxLength: _Validators.getError("maxLength", control, { maxLength, actual: value.length }) };
    };
  }
  static pattern(pattern) {
    if (!pattern) {
      return _Validators.nullValidator;
    }
    let regex;
    let regexStr;
    if (typeof pattern === "string") {
      regexStr = "";
      if (pattern.charAt(0) !== "^") {
        regexStr += "^";
      }
      regexStr += pattern;
      if (pattern.charAt(pattern.length - 1) !== "$") {
        regexStr += "$";
      }
      regex = new RegExp(regexStr);
    } else {
      regexStr = pattern.toString();
      regex = pattern;
    }
    return (value, control) => {
      if (isEmpty(value) || regex.test(value)) {
        return void 0;
      }
      return { pattern: _Validators.getError("pattern", control, { pattern: regexStr, actual: value }) };
    };
  }
  static nullValidator(_, _control) {
    return void 0;
  }
  static compose(validators) {
    if (!validators) {
      return void 0;
    }
    const presentValidators = validators.filter(isFunction);
    if (presentValidators.length == 0) {
      return void 0;
    }
    return (value, control) => mergeMessages(executeValidators(value, control, presentValidators));
  }
  static composeAsync(validators) {
    if (!validators) {
      return void 0;
    }
    const presentValidators = validators.filter(isFunction);
    if (presentValidators.length == 0) {
      return void 0;
    }
    return (value, control) => {
      const ValidateErrors = executeValidators(value, control, presentValidators);
      return Promise.all(ValidateErrors).then(mergeMessages);
    };
  }
};
let Validators = _Validators;
Validators.messages = zhCNMessages;
function isEmpty(val) {
  return isNil(val) || val.length === 0 && (isString(val) || isArray$1(val));
}
function hasLength(val) {
  return !isNil(val) && isNumber(val.length);
}
function executeValidators(value, control, validators) {
  return validators.map((validator) => validator(value, control));
}
function mergeMessages(validateErrors) {
  let res = {};
  validateErrors.forEach((errors) => {
    res = isNil(errors) ? res : __spreadValues$1$c(__spreadValues$1$c({}, res), errors);
  });
  return Object.keys(res).length === 0 ? void 0 : res;
}
var __defProp$t = Object.defineProperty;
var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
var __hasOwnProp$z = Object.prototype.hasOwnProperty;
var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$t = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$z.call(b, prop))
      __defNormalProp$t(a, prop, b[prop]);
  if (__getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(b)) {
      if (__propIsEnum$z.call(b, prop))
        __defNormalProp$t(a, prop, b[prop]);
    }
  return a;
};
var __async$9 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isOptions(val) {
  return isPlainObject(val);
}
function toValidator(validator) {
  return isArray$1(validator) ? Validators.compose(validator) : validator;
}
function toAsyncValidator(asyncValidator) {
  return isArray$1(asyncValidator) ? Validators.composeAsync(asyncValidator) : asyncValidator;
}
let controlId = 0;
class AbstractControl {
  constructor(controls, validatorOrOptions, asyncValidator, initValue) {
    this.uid = controlId++;
    this._blurred = ref(false);
    this._dirty = ref(false);
    this._controls = shallowRef(controls);
    this._valueRef = shallowRef(initValue != null ? initValue : this._calculateInitValue());
    this._forEachControls((control) => control.setParent(this));
    this._convertOptions(validatorOrOptions, asyncValidator);
    this._init();
  }
  get parent() {
    return this._parent;
  }
  get root() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  get trigger() {
    var _a, _b, _c;
    return (_c = (_b = this._trigger) != null ? _b : (_a = this._parent) == null ? void 0 : _a.trigger) != null ? _c : "change";
  }
  get trim() {
    var _a, _b, _c;
    return (_c = (_b = this._trim) != null ? _b : (_a = this._parent) == null ? void 0 : _a.trim) != null ? _c : false;
  }
  reset() {
    if (this._controls.value) {
      this._forEachControls((control) => control.reset());
    } else {
      this._valueRef.value = this._calculateInitValue();
      this.markAsUnblurred();
      this.markAsPristine();
    }
  }
  validate() {
    return __async$9(this, null, function* () {
      if (this._controls.value) {
        const validates = [];
        this._forEachControls((control) => validates.push(control.validate()));
        if (validates.length > 0) {
          yield Promise.all(validates);
        }
      }
      return this._validate();
    });
  }
  disable() {
    this._disabled.value = true;
    this._errors.value = void 0;
    if (this._controls.value) {
      this._forEachControls((control) => control.disable());
    }
  }
  enable() {
    this._disabled.value = false;
    this._validate();
    if (this._controls.value) {
      this._forEachControls((control) => control.enable());
    }
  }
  markAsBlurred() {
    if (this._controls.value) {
      this._forEachControls((control) => control.markAsBlurred());
    } else {
      this._blurred.value = true;
    }
    if (this.trigger === "blur") {
      this._validate();
    }
  }
  markAsUnblurred() {
    if (this._controls.value) {
      this._forEachControls((control) => control.markAsUnblurred());
    } else {
      this._blurred.value = false;
    }
  }
  markAsDirty() {
    if (this._controls.value) {
      this._forEachControls((control) => control.markAsDirty());
    } else {
      this._dirty.value = true;
    }
  }
  markAsPristine() {
    if (this._controls.value) {
      this._forEachControls((control) => control.markAsPristine());
    } else {
      this._dirty.value = false;
    }
  }
  setValidator(newValidator) {
    this._validators = toValidator(newValidator);
  }
  setAsyncValidator(newAsyncValidator) {
    this._asyncValidators = toAsyncValidator(newAsyncValidator);
  }
  get(path) {
    if (isNil(path)) {
      return void 0;
    }
    if (!isArray$1(path)) {
      path = path.toString().split(".");
    }
    if (path.length === 0) {
      return void 0;
    }
    let controlToFind = this;
    path.forEach((name) => {
      if (controlToFind instanceof FormGroup) {
        const controls = controlToFind.controls.value;
        controlToFind = controls.hasOwnProperty(name) ? controls[name] : void 0;
      } else if (controlToFind instanceof FormArray) {
        controlToFind = controlToFind.at(name);
      } else {
        controlToFind = void 0;
      }
    });
    return controlToFind;
  }
  setErrors(errors) {
    this._errors.value = errors;
  }
  getError(errorCode, path) {
    var _a, _b;
    const control = path ? this.get(path) : this;
    return (_b = (_a = control == null ? void 0 : control._errors) == null ? void 0 : _a.value) == null ? void 0 : _b[errorCode];
  }
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  setParent(parent) {
    this._parent = parent;
  }
  watchValue(cb, options) {
    return watch(this.valueRef, cb, options);
  }
  watchStatus(cb, options) {
    return watch(this.status, cb, options);
  }
  _validate() {
    return __async$9(this, null, function* () {
      let newErrors = void 0;
      if (!this._disabled.value) {
        let value = void 0;
        if (this._validators) {
          value = this.getValue();
          newErrors = this._validators(value, this);
        }
        if (isNil(newErrors) && this._asyncValidators) {
          value = this._validators ? value : this.getValue();
          this._status.value = "validating";
          newErrors = yield this._asyncValidators(value, this);
        }
      }
      this.setErrors(newErrors);
      return newErrors;
    });
  }
  _convertOptions(validatorOrOptions, asyncValidator) {
    var _a, _b;
    let disabled = false;
    if (isOptions(validatorOrOptions)) {
      this.name = validatorOrOptions.name;
      this._trigger = (_a = validatorOrOptions.trigger) != null ? _a : this._trigger;
      this._trim = (_b = validatorOrOptions.trim) != null ? _b : this._trim;
      this._validators = toValidator(validatorOrOptions.validators);
      this._asyncValidators = toAsyncValidator(validatorOrOptions.asyncValidators);
      if (validatorOrOptions.disabled) {
        disabled = true;
        const controls = this._controls.value;
        if (controls) {
          for (const key in controls) {
            controls[key].disable();
          }
        }
      }
    } else {
      this._validators = toValidator(validatorOrOptions);
      this._asyncValidators = toAsyncValidator(asyncValidator);
    }
    this._disabled = ref(disabled);
  }
  _init() {
    this.controls = computed(() => this._controls.value);
    this.valueRef = computed(() => this._valueRef.value);
    this._initErrorsAndStatus();
    this.errors = computed(() => this._errors.value);
    this.status = computed(() => {
      const selfStatus = this._status.value;
      if (selfStatus === "valid") {
        return this._controlsStatus.value;
      }
      return selfStatus;
    });
    this.valid = computed(() => this.status.value === "valid");
    this.invalid = computed(() => this.status.value === "invalid");
    this.validating = computed(() => this.status.value === "validating");
    this.disabled = computed(() => this._disabled.value);
    this.blurred = computed(() => this._blurred.value);
    this.unblurred = computed(() => !this._blurred.value);
    this.dirty = computed(() => this._dirty.value);
    this.pristine = computed(() => !this._dirty.value);
  }
  _initErrorsAndStatus() {
    const disabled = this._disabled.value;
    let value;
    let errors;
    let status = "valid";
    let controlsStatus = "valid";
    if (!disabled) {
      if (this._validators) {
        value = this.getValue();
        errors = this._validators(value, this);
      }
      if (errors) {
        status = "invalid";
      }
      const controls = this._controls.value;
      if (controls) {
        for (const key in controls) {
          const controlStatus = controls[key].status.value;
          if (controlStatus === "invalid") {
            controlsStatus = "invalid";
            break;
          }
        }
      }
    }
    this._errors = shallowRef(errors);
    this._status = ref(status);
    this._controlsStatus = ref(controlsStatus);
    if (!disabled && status === "valid" && controlsStatus === "valid" && this._asyncValidators) {
      value = this._validators ? value : this.getValue();
      this._status.value = "validating";
      this._asyncValidators(value, this).then((asyncErrors) => {
        this._errors.value = asyncErrors;
        this._status.value = asyncErrors ? "invalid" : "valid";
      });
    }
  }
}
class FormGroup extends AbstractControl {
  constructor(controls, validatorOrOptions, asyncValidator) {
    super(controls, validatorOrOptions, asyncValidator);
    this._watchValid();
    this._watchValue();
    this._watchStatus();
    this._watchBlurred();
    this._watchDirty();
  }
  setValue(value, options = {}) {
    Object.keys(value).forEach((key) => {
      this._controls.value[key].setValue(value[key], options);
    });
  }
  getValue() {
    const value = {};
    this._forEachControls((control, key) => {
      value[key] = control.getValue();
    });
    return value;
  }
  _calculateInitValue() {
    return this.getValue();
  }
  _forEachControls(cb) {
    const controls = this._controls.value;
    Object.keys(controls).forEach((key) => cb(controls[key], key));
  }
  addControl(name, control) {
    const controls = __spreadValues$t({}, this._controls.value);
    if (hasOwnProperty(controls, name)) {
      return;
    }
    control.setParent(this);
    controls[name] = control;
    this._controls.value = controls;
  }
  removeControl(name) {
    const controls = __spreadValues$t({}, this._controls.value);
    delete controls[name];
    this._controls.value = controls;
  }
  setControl(name, control) {
    control.setParent(this);
    const controls = __spreadValues$t({}, this._controls.value);
    controls[name] = control;
    this._controls.value = controls;
  }
  _watchValid() {
    watch(this._valueRef, () => {
      if (this.trigger === "change") {
        this._validate();
      }
    });
  }
  _watchValue() {
    watchEffect(() => {
      this._valueRef.value = this.getValue();
    });
  }
  _watchStatus() {
    watchEffect(() => {
      this._status.value = this._errors.value ? "invalid" : "valid";
    });
    watchEffect(() => {
      let status = "valid";
      const controls = this._controls.value;
      for (const key in controls) {
        const controlStatus = controls[key].status.value;
        if (controlStatus === "invalid") {
          status = "invalid";
          break;
        } else if (controlStatus === "validating") {
          status = "validating";
        }
      }
      this._controlsStatus.value = status;
    });
  }
  _watchBlurred() {
    watchEffect(() => {
      let blurred = false;
      const controls = this._controls.value;
      for (const key in controls) {
        if (controls[key].blurred.value) {
          blurred = true;
          break;
        }
      }
      this._blurred.value = blurred;
    });
  }
  _watchDirty() {
    watchEffect(() => {
      let dirty = false;
      const controls = this._controls.value;
      for (const key in controls) {
        if (controls[key].dirty.value) {
          dirty = true;
          break;
        }
      }
      this._dirty.value = dirty;
    });
  }
}
class FormArray extends AbstractControl {
  constructor(controls, validatorOrOptions, asyncValidator) {
    super(controls, validatorOrOptions, asyncValidator);
    this.length = computed(() => this._controls.value.length);
    this._watchValid();
    this._watchValue();
    this._watchStatus();
    this._watchBlurred();
    this._watchDirty();
  }
  setValue(value, options = {}) {
    value.forEach((item, index) => {
      if (this.at(index)) {
        this.at(index).setValue(item, options);
      }
    });
  }
  getValue() {
    return this._controls.value.map((control) => control.getValue());
  }
  _calculateInitValue() {
    return this.getValue();
  }
  _forEachControls(cb) {
    this._controls.value.forEach(cb);
  }
  at(index) {
    return this._controls.value[index];
  }
  push(control) {
    control.setParent(this);
    this._controls.value = [...this._controls.value, control];
  }
  insert(index, control) {
    control.setParent(this);
    const controls = [...this._controls.value];
    controls.splice(index, 0, control);
    this._controls.value = controls;
  }
  removeAt(index) {
    const controls = [...this._controls.value];
    controls.splice(index, 1);
    this._controls.value = controls;
  }
  setControl(index, control) {
    control.setParent(this);
    const controls = [...this._controls.value];
    controls.splice(index, 1, control);
    this._controls.value = controls;
  }
  _watchValid() {
    watch(this._valueRef, () => {
      if (this.trigger === "change") {
        this._validate();
      }
    });
  }
  _watchValue() {
    watchEffect(() => {
      this._valueRef.value = this.getValue();
    });
  }
  _watchStatus() {
    watchEffect(() => {
      this._status.value = this._errors.value ? "invalid" : "valid";
    });
    watchEffect(() => {
      let status = "valid";
      const controls = this._controls.value;
      for (const control of controls) {
        const controlStatus = control.status.value;
        if (controlStatus === "invalid") {
          status = "invalid";
          break;
        } else if (controlStatus === "validating") {
          status = "validating";
        }
      }
      this._controlsStatus.value = status;
    });
  }
  _watchBlurred() {
    watchEffect(() => {
      let blurred = false;
      const controls = this._controls.value;
      for (const control of controls) {
        if (control.blurred.value) {
          blurred = true;
          break;
        }
      }
      this._blurred.value = blurred;
    });
  }
  _watchDirty() {
    watchEffect(() => {
      let dirty = false;
      const controls = this._controls.value;
      for (const control of controls) {
        if (control.dirty.value) {
          dirty = true;
          break;
        }
      }
      this._dirty.value = dirty;
    });
  }
}
const isAbstractControl = (val) => {
  return val instanceof AbstractControl;
};
const controlPropDef = [String, Number, Object];
const FORMS_CONTROL_TOKEN = Symbol("cdk-forms-control");
function useValueControl(options = {}) {
  const { controlKey = "control" } = options;
  const { props } = getCurrentInstance();
  const parentControl = inject(FORMS_CONTROL_TOKEN, shallowRef());
  const control = shallowRef();
  let watchStop;
  watch([() => props[controlKey], parentControl], ([controlOrPath, pControl]) => {
    if (watchStop) {
      watchStop();
      watchStop = void 0;
    }
    if (isAbstractControl(controlOrPath)) {
      control.value = controlOrPath;
    } else if (!!pControl && !isNil(controlOrPath)) {
      watchStop = watch(pControl.controls, () => {
        const _control = pControl.get(controlOrPath);
        if (process.env.NODE_ENV !== "production" && !_control) {
          Logger.warn("cdk/forms", `not find control by [${controlOrPath}]`);
        }
        control.value = _control;
      }, { immediate: true });
    }
  }, { immediate: true });
  return control;
}
function useValueAccessor(options) {
  const { control, valueKey = "value", disabledKey = "disabled" } = options;
  const { props } = getCurrentInstance();
  const accessor = shallowReactive({});
  let watchStop;
  watch(control, (currControl) => {
    if (watchStop) {
      watchStop();
      watchStop = void 0;
    }
    if (currControl) {
      accessor.valueRef = currControl.valueRef;
      accessor.disabled = currControl.disabled;
      accessor.setValue = (value) => currControl.setValue(value, { dirty: true });
      accessor.markAsBlurred = () => currControl.markAsBlurred();
    } else {
      const tempRef = ref(props[valueKey]);
      watchStop = watch(() => props[valueKey], (value) => tempRef.value = value);
      accessor.valueRef = computed(() => {
        var _a;
        return (_a = props[valueKey]) != null ? _a : tempRef.value;
      });
      accessor.disabled = computed(() => props[disabledKey]);
      accessor.setValue = (value) => {
        if (value != toRaw(accessor.valueRef.value)) {
          tempRef.value = value;
          callEmit(props[`onUpdate:${valueKey}`], value);
        }
      };
      accessor.markAsBlurred = NoopFunction;
    }
  }, { immediate: true });
  return accessor;
}

let hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch (e) {
  hasV8BreakIterator = false;
}
const testUserAgent = (regexp) => {
  return regexp.test(navigator.userAgent);
};
const isBrowser = typeof document === "object" && !!document;
const isEdge = isBrowser && testUserAgent(/(edge)/i);
const isTrident = isBrowser && testUserAgent(/(msie|trident)/i);
const isBlink = isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !isEdge && !isTrident;
const isWebKit = isBrowser && testUserAgent(/AppleWebKit/i) && !isBlink && !isEdge && !isTrident;
const isFirefox = isBrowser && testUserAgent(/(firefox|minefield)/i);
isBrowser && testUserAgent(/safari/i) && isWebKit;
isBrowser && testUserAgent(/iPad|iPhone|iPod/) && !("MSStream" in window);
isBrowser && testUserAgent(/android/i) && !isTrident;
let flexGapSupported$1;
function supportsFlexGap() {
  if (!isBrowser) {
    return false;
  }
  if (flexGapSupported$1 !== void 0) {
    return flexGapSupported$1;
  }
  const flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported$1 = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported$1;
}
let supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
let shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}

const mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
let mediaQueryStyleNode;
function createEmptyStyleRule(query) {
  if (mediaQueriesForWebkitCompatibility.has(query)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      ;
      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {.fx-query-test{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query);
    }
  } catch (err) {
    Logger.error("cdk/breakpoint", err);
  }
}
function noopMatchMedia(query) {
  return {
    matches: query === "all" || query === "",
    media: query,
    addEventListener: () => {
    },
    removeEventListener: () => {
    }
  };
}
const _matchMedia = isBrowser && window.matchMedia ? window.matchMedia.bind(window) : noopMatchMedia;
const matchMedia = (query) => {
  if (isWebKit) {
    createEmptyStyleRule(query);
  }
  return _matchMedia(query);
};
const _queries = /* @__PURE__ */ new Map();
function useMediaQuery(value) {
  const queries = splitQueries(value).map((query) => registerQuery(query));
  onScopeDispose(() => {
    queries.forEach((query) => {
      query.destroy();
      _queries.delete(query.media);
    });
  });
  return computed(() => {
    let matches = false;
    const medias = {};
    queries.forEach((query) => {
      const currMatches = query.matches.value;
      matches = matches || currMatches;
      medias[query.media] = currMatches;
    });
    return { matches, medias };
  });
}
function registerQuery(query) {
  if (_queries.has(query)) {
    return _queries.get(query);
  }
  const mql = matchMedia(query);
  const matches = ref(mql.matches);
  const handler = (evt) => {
    matches.value = evt.matches;
  };
  mql.addEventListener("change", handler);
  const destroy = () => mql.removeEventListener("change", handler);
  const output = { matches, destroy, media: query };
  _queries.set(query, output);
  return output;
}
function splitQueries(queries) {
  return convertArray(queries).map((query) => query.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query) => query.trim());
}
const BREAKPOINTS_KEYS = ["xs", "sm", "md", "lg", "xl"];
const BREAKPOINTS = {
  xs: "(max-width: 599.99px)",
  sm: "(min-width: 600px) and (max-width: 959.99px)",
  md: "(min-width: 960px) and (max-width: 1279.99px)",
  lg: "(min-width: 1280px) and (max-width: 1719.99px)",
  xl: "(min-width: 1720px)"
};
const BREAKPOINTS_TOKEN = Symbol("cdk-breakpoints");
function useBreakpoints(value) {
  const medias = value != null ? value : inject(BREAKPOINTS_TOKEN, BREAKPOINTS);
  const queryState = useMediaQuery(Object.values(medias));
  const match = reactive({});
  watchEffect(() => {
    const state = queryState.value;
    Object.entries(medias).forEach(([key, value2]) => {
      match[key] = state.medias[value2];
    });
  });
  return match;
}
const useSharedBreakpoints = createSharedComposable(() => useBreakpoints());

const rowToken = Symbol("rowToken");
const rowProps = {
  align: IxPropTypes.oneOf(["start", "center", "end", "baseline", "stretch"]),
  justify: IxPropTypes.oneOf(["start", "end", "center", "space-around", "space-between"]),
  gutter: IxPropTypes.oneOfType([
    Number,
    String,
    IxPropTypes.array(),
    IxPropTypes.object()
  ]).def(0),
  wrap: IxPropTypes.bool
};
const singleProp = IxPropTypes.oneOfType([Number, String]);
const breakpointConfig = IxPropTypes.oneOfType([Number, String, IxPropTypes.object()]);
const colProps = {
  flex: singleProp,
  span: singleProp,
  order: singleProp,
  offset: singleProp,
  push: singleProp,
  pull: singleProp,
  xs: breakpointConfig,
  sm: breakpointConfig,
  md: breakpointConfig,
  lg: breakpointConfig,
  xl: breakpointConfig
};
var Col = defineComponent({
  name: "IxCol",
  props: colProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-col`);
    const {
      mergedGutters
    } = inject(rowToken);
    const classes = computed(() => generateAllCls(props, mergedPrefixCls.value));
    const style = computed(() => {
      const style2 = {};
      const [verticalGutter, horizontalGutter] = mergedGutters.value;
      if (verticalGutter > 0) {
        style2.paddingTop = `${verticalGutter / 2}px`;
        style2.paddingBottom = style2.paddingTop;
      }
      if (horizontalGutter > 0) {
        style2.paddingLeft = `${horizontalGutter / 2}px`;
        style2.paddingRight = style2.paddingLeft;
      }
      if (props.flex) {
        style2.flex = parseFlex(props.flex);
      }
      return style2;
    });
    return () => createVNode("div", {
      "class": classes.value,
      "style": style.value
    }, [slots.default && slots.default()]);
  }
});
const attrKeys = ["span", "order", "offset", "push", "pull"];
function generateAllCls(props, prefixCLs) {
  const clsMap = /* @__PURE__ */ new Map([[prefixCLs, true]]);
  const generateSizeCls = (sizeConfig, size) => {
    attrKeys.forEach((attrKey) => {
      const attr = sizeConfig[attrKey];
      const cls = `${prefixCLs}${size ? `-${size}` : ""}-${attrKey}-${attr}`;
      clsMap.set(cls, !isUndefined(attr));
    });
  };
  generateSizeCls(props);
  BREAKPOINTS_KEYS.forEach((size) => {
    const sizeValue = props[size];
    if (!isUndefined(sizeValue)) {
      generateSizeCls(normalizeSizeProps(sizeValue), size);
    }
  });
  const allCls = {};
  clsMap.forEach((value, key) => {
    allCls[key] = value;
  });
  return normalizeClass(allCls);
}
function normalizeSizeProps(rawProps) {
  return isNumber(rawProps) || isString(rawProps) ? {
    span: rawProps
  } : rawProps;
}
function parseFlex(flex) {
  if (isNumeric(flex)) {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
var Row = defineComponent({
  name: "IxRow",
  props: rowProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-row`);
    const config = useGlobalConfig$1("row");
    const mergedGutters = useGutters(props);
    provide(rowToken, {
      mergedGutters
    });
    const classes = computed(() => {
      const {
        align,
        justify,
        wrap = config.wrap
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-align-${align}`]: align,
        [`${prefixCls}-justify-${justify}`]: justify,
        [`${prefixCls}-nowrap`]: !wrap
      });
    });
    const style = computed(() => {
      const [verticalGutter, horizontalGutter] = mergedGutters.value;
      const style2 = {};
      if (verticalGutter > 0) {
        style2.marginTop = `${verticalGutter / -2}px`;
        style2.marginBottom = style2.marginTop;
      }
      if (horizontalGutter > 0) {
        style2.marginLeft = `${horizontalGutter / -2}px`;
        style2.marginRight = style2.marginLeft;
      }
      return style2;
    });
    return () => createVNode("div", {
      "class": classes.value,
      "style": style.value
    }, [slots.default && slots.default()]);
  }
});
function useGutters(props) {
  const breakpoints = useSharedBreakpoints();
  return computed(() => {
    const {
      gutter
    } = props;
    const results = [0, 0];
    const gutters = isArray$1(gutter) ? gutter : [gutter, gutter];
    gutters.forEach((item, index) => {
      if (isObject(item)) {
        BREAKPOINTS_KEYS.some((key) => {
          const currGutter = item[key];
          const isActive = currGutter != null && breakpoints[key];
          if (isActive) {
            results[index] = convertNumber(currGutter);
          }
          return isActive;
        });
      } else {
        results[index] = convertNumber(item);
      }
    });
    return results;
  });
}
const IxRow = Row;
const IxCol = Col;

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    // Fallback to 1 in case both values are `0`

    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }

    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }

  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$1(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle$1(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

function useElement() {
  const element = ref(null);
  return element;
}
const defaultDelay$2 = 0;
function useState(options) {
  const {
    allowEnter = true,
    autoAdjust = true,
    delay = defaultDelay$2,
    disabled = false,
    offset = [0, 0],
    placement = "top",
    trigger = "hover",
    visible = false,
    strategy = "absolute",
    modifiers = [],
    onFirstUpdate = NoopFunction
  } = options;
  return reactive({
    allowEnter,
    autoAdjust,
    delay,
    disabled,
    offset,
    placement,
    trigger,
    visible,
    strategy,
    modifiers,
    onFirstUpdate
  });
}
function useBaseOptions(state) {
  return computed(() => {
    const { placement, strategy, onFirstUpdate, modifiers, offset, autoAdjust } = state;
    return { placement, strategy, onFirstUpdate, modifiers, offset, autoAdjust };
  });
}
function useVisibility(state) {
  return computed(() => !state.disabled && state.visible);
}
function usePlacement(state) {
  const _placement = ref(state.placement);
  const updatePlacement = (value) => {
    _placement.value = value;
  };
  watch(() => state.placement, updatePlacement);
  const placement = computed(() => _placement.value);
  return { placement, updatePlacement };
}
function useDelay(state) {
  const covertDelay = (delay) => {
    if (Array.isArray(delay)) {
      const [show, hide] = delay;
      return { show: show != null ? show : defaultDelay$2, hide: hide != null ? hide : defaultDelay$2 };
    }
    return { show: delay, hide: delay };
  };
  return computed(() => covertDelay(state.delay));
}
function useTimer() {
  let timer = null;
  const setTimer = (action, delay) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(action, delay);
  };
  const clearTimer = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  return { setTimer, clearTimer };
}
function useTriggerEvents(baseOptions, eventOptions) {
  const { visibility, show, hide } = eventOptions;
  const onMouseenter = () => show();
  const onMouseleave = () => hide();
  const onFocus = () => show();
  const onBlur = () => hide();
  const onClick = () => {
    const { trigger } = baseOptions;
    if (trigger === "click") {
      visibility.value ? hide() : show();
    } else if (trigger === "contextmenu") {
      visibility.value && hide();
    }
  };
  const onContextmenu = (evt) => {
    evt.preventDefault();
    show();
  };
  const eventsMap = {
    hover: { onMouseenter, onMouseleave },
    focus: { onFocus, onBlur },
    click: { onClick },
    contextmenu: { onClick, onContextmenu },
    manual: {}
  };
  return computed(() => eventsMap[baseOptions.trigger]);
}
function usePopperEvents(baseOptions, eventOptions) {
  const { show, hide } = eventOptions;
  const onMouseenter = () => show();
  const onMouseleave = () => hide();
  const eventsMap = {
    click: NoopObject,
    focus: NoopObject,
    hover: { onMouseenter, onMouseleave },
    contextmenu: NoopObject,
    manual: NoopObject
  };
  return computed(() => baseOptions.allowEnter ? eventsMap[baseOptions.trigger] : NoopObject);
}
function convertOptions$1(baseOptions, extraOptions) {
  const { placement, strategy, onFirstUpdate, modifiers, offset, autoAdjust } = baseOptions;
  const { arrowElement, updatePlacement } = extraOptions;
  return {
    placement: kebabCase$1(placement),
    strategy,
    onFirstUpdate,
    modifiers: [
      { name: "offset", options: { offset } },
      { name: "flip", enabled: autoAdjust, options: { padding: 4 } },
      { name: "arrow", enabled: !!arrowElement, options: { element: arrowElement, padding: 4 } },
      {
        name: "IDUX_updatePlacement",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: ({ state }) => updatePlacement(camelCase$1(state.placement))
      },
      ...modifiers
    ]
  };
}
function usePopper(options = {}) {
  let popperInstance = null;
  const triggerRef = useElement();
  const popperRef = useElement();
  const arrowRef = useElement();
  const state = useState(options);
  const baseOptions = useBaseOptions(state);
  const visibility = useVisibility(state);
  const { placement, updatePlacement } = usePlacement(state);
  const delay = useDelay(state);
  const { setTimer, clearTimer } = useTimer();
  const triggerEvents = useTriggerEvents(state, { visibility, show, hide });
  const popperEvents = usePopperEvents(state, { show, hide });
  function toggle(visible, delay2) {
    clearTimer();
    const action = () => {
      state.visible = visible;
    };
    if (delay2 > 0) {
      setTimer(action, delay2);
    } else {
      action();
    }
  }
  function show(showDelay = delay.value.show) {
    toggle(true, showDelay);
  }
  function hide(hideDelay = delay.value.hide) {
    toggle(false, hideDelay);
  }
  function update(options2) {
    if (options2) {
      Object.entries(options2).forEach(([key, value]) => {
        if (value !== void 0 && !isEqual(value, state[key])) {
          state[key] = value;
        }
      });
      return;
    }
    popperInstance == null ? void 0 : popperInstance.update();
  }
  function forceUpdate() {
    popperInstance == null ? void 0 : popperInstance.forceUpdate();
  }
  function destroy() {
    clearTimer();
    if (!popperInstance) {
      return;
    }
    popperInstance.destroy();
    popperInstance = null;
  }
  let initWatchStop = null;
  function initialize() {
    if (initWatchStop) {
      initWatchStop();
    }
    initWatchStop = watch([triggerRef, popperRef], ([trigger, popper]) => {
      const triggerElement = convertElement(trigger);
      const popperElement = convertElement(popper);
      if (!triggerElement || !popperElement) {
        return;
      }
      destroy();
      const options2 = convertOptions$1(baseOptions.value, { arrowElement: convertElement(arrowRef), updatePlacement });
      popperInstance = createPopper(triggerElement, popperElement, options2);
    }, { immediate: true });
  }
  watch(visibility, (value) => {
    if (value) {
      clearTimer();
      popperInstance == null ? void 0 : popperInstance.update();
    }
  });
  watch([baseOptions, arrowRef], ([currBaseOptions, arrowElement]) => {
    popperInstance == null ? void 0 : popperInstance.setOptions(convertOptions$1(currBaseOptions, { arrowElement: convertElement(arrowElement), updatePlacement }));
  });
  return {
    visibility,
    placement,
    triggerRef,
    triggerEvents,
    popperRef,
    popperEvents,
    arrowRef,
    initialize,
    show,
    hide,
    update,
    forceUpdate,
    destroy
  };
}

const overlayPlacementDef = IxPropTypes.oneOf([
  "topStart",
  "top",
  "topEnd",
  "rightStart",
  "right",
  "rightEnd",
  "bottomStart",
  "bottom",
  "bottomEnd",
  "leftStart",
  "left",
  "leftEnd"
]);
const overlayTriggerDef = IxPropTypes.oneOf(["click", "hover", "focus", "contextmenu", "manual"]);
const overlayDelayDef = IxPropTypes.oneOfType([
  Number,
  IxPropTypes.array()
]);
const overlayProps = {
  visible: IxPropTypes.bool,
  allowEnter: IxPropTypes.bool,
  autoAdjust: IxPropTypes.bool,
  clickOutside: IxPropTypes.bool,
  delay: overlayDelayDef,
  destroyOnHide: IxPropTypes.bool,
  disabled: IxPropTypes.bool,
  offset: IxPropTypes.array(),
  placement: overlayPlacementDef,
  showArrow: IxPropTypes.bool,
  target: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]).isRequired,
  transitionName: IxPropTypes.string,
  trigger: overlayTriggerDef,
  "onUpdate:visible": IxPropTypes.emit(),
  "onUpdate:placement": IxPropTypes.emit(),
  onAfterLeave: IxPropTypes.emit()
};
var __defProp$s = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$y = Object.getOwnPropertySymbols;
var __hasOwnProp$y = Object.prototype.hasOwnProperty;
var __propIsEnum$y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$y.call(b, prop))
      __defNormalProp$s(a, prop, b[prop]);
  if (__getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(b)) {
      if (__propIsEnum$y.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$j = (a, b) => __defProps$j(a, __getOwnPropDescs$j(b));
var Overlay$1 = defineComponent({
  inheritAttrs: false,
  props: overlayProps,
  setup(props, {
    slots,
    attrs,
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-overlay`);
    const popperOptions = usePopperOptions(props);
    const {
      arrowRef,
      popperRef,
      popperEvents,
      triggerRef,
      triggerEvents,
      visibility,
      placement,
      initialize,
      update,
      forceUpdate,
      show,
      hide,
      destroy
    } = usePopper(__spreadProps$j(__spreadValues$s({}, popperOptions.value), {
      visible: props.visible
    }));
    onMounted(() => initialize());
    onBeforeUnmount(() => destroy());
    watch(visibility, (value) => callEmit(props["onUpdate:visible"], value));
    watch(placement, (value) => callEmit(props["onUpdate:placement"], value));
    watch(popperOptions, (options) => update(options));
    watch(() => props.visible, (visible) => visible ? show() : hide());
    const onAfterLeave = () => {
      if (props.destroyOnHide) {
        destroy();
      }
      callEmit(props.onAfterLeave);
    };
    expose({
      updatePopper: update,
      forceUpdatePopper: forceUpdate
    });
    const handleClickOutside = (evt) => {
      const popperElement = convertElement(popperRef);
      const target = evt.target;
      if (!popperElement || popperElement === target || popperElement.contains(target)) {
        return;
      }
      hide();
    };
    return () => {
      var _a, _b;
      const triggerNode = getFirstValidNode((_a = slots.default) == null ? void 0 : _a.call(slots));
      if (!triggerNode) {
        process.env.NODE_ENV !== "production" && Logger.warn("components/overlay", "Trigger must is single rooted node");
        return null;
      }
      const contentNode = (_b = slots.content) == null ? void 0 : _b.call(slots);
      if (!getFirstValidNode(contentNode)) {
        return triggerNode;
      }
      const trigger = renderTrigger$1(props, triggerNode, __spreadValues$s({
        ref: triggerRef
      }, triggerEvents.value), handleClickOutside);
      const content = renderContent$2(props, mergedPrefixCls, visibility, contentNode, arrowRef, popperRef, popperEvents, attrs);
      return createVNode(Fragment, null, [trigger, createVNode(CdkPortal, {
        "target": props.target,
        "load": visibility.value
      }, {
        default: () => [createVNode(Transition, {
          "appear": true,
          "name": props.transitionName,
          "onAfterLeave": onAfterLeave
        }, {
          default: () => [content]
        })]
      })]);
    };
  }
});
function usePopperOptions(props) {
  return computed(() => {
    const {
      allowEnter,
      autoAdjust,
      delay,
      disabled,
      offset,
      placement,
      trigger
    } = props;
    return {
      allowEnter,
      autoAdjust,
      delay,
      disabled,
      offset,
      placement,
      trigger
    };
  });
}
function renderContent$2(props, mergedPrefixCls, visibility, contentNode, arrowRef, popperRef, popperEvents, attrs) {
  if (props.destroyOnHide && !visibility.value) {
    return null;
  }
  const prefixCls = mergedPrefixCls.value;
  const overlay = createVNode("div", mergeProps({
    "ref": popperRef,
    "class": prefixCls
  }, popperEvents.value, attrs), [contentNode, props.showArrow && createVNode("div", {
    "ref": arrowRef,
    "class": `${prefixCls}-arrow`
  }, null)]);
  return props.destroyOnHide ? overlay : withDirectives(overlay, [[vShow, visibility.value]]);
}
function renderTrigger$1(props, triggerNode, extraProps, handleClickOutside) {
  const element = cloneVNode(triggerNode, extraProps, true);
  if (props.clickOutside) {
    return withDirectives(element, [[clickOutside, handleClickOutside]]);
  }
  return element;
}
const \u0275Overlay = Overlay$1;

const tooltipProps = {
  visible: IxPropTypes.bool,
  autoAdjust: IxPropTypes.bool,
  destroyOnHide: IxPropTypes.bool,
  delay: overlayDelayDef,
  placement: overlayPlacementDef,
  target: portalTargetDef,
  title: IxPropTypes.string,
  trigger: overlayTriggerDef,
  "onUpdate:visible": IxPropTypes.emit()
};
const defaultOffset$4 = [0, 12];
function useTooltipOverlay(props, config, mergedPrefixCls) {
  const overlayRef = ref();
  const updatePopper = () => {
    var _a;
    return (_a = overlayRef.value) == null ? void 0 : _a.updatePopper();
  };
  const [visible, setVisible] = useControlledProp(props, "visible", false);
  const overlayProps = computed(() => {
    var _a, _b, _c, _d, _e, _f, _g;
    const trigger = (_a = props.trigger) != null ? _a : config.trigger;
    return {
      visible: visible.value,
      ["onUpdate:visible"]: setVisible,
      autoAdjust: (_b = props.autoAdjust) != null ? _b : config.autoAdjust,
      clickOutside: trigger === "click" || trigger === "contextmenu",
      delay: (_c = props.delay) != null ? _c : config.delay,
      destroyOnHide: (_d = props.destroyOnHide) != null ? _d : config.destroyOnHide,
      offset: defaultOffset$4,
      showArrow: true,
      placement: (_e = props.placement) != null ? _e : config.placement,
      target: (_g = (_f = props.target) != null ? _f : config.target) != null ? _g : `${mergedPrefixCls.value}-container`,
      trigger
    };
  });
  return { overlayRef, updatePopper, visible, setVisible, overlayProps };
}
var Tooltip = defineComponent({
  name: "IxTooltip",
  props: tooltipProps,
  setup(props, {
    slots,
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-tooltip`);
    const config = useGlobalConfig$1("tooltip");
    const {
      overlayRef,
      updatePopper,
      overlayProps
    } = useTooltipOverlay(props, config, mergedPrefixCls);
    expose({
      updatePopper
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(\u0275Overlay, mergeProps({
        "ref": overlayRef,
        "class": prefixCls,
        "transitionName": `${common.prefixCls}-fade-fast`
      }, overlayProps.value), {
        default: slots.default,
        content: () => renderContent$1(props, slots, prefixCls)
      });
    };
  }
});
const renderContent$1 = (props, slots, prefixCls) => {
  var _a, _b;
  if (!(slots.title || props.title)) {
    return null;
  }
  return createVNode("div", {
    "class": `${prefixCls}-wrapper`
  }, [(_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : props.title]);
};
const IxTooltip = Tooltip;

const formToken = Symbol("formToken");
const FORM_TOKEN = Symbol("FORM_TOKEN");
const FORM_ITEM_TOKEN = Symbol("FORM_ITEM_TOKEN");
function useFormItemRegister(control) {
  const context = inject(FORM_ITEM_TOKEN, null);
  if (context) {
    const key = useKey();
    const { registerControl, unregisterControl } = context;
    registerControl(key, control);
    onBeforeUnmount(() => unregisterControl(key));
  }
}
const colProp = IxPropTypes.oneOfType([String, Number, IxPropTypes.object()]);
const formProps = {
  colonless: IxPropTypes.bool,
  control: controlPropDef,
  controlCol: colProp,
  hasFeedback: IxPropTypes.bool.def(false),
  labelAlign: IxPropTypes.oneOf(["start", "end"]),
  labelCol: colProp,
  layout: IxPropTypes.oneOf(["horizontal", "vertical", "inline"]),
  size: IxPropTypes.oneOf(["lg", "md", "sm"])
};
const formItemProps = {
  colonless: IxPropTypes.bool,
  control: controlPropDef,
  controlCol: colProp,
  extra: IxPropTypes.string,
  hasFeedback: IxPropTypes.bool,
  label: IxPropTypes.string,
  labelAlign: IxPropTypes.oneOf(["start", "end"]),
  labelCol: colProp,
  labelFor: IxPropTypes.string,
  labelTooltip: IxPropTypes.string,
  required: IxPropTypes.bool.def(false),
  message: IxPropTypes.oneOfType([
    String,
    IxPropTypes.func(),
    IxPropTypes.object()
  ]),
  status: IxPropTypes.oneOf(["valid", "invalid", "validating"])
};
const formWrapperProps = {
  control: controlPropDef
};
var Form = defineComponent({
  name: "IxForm",
  props: formProps,
  setup(props, {
    slots
  }) {
    const control = useValueControl();
    provide(FORMS_CONTROL_TOKEN, control);
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-form`);
    const config = useGlobalConfig$1("form");
    const colonless = computed(() => {
      var _a;
      return (_a = props.colonless) != null ? _a : config.colonless;
    });
    const labelAlign = computed(() => {
      var _a;
      return (_a = props.labelAlign) != null ? _a : config.labelAlign;
    });
    const layout = computed(() => {
      var _a;
      return (_a = props.layout) != null ? _a : config.layout;
    });
    const size = computed(() => {
      var _a;
      return (_a = props.size) != null ? _a : config.size;
    });
    provide(formToken, {
      colonless,
      controlCol: toRef(props, "controlCol"),
      hasFeedback: toRef(props, "hasFeedback"),
      labelAlign,
      labelCol: toRef(props, "labelCol")
    });
    provide(FORM_TOKEN, {
      size
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-${layout.value}`]: true,
        [`${prefixCls}-${size.value}`]: true
      };
    });
    return () => {
      var _a;
      return createVNode("form", {
        "class": classes.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
var __hasOwnProp$x = Object.prototype.hasOwnProperty;
var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
var __objRest$h = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$x.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$x.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var FormItem = defineComponent({
  name: "IxFormItem",
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-form-item`);
    const formContext = inject(formToken, null);
    const labelColConfig = computed(() => {
      var _a;
      return normalizeColConfig((_a = props.labelCol) != null ? _a : formContext == null ? void 0 : formContext.labelCol.value);
    });
    const controlColConfig = computed(() => {
      var _a;
      return normalizeColConfig((_a = props.controlCol) != null ? _a : formContext == null ? void 0 : formContext.controlCol.value);
    });
    const hasFeedback = computed(() => {
      var _a;
      return (_a = props.hasFeedback) != null ? _a : !!(formContext == null ? void 0 : formContext.hasFeedback.value);
    });
    const {
      status,
      statusIcon,
      message
    } = useControlStatus(props);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const currStatus = status.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-has-feedback`]: hasFeedback.value && !!currStatus,
        [`${prefixCls}-has-message`]: !!message.value,
        [`${prefixCls}-${currStatus}`]: !!currStatus
      };
    });
    const labelClasses = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const {
        colonless = formContext == null ? void 0 : formContext.colonless.value,
        labelAlign = formContext == null ? void 0 : formContext.labelAlign.value,
        required
      } = props;
      return {
        [`${prefixCls}-label`]: true,
        [`${prefixCls}-label-colonless`]: colonless,
        [`${prefixCls}-label-required`]: required,
        [`${prefixCls}-label-start`]: labelAlign === "start"
      };
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(IxRow, {
        "class": classes.value
      }, {
        default: () => [renderLabel$1(props, slots, labelClasses, labelColConfig, prefixCls), renderControl(props, slots, controlColConfig, hasFeedback, statusIcon, message, prefixCls)]
      });
    };
  }
});
function renderLabel$1(props, slots, classes, labelColConfig, prefixCls) {
  var _a;
  const {
    label,
    labelFor,
    labelTooltip
  } = props;
  const {
    label: labelSlot,
    labelTooltip: labelTooltipSlot
  } = slots;
  if (!(label || labelSlot || labelTooltip || labelTooltipSlot)) {
    return void 0;
  }
  const tooltipNode = (_a = labelTooltipSlot == null ? void 0 : labelTooltipSlot()) != null ? _a : labelTooltip && createVNode(IxTooltip, {
    "title": labelTooltip
  }, {
    default: () => [createVNode(IxIcon, {
      "name": "question-circle"
    }, null)]
  });
  return createVNode(IxCol, mergeProps({
    "class": classes.value
  }, labelColConfig.value), {
    default: () => {
      var _a2;
      return [createVNode("label", {
        "for": labelFor
      }, [(_a2 = labelSlot == null ? void 0 : labelSlot()) != null ? _a2 : label, tooltipNode && createVNode("span", {
        "class": `${prefixCls}-label-tooltip`
      }, [tooltipNode])])];
    }
  });
}
function renderControl(props, slots, controlColConfig, hasFeedback, statusIcon, message, prefixCls) {
  var _a;
  const {
    extra
  } = props;
  const {
    extra: extraSlot
  } = slots;
  const statusNode = hasFeedback.value && statusIcon.value && createVNode("span", {
    "class": `${prefixCls}-status-icon`
  }, [createVNode(IxIcon, {
    "name": statusIcon.value
  }, null)]);
  const messageNode = message.value && createVNode("div", {
    "class": `${prefixCls}-message`
  }, [message.value]);
  const extraNode = (_a = extraSlot == null ? void 0 : extraSlot()) != null ? _a : extra;
  const extraWrapper = extraNode && createVNode("div", {
    "class": `${prefixCls}-extra`
  }, [extraNode]);
  return createVNode(IxCol, mergeProps({
    "class": `${prefixCls}-control`
  }, controlColConfig.value), {
    default: () => {
      var _a2;
      return [createVNode("div", {
        "class": `${prefixCls}-control-input`
      }, [createVNode("div", {
        "class": `${prefixCls}-control-input-content`
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), statusNode]), messageNode, extraWrapper];
    }
  });
}
function normalizeColConfig(col) {
  return isNumber(col) || isString(col) ? {
    span: col
  } : col;
}
function useControl() {
  const firstChildControl = shallowRef();
  let firstChildKey;
  let firstChildWatchStop;
  const registerControl = (key, control2) => {
    if (!firstChildWatchStop) {
      firstChildKey = key;
      firstChildWatchStop = watchEffect(() => firstChildControl.value = control2.value);
    }
  };
  const unregisterControl = (key) => {
    if (key === firstChildKey) {
      if (firstChildWatchStop) {
        firstChildWatchStop();
        firstChildWatchStop = void 0;
      }
      firstChildControl.value = void 0;
    }
  };
  provide(FORM_ITEM_TOKEN, {
    registerControl,
    unregisterControl
  });
  const selfControl = useValueControl();
  const control = shallowRef();
  watch([selfControl, firstChildControl], ([self, child]) => {
    const target = self != null ? self : child;
    if (control.value !== target) {
      control.value = target;
    }
  }, {
    immediate: true
  });
  return control;
}
const iconTypeMap = {
  invalid: "close-circle-filled",
  validating: "loading",
  valid: "check-circle-filled"
};
function useControlStatus(props) {
  const control = useControl();
  const status = useStatus$2(props, control);
  const message = useMessage(props, control, status);
  const statusIcon = computed(() => {
    const currStatus = status.value;
    return currStatus ? iconTypeMap[currStatus] : void 0;
  });
  return {
    status,
    statusIcon,
    message
  };
}
function useStatus$2(props, control) {
  return computed(() => {
    if (props.status) {
      return props.status;
    }
    const currControl = control.value;
    if (!currControl) {
      return void 0;
    }
    const {
      trigger,
      dirty,
      blurred
    } = currControl;
    if (trigger === "change" && dirty.value || trigger === "blur" && blurred.value) {
      return currControl.status.value;
    }
    return void 0;
  });
}
function useMessage(props, control, status) {
  const locale = getLocale();
  const messages = computed(() => {
    const message = props.message;
    return isString(message) || isFunction(message) ? {
      invalid: message
    } : message || {};
  });
  return computed(() => {
    const currStatus = status.value;
    if (!currStatus) {
      return void 0;
    }
    const currMessage = messages.value[currStatus];
    if (currMessage) {
      return isString(currMessage) ? currMessage : currMessage(control.value);
    }
    const currControl = control.value;
    return getMessageByError(currControl, currControl == null ? void 0 : currControl.errors.value, locale);
  });
}
function getMessageByError(control, error, locale) {
  if (!error) {
    return void 0;
  }
  for (const key in error) {
    const _a = error[key], {
      message
    } = _a, rest = __objRest$h(_a, [
      "message"
    ]);
    if (message) {
      if (isString(message)) {
        return message;
      }
      if (isFunction(message)) {
        return message(rest, control);
      }
      const currMessage = message[locale.value.type];
      if (isString(currMessage)) {
        return currMessage;
      }
      return currMessage(rest, control);
    }
  }
  return void 0;
}
var FormWrapper = defineComponent({
  name: "IxFormWrapper",
  props: formWrapperProps,
  setup(_, {
    slots
  }) {
    const control = useValueControl();
    provide(FORMS_CONTROL_TOKEN, control);
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots);
    };
  }
});
const IxForm = Form;
const IxFormItem = FormItem;
const IxFormWrapper = FormWrapper;

function isFakeMousedownFromScreenReader(event) {
  return event.offsetX === 0 && event.offsetY === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var __defProp$1$b = Object.defineProperty;
var __getOwnPropSymbols$1$e = Object.getOwnPropertySymbols;
var __hasOwnProp$1$e = Object.prototype.hasOwnProperty;
var __propIsEnum$1$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$b = (obj, key, value) => key in obj ? __defProp$1$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$e.call(b, prop))
      __defNormalProp$1$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$e)
    for (var prop of __getOwnPropSymbols$1$e(b)) {
      if (__propIsEnum$1$e.call(b, prop))
        __defNormalProp$1$b(a, prop, b[prop]);
    }
  return a;
};
const INPUT_MODALITY_DETECTOR_OPTIONS_TOKEN = Symbol("cdk-input-modality-detector-options");
const INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreCodes: ["AltLeft", "AltRight", "ControlLeft", "ControlRight", "OSLeft", "OSRight", "ShiftLeft", "ShiftRight"]
};
const TOUCH_BUFFER_MS = 650;
const modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
function useInputModalityDetector(options) {
  const contextOptions = inject(INPUT_MODALITY_DETECTOR_OPTIONS_TOKEN, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS);
  const _options = __spreadValues$1$b(__spreadValues$1$b({}, contextOptions), options);
  const _modality = ref(null);
  const _modalityDetected = customRef((track, trigger) => {
    let value = null;
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
      }
    };
  });
  const changeModality = (value) => {
    _modality.value = value;
    _modalityDetected.value = value;
  };
  const _target = ref(null);
  let _lastTouchMs = 0;
  const _onKeydown = (event) => {
    var _a;
    if ((_a = _options.ignoreCodes) == null ? void 0 : _a.some((code) => code === event.code)) {
      return;
    }
    changeModality("keyboard");
    _target.value = _getEventTarget(event);
  };
  const _onMousedown = (event) => {
    if (Date.now() - _lastTouchMs < TOUCH_BUFFER_MS) {
      return;
    }
    changeModality(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
    _target.value = _getEventTarget(event);
  };
  const _onTouchstart = (event) => {
    if (isFakeTouchstartFromScreenReader(event)) {
      changeModality("keyboard");
      return;
    }
    _lastTouchMs = Date.now();
    changeModality("touch");
    _target.value = _getEventTarget(event);
  };
  if (isBrowser) {
    document.addEventListener("keydown", _onKeydown, modalityEventListenerOptions);
    document.addEventListener("mousedown", _onMousedown, modalityEventListenerOptions);
    document.addEventListener("touchstart", _onTouchstart, modalityEventListenerOptions);
  }
  onScopeDispose(() => {
    if (isBrowser) {
      document.removeEventListener("keydown", _onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", _onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", _onTouchstart, modalityEventListenerOptions);
    }
  });
  return {
    modality: _modality,
    modalityDetected: _modalityDetected,
    target: _target
  };
}
const useSharedInputModalityDetector = createSharedComposable(() => useInputModalityDetector());
var __defProp$r = Object.defineProperty;
var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
var __hasOwnProp$w = Object.prototype.hasOwnProperty;
var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$w.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(b)) {
      if (__propIsEnum$w.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
const FOCUS_MONITOR_OPTIONS_TOKEN = Symbol("cdk-focus-monitor-options");
const FOCUS_MONITOR_DEFAULT_OPTIONS = {
  detectionMode: "immediate"
};
const captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
function useFocusMonitor(options) {
  var _a;
  const contextOptions = inject(FOCUS_MONITOR_OPTIONS_TOKEN, FOCUS_MONITOR_DEFAULT_OPTIONS);
  const _options = __spreadValues$r(__spreadValues$r({}, contextOptions), options);
  const _detectionMode = _options.detectionMode;
  const _inputModalityDetector = (_a = _options.inputModalityDetector) != null ? _a : useSharedInputModalityDetector();
  let _origin = null;
  let _lastFocusOrigin;
  let _windowFocused = false;
  let _windowFocusTimeoutId;
  let _originTimeoutId;
  let _originFromTouchInteraction = false;
  const _elementInfo = /* @__PURE__ */ new Map();
  let _monitoredElementCount = 0;
  const _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
  const _windowFocusListener = () => {
    _windowFocused = true;
    _windowFocusTimeoutId = setTimeout(() => _windowFocused = false);
  };
  let _stopInputModalityDetector = null;
  const _rootNodeFocusAndBlurListener = (event) => {
    const target = _getEventTarget(event);
    const handler = event.type === "focus" ? _onFocus : _onBlur;
    for (let element = target; element; element = element.parentElement) {
      handler(event, element);
    }
  };
  function monitor(element, checkChildren = false) {
    const nativeElement = convertElement(element);
    if (!isBrowser || !nativeElement || nativeElement.nodeType !== 1) {
      return computed(() => ({ origin: null }));
    }
    const rootNode = _getShadowRoot(nativeElement) || _getDocument();
    const cachedInfo = _elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return computed(() => cachedInfo.subject.value);
    }
    const info = {
      checkChildren,
      subject: shallowRef({ origin: null }),
      rootNode
    };
    _elementInfo.set(nativeElement, info);
    _registerGlobalListeners(info);
    return computed(() => info.subject.value);
  }
  function stopMonitoring(element) {
    const nativeElement = convertElement(element);
    if (!nativeElement) {
      return;
    }
    const elementInfo = _elementInfo.get(nativeElement);
    if (elementInfo) {
      _setClasses(nativeElement);
      _elementInfo.delete(nativeElement);
      _removeGlobalListeners(elementInfo);
    }
  }
  function focusVia(element, origin, options2) {
    const nativeElement = convertElement(element);
    const focusedElement = _getDocument().activeElement;
    if (nativeElement === focusedElement) {
      _getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => _originChanged(currentElement, origin, info));
    } else {
      _setOrigin(origin);
      if (nativeElement && typeof nativeElement.focus === "function") {
        nativeElement.focus(options2);
      }
    }
  }
  function blurVia(element) {
    const nativeElement = convertElement(element);
    if (!nativeElement) {
      return;
    }
    const focusedElement = _getDocument().activeElement;
    if (nativeElement === focusedElement && typeof nativeElement.blur === "function") {
      nativeElement.blur();
    }
  }
  function _getDocument() {
    return document;
  }
  function _getWindow() {
    const doc = _getDocument();
    return doc.defaultView || window;
  }
  function _toggleClass(element, className, shouldSet) {
    if (shouldSet) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }
  function _getFocusOrigin(focusEventTarget) {
    if (_origin) {
      if (_originFromTouchInteraction) {
        return _shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return _origin;
      }
    }
    return _windowFocused && _lastFocusOrigin ? _lastFocusOrigin : "program";
  }
  function _shouldBeAttributedToTouch(focusEventTarget) {
    return _detectionMode === "eventual" || !!(focusEventTarget == null ? void 0 : focusEventTarget.contains(_inputModalityDetector.target.value));
  }
  function _setClasses(element, origin) {
    _toggleClass(element, "cdk-focused", !!origin);
    _toggleClass(element, "cdk-touch-focused", origin === "touch");
    _toggleClass(element, "cdk-keyboard-focused", origin === "keyboard");
    _toggleClass(element, "cdk-mouse-focused", origin === "mouse");
    _toggleClass(element, "cdk-program-focused", origin === "program");
  }
  function _setOrigin(origin, isFromInteraction = false) {
    _origin = origin;
    _originFromTouchInteraction = origin === "touch" && isFromInteraction;
    if (_detectionMode === "immediate") {
      clearTimeout(_originTimeoutId);
      const ms = _originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
      _originTimeoutId = setTimeout(() => _origin = null, ms);
    }
  }
  function _onFocus(event, element) {
    const elementInfo = _elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    _originChanged(element, _getFocusOrigin(focusEventTarget), elementInfo, event);
  }
  function _onBlur(event, element) {
    const elementInfo = _elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    _setClasses(element);
    _emitOrigin(elementInfo.subject, null, event);
  }
  function _emitOrigin(subject, origin, event) {
    subject.value = { origin, event };
  }
  function _registerGlobalListeners(elementInfo) {
    if (!isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = _rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      rootNode.addEventListener("focus", _rootNodeFocusAndBlurListener, captureEventListenerOptions);
      rootNode.addEventListener("blur", _rootNodeFocusAndBlurListener, captureEventListenerOptions);
    }
    _rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++_monitoredElementCount === 1) {
      const window2 = _getWindow();
      window2.addEventListener("focus", _windowFocusListener);
      _stopInputModalityDetector = watchEffect(() => {
        _setOrigin(_inputModalityDetector.modalityDetected.value, true);
      });
    }
  }
  function _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (_rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = _rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        _rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", _rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", _rootNodeFocusAndBlurListener, captureEventListenerOptions);
        _rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--_monitoredElementCount) {
      const window2 = _getWindow();
      window2.removeEventListener("focus", _windowFocusListener);
      if (_stopInputModalityDetector) {
        _stopInputModalityDetector();
        _stopInputModalityDetector = null;
      }
      clearTimeout(_windowFocusTimeoutId);
      clearTimeout(_originTimeoutId);
    }
  }
  function _originChanged(element, origin, elementInfo, event) {
    _setClasses(element, origin);
    _emitOrigin(elementInfo.subject, origin, event);
    _lastFocusOrigin = origin;
  }
  function _getClosestElementsInfo(element) {
    const results = [];
    _elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  onScopeDispose(() => _elementInfo.forEach((_info, element) => stopMonitoring(element)));
  return { monitor, stopMonitoring, focusVia, blurVia };
}
const useSharedFocusMonitor = createSharedComposable(() => useFocusMonitor());

const presetColors = [
  "red",
  "orange",
  "brown",
  "yellow",
  "canary",
  "bud",
  "green",
  "turquoise",
  "cyan",
  "glacier",
  "blue",
  "indigo",
  "purple",
  "magenta"
];
function isPresetColor(color) {
  return presetColors.includes(color);
}
const statusColors = ["primary", "info", "pending", "success", "warning", "error"];
function isStatusColor(color) {
  return statusColors.includes(color);
}
function covertTarget(target) {
  const temp = isFunction(target) ? target() : target;
  if (isString(temp)) {
    const targetDom = document.querySelector(temp);
    if (targetDom) {
      return targetDom;
    } else {
      process.env.NODE_ENV !== "production" && Logger.warn("components/utils", `target does not exist: ${target}, default value are already used: window.`);
      return window;
    }
  }
  return temp || window;
}
function covertIconVNode(slots, props, key) {
  let iconSlot;
  let iconName;
  if (key) {
    iconSlot = slots[key];
    if (!iconSlot) {
      iconName = props[key];
    }
  } else {
    iconSlot = slots;
    iconName = props;
  }
  if (iconSlot) {
    return iconSlot();
  }
  return isString(iconName) ? createVNode(IxIcon, { name: iconName }, null) : iconName;
}
function covertStringVNode(slots, props, key) {
  let labelSlot;
  let label;
  if (key) {
    labelSlot = slots[key];
    if (!labelSlot) {
      label = props[key];
    }
  } else {
    labelSlot = slots;
    label = props;
  }
  return labelSlot ? labelSlot() : label;
}
function useFormAccessor(valueKey) {
  const control = useValueControl();
  const accessor = useValueAccessor({ control, valueKey });
  useFormItemRegister(control);
  return accessor;
}
function useFormElement() {
  const elementRef = ref();
  const focus = (options) => {
    var _a;
    (_a = elementRef.value) == null ? void 0 : _a.focus(options);
  };
  const blur = () => {
    var _a;
    return (_a = elementRef.value) == null ? void 0 : _a.blur();
  };
  return { elementRef, focus, blur };
}
function useFormFocusMonitor(options) {
  const focusMonitor = useSharedFocusMonitor();
  const elementRef = ref();
  let watchStopHandle;
  watch(elementRef, (currElement, prevElement) => {
    watchStopHandle == null ? void 0 : watchStopHandle();
    focusMonitor.stopMonitoring(prevElement);
    watchStopHandle = watch(focusMonitor.monitor(currElement, options.checkChildren), (evt) => {
      const { origin, event } = evt;
      if (event) {
        origin ? options.handleFocus(event) : options.handleBlur(event);
      }
    });
  });
  onBeforeUnmount(() => {
    watchStopHandle == null ? void 0 : watchStopHandle();
    focusMonitor.stopMonitoring(elementRef.value);
  });
  const focus = (options2) => focusMonitor.focusVia(elementRef.value, "program", options2);
  const blur = () => focusMonitor.blurVia(elementRef.value);
  return { elementRef, focus, blur };
}
function useKey() {
  var _a;
  const { vnode, uid } = getCurrentInstance();
  return (_a = vnode.key) != null ? _a : uid;
}

const affixProps = {
  offset: IxPropTypes.oneOfType([Number, String, IxPropTypes.object()]).def(0),
  target: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]),
  onChange: IxPropTypes.func()
};
const events = ["scroll", "resize"];
const directions = ["top", "bottom", "left", "right"];
function normalizeOffset(offset) {
  if (!isObject(offset)) {
    return { top: convertNumber(offset) };
  }
  const _offset = {};
  Object.keys(offset).forEach((dire) => {
    _offset[dire] = convertNumber(offset[dire]);
  });
  return _offset;
}
function getTargetRect(target, container) {
  const targetRect = target.getBoundingClientRect();
  const containerRect = isHTMLElement$1(container) ? container.getBoundingClientRect() : { top: 0, bottom: window.innerHeight, left: 0, right: window.innerWidth };
  return {
    top: targetRect.top - containerRect.top,
    left: targetRect.left - containerRect.left,
    bottom: containerRect.bottom - targetRect.bottom,
    right: containerRect.right - targetRect.right
  };
}
function getTargetSize(target) {
  if (target === window) {
    return {
      width: target.innerWidth,
      height: target.innerHeight
    };
  }
  return {
    width: target.offsetWidth,
    height: target.offsetHeight
  };
}
function observeTarget(target, cb) {
  events.forEach((event) => {
    on(target, event, cb);
  });
}
function removeObserveTarget(target, cb) {
  events.forEach((event) => {
    off(target, event, cb);
  });
}
function isDireSticky(dire, affixRect, offsetOption) {
  return !isUndefined(offsetOption[dire]) && affixRect[dire] <= offsetOption[dire];
}
function isSticky(affixRect, offsetOption) {
  return directions.some((dire) => isDireSticky(dire, affixRect, offsetOption));
}
function calcPosition(affixRect, offsetOption, target) {
  const style = {};
  if (isSticky(affixRect, offsetOption)) {
    style.position = target === window ? "fixed" : "absolute";
    const _directions = [
      isDireSticky("bottom", affixRect, offsetOption) ? "bottom" : "top",
      isDireSticky("right", affixRect, offsetOption) ? "right" : "left"
    ];
    _directions.forEach((dire) => {
      if (isDireSticky(dire, affixRect, offsetOption)) {
        style[dire] = `${offsetOption[dire] - (target === window ? 0 : affixRect[dire])}px`;
      } else {
        style[dire] = `${target === window ? affixRect[dire] : 0}px`;
      }
    });
  }
  return style;
}
var __defProp$q = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
var __hasOwnProp$v = Object.prototype.hasOwnProperty;
var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$v.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(b)) {
      if (__propIsEnum$v.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$i = (a, b) => __defProps$i(a, __getOwnPropDescs$i(b));
var Affix = defineComponent({
  name: "IxAffix",
  props: affixProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-affix`);
    const contentStyle = ref({});
    const affixStyle = ref({});
    const targetRef = ref(null);
    const affixRef = ref(null);
    const contentRef = ref(null);
    const offset = computed(() => normalizeOffset(props.offset));
    const isStickyRef = ref(false);
    watch(isStickyRef, (value) => {
      var _a;
      return (_a = props.onChange) == null ? void 0 : _a.call(props, value);
    });
    const throttleMeasure = throttleRAF(measure);
    function measure(event) {
      if (!affixRef.value || !targetRef.value) {
        return;
      }
      const affixRect = getTargetRect(affixRef.value, targetRef.value);
      isStickyRef.value = isSticky(affixRect, offset.value);
      contentStyle.value = calcPosition(affixRect, offset.value, targetRef.value);
      if (isStickyRef.value && contentRef.value) {
        if (event && event.type === "resize") {
          clearStyle();
          nextTick(() => {
            measure();
          });
          return;
        }
        const {
          width,
          height
        } = getTargetSize(contentRef.value);
        contentStyle.value = __spreadProps$i(__spreadValues$q({}, contentStyle.value), {
          width: `${width}px`,
          height: `${height}px`
        });
        affixStyle.value = {
          width: `${width}px`,
          height: `${height}px`
        };
        if (targetRef.value !== window) {
          affixStyle.value.position = "relative";
        }
      }
    }
    function clearStyle() {
      affixStyle.value = {};
      contentStyle.value = {};
    }
    onMounted(() => {
      nextTick(() => {
        initContainer();
        measure();
      });
    });
    onUnmounted(() => {
      var _a;
      removeObserveTarget(targetRef.value, throttleMeasure);
      (_a = throttleMeasure.cancel) == null ? void 0 : _a.call(throttleMeasure);
    });
    watch(() => props.offset, measure);
    watch(() => props.target, () => {
      removeObserveTarget(targetRef.value, throttleMeasure);
      initContainer();
      measure();
    });
    function initContainer() {
      targetRef.value = covertTarget(props.target);
      observeTarget(targetRef.value, throttleMeasure);
    }
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "ref": affixRef,
        "style": affixStyle.value,
        "class": prefixCls
      }, [createVNode("div", {
        "ref": contentRef,
        "class": `${prefixCls}-content`,
        "style": contentStyle.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
const IxAffix = Affix;

var __async$8 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useCloseable(props, config) {
  const closeable = computed(() => {
    var _a;
    return (_a = props.closable) != null ? _a : config.closable;
  });
  const [visible, setVisible] = useState$1(true);
  const handleClose = () => __async$8(this, null, function* () {
    const result = yield callEmit(props.onBeforeClose);
    if (result === false) {
      return;
    }
    setVisible(false);
    callEmit(props.onClose);
  });
  return { closeable, visible, handleClose };
}
function usePagination$1(props, titleChildren) {
  const [pageIndex, setPageIndex] = useControlledPageIndex(props);
  const pageTotal = computed(() => titleChildren.value.length);
  const pageText = computed(() => `${pageIndex.value}/${pageTotal.value}`);
  const isPagination = computed(() => props.pagination && pageTotal.value > 1);
  const leftDisabled = computed(() => pageIndex.value <= 1);
  const rightDisabled = computed(() => pageIndex.value >= pageTotal.value);
  const offsetPageIndex = (offset) => {
    if (offset === -1 && leftDisabled.value) {
      return;
    }
    if (offset === 1 && rightDisabled.value) {
      return;
    }
    setPageIndex(pageIndex.value + offset);
  };
  return {
    pageIndex,
    pageText,
    isPagination,
    leftDisabled,
    rightDisabled,
    offsetPageIndex
  };
}
function useControlledPageIndex(props) {
  const tempProp = ref(1);
  watchEffect(() => {
    const { pagination } = props;
    if (isObject(pagination) && !isNil(pagination.pageIndex)) {
      tempProp.value = pagination.pageIndex;
    }
  });
  const state = computed(() => {
    const { pagination } = props;
    if (isObject(pagination) && !isNil(pagination.pageIndex)) {
      return pagination.pageIndex;
    }
    return tempProp.value;
  });
  const setState = (value) => {
    if (value !== state.value) {
      tempProp.value = value;
      const { pagination } = props;
      if (isObject(pagination)) {
        callEmit(pagination.onChange, value);
      }
    }
  };
  return [state, setState];
}
const alertProps = {
  closable: IxPropTypes.bool,
  closeIcon: IxPropTypes.string.def("close"),
  description: IxPropTypes.string,
  icon: IxPropTypes.string,
  title: IxPropTypes.oneOfType([String, IxPropTypes.arrayOf(String)]),
  pagination: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]).def(false),
  type: IxPropTypes.oneOf(["success", "info", "warning", "error"]).def("info"),
  onBeforeClose: IxPropTypes.emit(),
  onClose: IxPropTypes.emit()
};
var Alert = defineComponent({
  name: "IxAlert",
  props: alertProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-alert`);
    const config = useGlobalConfig$1("alert");
    const mergedIcon = computed(() => {
      if (props.icon !== void 0) {
        return props.icon;
      }
      const iconConfig = config.icon;
      return isObject(iconConfig) ? iconConfig[props.type] : iconConfig;
    });
    const titleChildren = computed(() => {
      if (slots.default) {
        return flattenNode(slots.default());
      }
      return convertArray(props.title);
    });
    const {
      pageIndex,
      pageText,
      isPagination,
      leftDisabled,
      rightDisabled,
      offsetPageIndex
    } = usePagination$1(props, titleChildren);
    const {
      closeable,
      visible,
      handleClose
    } = useCloseable(props, config);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${props.type}`]: true,
        [`${prefixCls}-with-description`]: slots.description || props.description
      });
    });
    const paginationLeftIconClass = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-pagination-icon`]: true,
        [`${prefixCls}-pagination-disabled`]: leftDisabled.value
      });
    });
    const paginationRightIconClass = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-pagination-icon`]: true,
        [`${prefixCls}-pagination-disabled`]: rightDisabled.value
      });
    });
    return () => {
      var _a, _b;
      const pagination = isPagination.value;
      const titleNodes = pagination ? titleChildren.value[pageIndex.value - 1] : titleChildren.value;
      const iconNode = slots.icon ? slots.icon() : mergedIcon.value && createVNode(IxIcon, {
        "name": mergedIcon.value
      }, null);
      const descriptionNode = (_b = (_a = slots.description) == null ? void 0 : _a.call(slots)) != null ? _b : props.description;
      const prefixCls = mergedPrefixCls.value;
      return createVNode(Transition, {
        "name": prefixCls
      }, {
        default: () => [visible.value && createVNode("div", {
          "class": classes.value
        }, [iconNode && createVNode("span", {
          "class": `${prefixCls}-icon`
        }, [iconNode]), createVNode("div", {
          "class": `${prefixCls}-content`
        }, [createVNode("div", {
          "class": `${prefixCls}-title`
        }, [titleNodes]), descriptionNode && createVNode("div", {
          "class": `${prefixCls}-description`
        }, [descriptionNode])]), pagination && createVNode("div", {
          "class": `${prefixCls}-pagination`
        }, [createVNode("span", {
          "class": paginationLeftIconClass.value,
          "onClick": () => offsetPageIndex(-1)
        }, [createVNode(IxIcon, {
          "name": "left"
        }, null)]), createVNode("span", {
          "class": `${prefixCls}-pagination-text`
        }, [pageText.value]), createVNode("span", {
          "class": paginationRightIconClass.value,
          "onClick": () => offsetPageIndex(1)
        }, [createVNode(IxIcon, {
          "name": "right"
        }, null)])]), closeable.value && createVNode("span", {
          "class": `${prefixCls}-close-icon`,
          "onClick": handleClose
        }, [slots.closeIcon ? slots.closeIcon() : createVNode(IxIcon, {
          "name": props.closeIcon
        }, null)])])]
      });
    };
  }
});
const IxAlert = Alert;

const anchorToken = Symbol("anchorToken");
const anchorProps = {
  affix: IxPropTypes.bool.def(true),
  bounds: IxPropTypes.number,
  hideLinkBall: IxPropTypes.bool,
  offsetTop: IxPropTypes.number,
  target: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]),
  targetOffset: IxPropTypes.number,
  onChange: IxPropTypes.emit(),
  onClick: IxPropTypes.emit()
};
const linkProps = {
  href: IxPropTypes.string.isRequired,
  title: IxPropTypes.string
};
var Anchor = defineComponent({
  name: "IxAnchor",
  props: anchorProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-anchor`);
    const config = useGlobalConfig$1("anchor");
    const hideLinkBall = computed(() => {
      var _a;
      return (_a = props.hideLinkBall) != null ? _a : config.hideLinkBall;
    });
    const wrapperStyle = computed(() => {
      const {
        offsetTop
      } = props;
      return {
        maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh"
      };
    });
    const {
      activeLink
    } = useLinks(props, config);
    const {
      anchorRef,
      inkBallElRef,
      inkBallClasses,
      inkBallTop
    } = useInkBall(activeLink, mergedPrefixCls);
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      const linkBall = hideLinkBall.value ? null : createVNode("span", {
        "class": inkBallClasses.value,
        "style": {
          top: inkBallTop.value
        },
        "ref": inkBallElRef
      }, null);
      const anchorNode = createVNode("div", {
        "class": `${prefixCls}-wrapper`,
        "style": wrapperStyle.value
      }, [createVNode("div", {
        "class": prefixCls,
        "ref": anchorRef
      }, [createVNode("div", {
        "class": `${prefixCls}-ink`
      }, [linkBall]), (_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      if (!props.affix) {
        return anchorNode;
      }
      return createVNode(IxAffix, {
        "target": props.target,
        "offset": props.offsetTop
      }, {
        default: () => [anchorNode]
      });
    };
  }
});
const useLinks = (props, config) => {
  const links = ref([]);
  const registerLink = (link) => {
    if (!links.value.includes(link)) {
      links.value.push(link);
    }
  };
  const unregisterLink = (link) => {
    const index = links.value.indexOf(link);
    if (index !== -1) {
      links.value.splice(index, 1);
    }
  };
  const activeLink = ref();
  const setActiveLink = (link) => {
    if (activeLink.value !== link) {
      activeLink.value = link;
      callEmit(props.onChange, link);
    }
  };
  const {
    scrollTo
  } = useScroll$1(props, config, links, setActiveLink);
  const handleLinkClick = (evt, linkProps2) => {
    callEmit(props.onClick, evt, linkProps2);
    scrollTo(linkProps2.href);
  };
  provide(anchorToken, {
    registerLink,
    unregisterLink,
    activeLink,
    handleLinkClick
  });
  return {
    activeLink
  };
};
const useInkBall = (activeLink, mergedPrefixCls) => {
  const anchorRef = ref();
  const inkBallElRef = ref();
  const inkBallClasses = computed(() => {
    const prefixCls = mergedPrefixCls.value;
    return {
      [`${prefixCls}-ink-ball`]: true,
      [`${prefixCls}-ink-ball-visible`]: !!activeLink.value
    };
  });
  const inkBallTop = ref();
  onMounted(() => {
    watchEffect(() => {
      var _a, _b, _c;
      const activeLinkElement = (_a = anchorRef.value) == null ? void 0 : _a.querySelector(`a[data-href="${activeLink.value}"]`);
      if (!activeLinkElement) {
        return;
      }
      const inkBallHeight = (_c = (_b = inkBallElRef.value) == null ? void 0 : _b.getBoundingClientRect().height) != null ? _c : 9;
      const {
        offsetTop,
        clientHeight
      } = activeLinkElement;
      inkBallTop.value = `${offsetTop + clientHeight / 2 - inkBallHeight / 2}px`;
    });
  });
  return {
    anchorRef,
    inkBallElRef,
    inkBallClasses,
    inkBallTop
  };
};
const getTargetTop = (link, container) => {
  const targetElement = document.getElementById(link.split("#")[1]);
  if (targetElement) {
    const {
      top
    } = getOffset(targetElement, container);
    return top;
  }
  return null;
};
const getCurrentAnchor = (links, container, offsetTop, bounds) => {
  const maxSection = links.reduce((curr, link) => {
    const top = getTargetTop(link, container);
    if (top !== null && top < offsetTop + bounds && curr.top < top) {
      return {
        link,
        top
      };
    }
    return curr;
  }, {
    link: "",
    top: Number.MIN_SAFE_INTEGER
  });
  return maxSection.link;
};
const useScroll$1 = (props, config, links, setActiveLink) => {
  const bounds = computed(() => {
    var _a;
    return (_a = props.bounds) != null ? _a : config.bounds;
  });
  const container = ref();
  const eventType = "scroll";
  let animating = false;
  const targetOffset = computed(() => {
    var _a, _b;
    return (_b = (_a = props.targetOffset) != null ? _a : props.offsetTop) != null ? _b : 0;
  });
  const handleScroll = () => {
    if (animating) {
      return;
    }
    const currLink = getCurrentAnchor(links.value, container.value, targetOffset.value, bounds.value);
    setActiveLink(currLink);
  };
  const scrollTo = (link) => {
    setActiveLink(link);
    const top = getTargetTop(link, container.value);
    if (top === null) {
      return;
    }
    animating = true;
    scrollToTop({
      amountOfChange: top - targetOffset.value,
      target: container.value,
      callback: () => {
        animating = false;
      }
    });
  };
  watch(() => props.target, () => {
    off(container.value, eventType, handleScroll);
    container.value = covertTarget(props.target);
    on(container.value, eventType, handleScroll);
    handleScroll();
  });
  onMounted(() => {
    container.value = covertTarget(props.target);
    on(container.value, eventType, handleScroll);
    handleScroll();
  });
  onBeforeUnmount(() => {
    off(container.value, eventType, handleScroll);
  });
  return {
    scrollTo
  };
};
var AnchorLink = defineComponent({
  name: "IxAnchorLink",
  props: linkProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-anchor-link`);
    const {
      registerLink,
      unregisterLink,
      activeLink,
      handleLinkClick
    } = inject(anchorToken);
    watch(() => props.href, (newHref, oldHref) => {
      unregisterLink(oldHref);
      registerLink(newHref);
    });
    onMounted(() => registerLink(props.href));
    onBeforeUnmount(() => unregisterLink(props.href));
    const isActive = computed(() => activeLink.value === props.href);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [`${prefixCls}-title`]: true,
        [`${prefixCls}-title-active`]: isActive.value
      };
    });
    const onClick = (evt) => handleLinkClick(evt, props);
    return () => {
      var _a, _b, _c;
      const {
        href,
        title
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("a", {
        "class": classes.value,
        "href": href,
        "data-href": href,
        "title": title,
        "onClick": onClick
      }, [(_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : title]), (_c = slots.default) == null ? void 0 : _c.call(slots)]);
    };
  }
});
const IxAnchor = Anchor;
const IxAnchorLink = AnchorLink;

const sizeProp = IxPropTypes.oneOfType([
  Number,
  IxPropTypes.oneOf(["lg", "md", "sm"]),
  IxPropTypes.object()
]);
const avatarProps = {
  alt: IxPropTypes.string,
  gap: IxPropTypes.number,
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  shape: IxPropTypes.oneOf(["circle", "square"]),
  size: sizeProp,
  src: IxPropTypes.string,
  srcset: IxPropTypes.string,
  text: IxPropTypes.string,
  onError: IxPropTypes.emit()
};
var Avatar = defineComponent({
  name: "IxAvatar",
  props: avatarProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-avatar`);
    const config = useGlobalConfig$1("avatar");
    const showText = ref(false);
    watchEffect(() => {
      showText.value = !props.src && (!!props.text || hasSlot(slots));
    });
    const showIcon = ref(false);
    watchEffect(() => {
      showIcon.value = !props.src && !showText.value;
    });
    const icon$$ = computed(() => {
      var _a;
      return (_a = props.icon) != null ? _a : config.icon;
    });
    const {
      avatarRef,
      textRef,
      size,
      avatarStyle,
      textStyle
    } = useSize$1(props, config);
    const classes = useClasses$8(props, config, size, showText, showIcon, mergedPrefixCls);
    const handleError = (evt) => {
      const result = callEmit(props.onError, evt);
      if (result !== false && !evt.defaultPrevented) {
        if (!!props.text || hasSlot(slots)) {
          showText.value = true;
        }
        showIcon.value = !showText.value;
      }
    };
    return () => {
      var _a, _b;
      let child;
      const prefixCls = mergedPrefixCls.value;
      if (showIcon.value) {
        child = renderIcon$6(slots.icon, icon$$.value);
      } else if (showText.value) {
        const textChild = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : props.text;
        child = createVNode("span", {
          "ref": textRef,
          "class": `${prefixCls}-text`,
          "style": textStyle.value
        }, [textChild]);
      } else {
        child = createVNode("img", {
          "src": props.src,
          "srcset": props.srcset,
          "alt": props.alt,
          "onError": handleError
        }, null);
      }
      return createVNode("span", {
        "ref": avatarRef,
        "class": classes.value,
        "style": avatarStyle.value
      }, [child]);
    };
  }
});
const useClasses$8 = (props, config, size, showText, showIcon, mergedPrefixCls) => {
  return computed(() => {
    var _a;
    const shape = (_a = props.shape) != null ? _a : config.shape;
    const sizeValue = size.value;
    const prefixCls = mergedPrefixCls.value;
    return {
      [`${prefixCls}`]: true,
      [`${prefixCls}-image`]: !!props.src && !showText.value && !showIcon.value,
      [`${prefixCls}-${shape}`]: true,
      [`${prefixCls}-${sizeValue}`]: isString(sizeValue)
    };
  });
};
const useSizeStyle = (size) => {
  const breakpoints = useSharedBreakpoints();
  return computed(() => {
    let currSize;
    const sizeValue = size.value;
    if (isNumber(sizeValue)) {
      currSize = sizeValue;
    } else if (isObject(sizeValue)) {
      const currBreakpoint = Object.keys(breakpoints).find((key) => breakpoints[key]);
      currSize = sizeValue[currBreakpoint];
    }
    return getSizeStyle(currSize);
  });
};
const getSizeStyle = (size) => {
  if (!size) {
    return {};
  }
  const sizePixel = convertCssPixel(size);
  return {
    width: sizePixel,
    height: sizePixel,
    lineHeight: sizePixel,
    fontSize: convertCssPixel(size / 2)
  };
};
const renderIcon$6 = (iconSlot, icon) => {
  if (iconSlot) {
    return iconSlot();
  }
  return isVNode(icon) ? icon : createVNode(IxIcon, {
    "name": icon
  }, null);
};
const useSize$1 = (props, config) => {
  const avatarRef = ref();
  const textRef = ref();
  const size = computed(() => {
    var _a;
    return (_a = props.size) != null ? _a : config.size;
  });
  const gap = computed(() => {
    var _a;
    return (_a = props.gap) != null ? _a : config.gap;
  });
  const avatarStyle = useSizeStyle(size);
  const textScale = ref(1);
  const textStyle = computed(() => ({
    transform: `scale(${textScale.value}) translateX(-50%)`,
    lineHeight: avatarStyle.value.lineHeight
  }));
  const calcTextSize = () => {
    const avatarElement = avatarRef.value;
    const textElement = textRef.value;
    if (!avatarElement || !textElement) {
      return;
    }
    const avatarWidth = avatarElement.offsetWidth;
    const textWidth = textElement.offsetWidth;
    const gapWidth = gap.value * 2;
    if (avatarWidth !== 0 && textWidth !== 0 && gapWidth < avatarWidth) {
      textScale.value = avatarWidth - gapWidth < textWidth ? (avatarWidth - gapWidth) / textWidth : 1;
    }
  };
  onMounted(() => {
    watch(textRef, (newEl, oldEl) => {
      offResize(oldEl, calcTextSize);
      onResize(newEl, calcTextSize);
      calcTextSize();
    }, {
      immediate: true
    });
    watch(gap, () => calcTextSize(), {
      immediate: true
    });
  });
  onBeforeUnmount(() => offResize(textRef.value, calcTextSize));
  return {
    avatarRef,
    textRef,
    size,
    calcTextSize,
    avatarStyle,
    textStyle
  };
};
const IxAvatar = Avatar;

const backTopProps$1 = {
  target: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]),
  duration: IxPropTypes.number,
  visibilityHeight: IxPropTypes.number,
  onClick: IxPropTypes.emit()
};
var BackTop = defineComponent({
  name: "IxBackTop",
  props: backTopProps$1,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-back-top`);
    const config = useGlobalConfig$1("backTop");
    const eventType = "scroll";
    const visible = ref(false);
    const container = ref(null);
    const duration = computed(() => {
      var _a;
      return (_a = props.duration) != null ? _a : config.duration;
    });
    const handleScroll = () => {
      var _a;
      const {
        scrollTop
      } = getScroll(container.value);
      visible.value = scrollTop >= ((_a = props.visibilityHeight) != null ? _a : config.visibilityHeight);
    };
    const handleClick = (evt) => {
      evt.stopPropagation();
      scrollToTop({
        top: 0,
        duration: duration.value,
        target: container.value
      });
      callEmit(props.onClick, evt);
    };
    const throttledScrollHandler = throttle(handleScroll, 300);
    onMounted(() => {
      nextTick(() => {
        container.value = covertTarget(props.target);
        on(container.value, eventType, throttledScrollHandler);
        handleScroll();
      });
    });
    onUnmounted(() => {
      off(container.value, eventType, throttledScrollHandler);
    });
    return () => {
      return createVNode(Transition, {
        "name": `${common.prefixCls}-fade`
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": mergedPrefixCls.value,
          "onClick": handleClick
        }, [slots.default ? slots.default() : createVNode(IxIcon, {
          "name": "vertical-align-top"
        }, null)]), [[vShow, visible.value]])]
      });
    };
  }
});
const IxBackTop = BackTop;

const backTopProps = {
  count: IxPropTypes.oneOfType([Number, String]).def(0),
  showZero: IxPropTypes.bool,
  overflowCount: IxPropTypes.number,
  dot: IxPropTypes.bool,
  color: IxPropTypes.string
};
var Badge = defineComponent({
  name: "IxBadge",
  props: backTopProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-badge`);
    const badgeConfig = useGlobalConfig$1("badge");
    const showZero = computed(() => {
      var _a;
      return (_a = props.showZero) != null ? _a : badgeConfig.showZero;
    });
    const dot = computed(() => {
      var _a;
      return (_a = props.dot) != null ? _a : badgeConfig.dot;
    });
    const overflowCount = computed(() => {
      var _a;
      return (_a = props.overflowCount) != null ? _a : badgeConfig.overflowCount;
    });
    const hasDefaultSlot = computed(() => hasSlot(slots));
    const hasCountSlot = computed(() => hasSlot(slots, "count"));
    const classes = useClasses$7(props, hasDefaultSlot, hasCountSlot, showZero, dot, mergedPrefixCls);
    const styles = useStyles(props, hasCountSlot, dot);
    const countValue = useCountValue(props, hasCountSlot, showZero, dot, overflowCount);
    return () => {
      var _a, _b, _c;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("span", {
        "class": `${prefixCls}-wrapper`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots), createVNode("sup", {
        "class": classes.value,
        "style": styles.value
      }, [(_c = (_b = slots.count) == null ? void 0 : _b.call(slots)) != null ? _c : countValue.value])]);
    };
  }
});
const useCountValue = (props, hasCountSlot, showZero, dot, overflowCount) => {
  return computed(() => {
    if (!hasCountSlot.value && !dot.value) {
      if (!showZero.value && +props.count === 0) {
        return false;
      }
      if (isNumeric(props.count)) {
        return props.count > convertNumber(overflowCount.value, Number.MAX_VALUE) ? `${overflowCount.value}+` : `${props.count}`;
      }
      return props.count;
    }
    return false;
  });
};
const useStyles = (props, hasCountSlot, dot) => {
  return computed(() => {
    var _a;
    const color = (_a = props.color) != null ? _a : "";
    if (hasCountSlot.value) {
      return {
        color
      };
    } else if (dot.value) {
      return {
        backgroundColor: color
      };
    } else {
      return {
        backgroundColor: color
      };
    }
  });
};
const useClasses$7 = (props, hasDefaultSlot, hasCountSlot, showZero, dot, mergedPrefixCls) => {
  return computed(() => {
    const prefixCls = mergedPrefixCls.value;
    return {
      [prefixCls]: true,
      [`${prefixCls}-empty`]: !hasDefaultSlot.value,
      [`${prefixCls}-slot-count`]: hasCountSlot.value,
      [`${prefixCls}-dot`]: !hasCountSlot.value && dot.value,
      [`${prefixCls}-count`]: !hasCountSlot.value && !dot.value,
      [`${prefixCls}-hide-zero`]: !hasCountSlot.value && !dot.value && !showZero.value && +props.count === 0
    };
  });
};
const IxBadge = Badge;

const breadcrumbToken = Symbol("breadcrumbToken");
const breadcrumbProps = {
  separator: IxPropTypes.string.def("/")
};
const breadcrumbItemProps = {
  separator: IxPropTypes.string
};
var Breadcrumb = defineComponent({
  name: "IxBreadcrumb",
  props: breadcrumbProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-breadcrumb`);
    provide(breadcrumbToken, {
      mergedPrefixCls,
      separatorRef: toRef(props, "separator")
    });
    return () => {
      var _a;
      return createVNode("nav", {
        "class": mergedPrefixCls.value,
        "aria-label": "Breadcrumb"
      }, [createVNode("ol", null, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
var BreadcrumbItem = defineComponent({
  name: "IxBreadcrumbItem",
  props: breadcrumbItemProps,
  setup(props, {
    slots
  }) {
    const breadcrumbInjection = inject(breadcrumbToken, null);
    if (!breadcrumbInjection) {
      if (process.env.NODE_ENV !== "production") {
        Logger.error("components/breadcrumb", "`breadcrumb-item` must be placed inside `breadcrumb`.");
      }
      return () => null;
    }
    const {
      mergedPrefixCls,
      separatorRef
    } = breadcrumbInjection;
    return () => {
      var _a, _b;
      return createVNode("li", {
        "class": `${mergedPrefixCls.value}-item`
      }, [createVNode("span", {
        "class": `${mergedPrefixCls.value}-item-link`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), createVNode("span", {
        "class": `${mergedPrefixCls.value}-item-separator`,
        "aria-hidden": "true"
      }, [slots.separator ? slots.separator() : (_b = props.separator) != null ? _b : separatorRef.value])]);
    };
  }
});
const IxBreadcrumb = Breadcrumb;
const IxBreadcrumbItem = BreadcrumbItem;

const buttonToken = Symbol("button");
const buttonProps = {
  mode: IxPropTypes.oneOf(["primary", "default", "dashed", "text", "link"]),
  danger: IxPropTypes.bool,
  ghost: IxPropTypes.bool,
  disabled: IxPropTypes.bool,
  loading: IxPropTypes.bool,
  size: IxPropTypes.oneOf(["lg", "md", "sm"]),
  shape: IxPropTypes.oneOf(["circle", "round"]),
  block: IxPropTypes.bool,
  icon: IxPropTypes.string,
  type: IxPropTypes.oneOf(["button", "submit", "reset"]).def("button")
};
const buttonGroupProps = {
  mode: IxPropTypes.oneOf(["primary", "default", "dashed", "text", "link"]),
  size: IxPropTypes.oneOf(["lg", "md", "sm"]),
  shape: IxPropTypes.oneOf(["circle", "round"])
};
var Button = defineComponent({
  name: "IxButton",
  props: buttonProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-button`);
    const groupProps = inject(buttonToken, {});
    const formContext = inject(FORM_TOKEN, null);
    const mode = computed(() => {
      var _a, _b;
      return (_b = (_a = props.mode) != null ? _a : groupProps.mode) != null ? _b : "default";
    });
    const size = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = props.size) != null ? _a : groupProps.size) != null ? _b : formContext == null ? void 0 : formContext.size.value) != null ? _c : "md";
    });
    const classes = computed(() => {
      const {
        block,
        danger,
        disabled,
        ghost,
        loading,
        icon,
        shape = groupProps.shape
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-danger`]: danger,
        [`${prefixCls}-disabled`]: disabled || loading,
        [`${prefixCls}-ghost`]: ghost,
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-icon-only`]: !slots.default && (icon || loading),
        [`${prefixCls}-${mode.value}`]: mode.value !== "default",
        [`${prefixCls}-${shape}`]: !!shape,
        [`${prefixCls}-${size.value}`]: true
      });
    });
    return () => {
      const {
        disabled,
        loading,
        icon,
        type
      } = props;
      const children = [];
      if (loading) {
        children.push(createVNode(IxIcon, {
          "name": "loading"
        }, null));
      } else if (slots.icon) {
        children.push(slots.icon());
      } else if (icon) {
        children.push(createVNode(IxIcon, {
          "name": icon
        }, null));
      }
      if (slots.default) {
        children.push(createVNode("span", null, [slots.default()]));
      }
      if (mode.value === "link") {
        return createVNode("a", {
          "class": classes.value
        }, [children]);
      }
      return createVNode("button", {
        "class": classes.value,
        "disabled": disabled || loading,
        "type": type
      }, [children]);
    };
  }
});
var ButtonGroup = defineComponent({
  name: "IxButtonGroup",
  props: buttonGroupProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-button-group`);
    provide(buttonToken, props);
    return () => createVNode("div", {
      "class": mergedPrefixCls.value
    }, [slots.default && slots.default()]);
  }
});
const IxButton = Button;
const IxButtonGroup = ButtonGroup;

const headerProps = {
  avatar: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  description: IxPropTypes.string,
  disabled: IxPropTypes.bool.def(false),
  prefix: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  size: IxPropTypes.oneOf(["xl", "lg", "md", "sm"]).def("md"),
  showBar: IxPropTypes.bool.def(false),
  subTitle: IxPropTypes.string,
  suffix: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  title: IxPropTypes.string,
  onPrefixClick: IxPropTypes.emit(),
  onSuffixClick: IxPropTypes.emit()
};
const avatarSizeTransformMap = {
  xl: "md",
  lg: "md",
  md: "sm",
  sm: "sm"
};
var Header$2 = defineComponent({
  name: "IxHeader",
  props: headerProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-header`);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-with-bar`]: props.showBar,
        [`${prefixCls}-${props.size}`]: true
      });
    });
    const avatarSize = computed(() => avatarSizeTransformMap[props.size]);
    const onPrefixClick = (evt) => !props.disabled && callEmit(props.onPrefixClick, evt);
    const onSuffixClick = (evt) => !props.disabled && callEmit(props.onSuffixClick, evt);
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const prefixIconNode = covertIconVNode(slots, props, "prefix");
      const suffixIconNode = covertIconVNode(slots, props, "suffix");
      const titleNode = covertStringVNode(slots.default, props.title);
      const subTitleNode = covertStringVNode(slots, props, "subTitle");
      const descriptionNode = covertStringVNode(slots, props, "description");
      return createVNode("div", {
        "class": classes.value
      }, [createVNode("div", {
        "class": `${prefixCls}-content`
      }, [prefixIconNode && createVNode("span", {
        "class": `${prefixCls}-prefix`,
        "onClick": onPrefixClick
      }, [prefixIconNode]), renderAvatar(slots.avatar, props.avatar, avatarSize), titleNode && createVNode("span", {
        "class": `${prefixCls}-title`
      }, [titleNode]), subTitleNode && createVNode("span", {
        "class": `${prefixCls}-sub-title`
      }, [subTitleNode]), suffixIconNode && createVNode("span", {
        "class": `${prefixCls}-suffix`,
        "onClick": onSuffixClick
      }, [suffixIconNode])]), descriptionNode && createVNode("div", {
        "class": `${prefixCls}-description`
      }, [descriptionNode])]);
    };
  }
});
const renderAvatar = (slot, avatar, size) => {
  if (slot) {
    return slot();
  }
  if (!avatar) {
    return null;
  }
  const avatarProps = isString(avatar) ? {
    icon: avatar
  } : avatar;
  return createVNode(IxAvatar, mergeProps({
    "size": size.value
  }, avatarProps), null);
};
const IxHeader = Header$2;

var __defProp$p = Object.defineProperty;
var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
var __hasOwnProp$u = Object.prototype.hasOwnProperty;
var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$u.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(b)) {
      if (__propIsEnum$u.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
const Header$1 = (props, {
  slots
}) => {
  if (slots.header) {
    return slots.header(props);
  }
  if (!props.header && !props.closable) {
    return void 0;
  }
  const headerProps = covertProps(props);
  const headerSlots = {
    suffix: slots.closeIcon
  };
  return createVNode(IxHeader, headerProps, headerSlots);
};
const defaultSize = "sm";
function covertProps(props) {
  var _a;
  const {
    closable,
    closeIcon,
    header,
    onClose
  } = props;
  const headerProps = isString(header) ? {
    size: defaultSize,
    title: header
  } : __spreadValues$p({
    size: defaultSize
  }, header);
  if (closable) {
    headerProps.suffix = (_a = headerProps.suffix) != null ? _a : closeIcon;
    if (onClose) {
      const onSuffixClick = convertArray(headerProps.onSuffixClick);
      onSuffixClick.push(onClose);
      headerProps.onSuffixClick = onSuffixClick;
    }
  }
  return headerProps;
}
const \u0275Header = Header$1;

const cardToken = Symbol("cardToken");
const cardProps = {
  borderless: IxPropTypes.bool,
  cover: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  hoverable: IxPropTypes.bool,
  loading: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  footer: IxPropTypes.array()
};
const cardGridProps = {
  hoverable: IxPropTypes.bool
};
var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
var __hasOwnProp$t = Object.prototype.hasOwnProperty;
var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
var __objRest$g = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$t.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$t.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Card = defineComponent({
  name: "IxCard",
  props: cardProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-card`);
    const config = useGlobalConfig$1("card");
    const hoverable = computed(() => {
      var _a;
      return (_a = props.hoverable) != null ? _a : config.hoverable;
    });
    provide(cardToken, {
      hoverable
    });
    const children = computed(() => {
      var _a;
      return ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
    });
    const hasGrid = computed(() => {
      return children.value.some((node) => node.type && node.type.name === "IxCardGrid");
    });
    const classes = computed(() => {
      const {
        borderless = config.borderless,
        loading,
        size = config.size
      } = props;
      const hasGridValue = hasGrid.value;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-borderless`]: borderless,
        [`${prefixCls}-hoverable`]: !hasGridValue && hoverable.value,
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-has-grid`]: hasGridValue,
        [`${prefixCls}-${size}`]: true
      });
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "class": classes.value
      }, [renderCover(props, slots, prefixCls), createVNode(\u0275Header, {
        "header": props.header
      }, slots), renderBody(props, children, hasGrid, prefixCls), renderFooter$2(props, slots, prefixCls)]);
    };
  }
});
const renderCover = (props, slots, prefixCls) => {
  let coverNode;
  if (slots.cover) {
    coverNode = slots.cover();
  } else if (props.cover) {
    const {
      cover
    } = props;
    const imgProps = isString(cover) ? {
      src: cover
    } : cover;
    coverNode = createVNode("img", imgProps, null);
  }
  return coverNode ? createVNode("div", {
    "class": `${prefixCls}-cover`
  }, [coverNode]) : void 0;
};
const renderBody = (props, children, hasGrid, prefixCls) => {
  let bodyNode;
  if (props.loading) {
    bodyNode = renderLoading(prefixCls);
  } else if (children.value.length) {
    bodyNode = hasGrid.value ? createVNode(IxRow, null, {
      default: () => [children.value]
    }) : children.value;
  }
  return bodyNode ? createVNode("div", {
    "class": `${prefixCls}-body`
  }, [bodyNode]) : void 0;
};
const loadingSpans = [[22], [8, 15], [6, 18], [13, 9], [4, 3, 16], [8, 6, 8]];
const renderLoading = (prefixCls) => {
  const loadingChild = loadingSpans.map((spans) => {
    const cols = spans.map((span) => createVNode(IxCol, {
      "span": span,
      "class": `${prefixCls}-loading-col`
    }, {
      default: () => [createVNode("div", {
        "class": `${prefixCls}-loading-block`
      }, null)]
    }));
    return createVNode(IxRow, null, {
      default: () => [cols]
    });
  });
  return createVNode("div", {
    "class": `${prefixCls}-loading`
  }, [loadingChild]);
};
const renderFooter$2 = (props, slots, prefixCls) => {
  if (!slots.footer && !props.footer) {
    return void 0;
  }
  let footerNode;
  if (slots.footer) {
    footerNode = slots.footer();
  } else {
    footerNode = props.footer.map((item) => {
      let itemChild;
      if (isVNode(item)) {
        itemChild = item;
      } else {
        const _a = item, {
          text
        } = _a, rest = __objRest$g(_a, [
          "text"
        ]);
        itemChild = createVNode(IxButton, rest, {
          default: () => [text]
        });
      }
      return itemChild ? createVNode("li", null, [itemChild]) : null;
    });
  }
  return createVNode("ul", {
    "class": `${prefixCls}-footer`
  }, [footerNode]);
};
var CardGrid = defineComponent({
  name: "IxCardGrid",
  props: cardGridProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-card-grid`);
    const {
      hoverable
    } = inject(cardToken);
    const classes = computed(() => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-hoverable`]: (_a = props.hoverable) != null ? _a : hoverable.value
      });
    });
    return () => createVNode(IxCol, {
      "class": classes.value
    }, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    });
  }
});
const IxCard = Card;
const IxCardGrid = CardGrid;

const useAutoplay = (autoplayTime, next) => {
  let timer = null;
  watch(autoplayTime, (newVal) => {
    timer && window.clearInterval(timer);
    if (newVal) {
      timer = window.setInterval(() => {
        next();
      }, newVal);
    }
  }, { immediate: true });
  onBeforeUnmount(() => {
    if (timer !== null) {
      window.clearInterval(timer);
    }
  });
};
const useWalk = (length, props) => {
  const [activeIndex, setActiveIndex] = useState$1(1);
  let running = false;
  watch(activeIndex, (newVal, oldVal) => {
    if (newVal >= 1 && newVal <= length.value) {
      callEmit(props.onChange, oldVal, newVal);
    }
  });
  const goTo = (slideIndex) => {
    running = true;
    if (activeIndex.value === 1 && slideIndex === length.value - 1) {
      setActiveIndex(0);
    } else if (activeIndex.value === length.value && slideIndex === 0) {
      setActiveIndex(length.value + 1);
    } else {
      setActiveIndex(slideIndex + 1);
    }
  };
  const next = () => {
    if (length.value <= 1 || running) {
      return;
    }
    running = true;
    setActiveIndex(activeIndex.value + 1);
  };
  const prev = () => {
    if (length.value <= 1 || running) {
      return;
    }
    running = true;
    setActiveIndex(activeIndex.value - 1);
  };
  const onTransitionend = (e) => {
    running = false;
    if (activeIndex.value > 0 && activeIndex.value <= length.value) {
      return;
    }
    if (activeIndex.value === 0) {
      setActiveIndex(length.value);
    } else if (activeIndex.value === length.value + 1) {
      setActiveIndex(1);
    }
    nextTick(() => {
      const target = e.target;
      target.style.transition = "none";
      void target.clientWidth;
      target.style.transition = "";
    });
  };
  return {
    goTo,
    next,
    prev,
    onTransitionend,
    activeIndex
  };
};
const dotPlacement = ["top", "start", "bottom", "end", "none"];
const dotTrigger = ["click", "hover"];
const carouselProps = {
  autoplayTime: IxPropTypes.number,
  dotPlacement: IxPropTypes.oneOf(dotPlacement),
  showArrow: IxPropTypes.bool,
  trigger: IxPropTypes.oneOf(dotTrigger),
  onChange: IxPropTypes.emit()
};
var __defProp$o = Object.defineProperty;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var Carousel = defineComponent({
  name: "IxCarousel",
  props: carouselProps,
  setup(props, {
    slots,
    expose
  }) {
    const carouselRef = ref(null);
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-carousel`);
    const config = useGlobalConfig$1("carousel");
    const autoplayTime = computed(() => {
      var _a;
      return (_a = props.autoplayTime) != null ? _a : config.autoplayTime;
    });
    const dotPlacement2 = computed(() => {
      var _a;
      return (_a = props.dotPlacement) != null ? _a : config.dotPlacement;
    });
    const showArrow = computed(() => {
      var _a;
      return (_a = props.showArrow) != null ? _a : config.showArrow;
    });
    const trigger = computed(() => {
      var _a;
      return (_a = props.trigger) != null ? _a : config.trigger;
    });
    const children = computed(() => {
      var _a;
      return flattenNode((_a = slots.default) == null ? void 0 : _a.call(slots));
    });
    const length = computed(() => children.value.length);
    const vertical = computed(() => dotPlacement2.value === "start" || dotPlacement2.value === "end");
    const itemClass = computed(() => `${mergedPrefixCls.value}-slide-item`);
    const size = computed(() => {
      var _a, _b, _c;
      const carousel = carouselRef.value;
      return {
        width: (_a = carousel == null ? void 0 : carousel.offsetWidth) != null ? _a : 0,
        height: (_c = (_b = carousel == null ? void 0 : carousel.querySelector(`.${itemClass.value}`)) == null ? void 0 : _b.offsetHeight) != null ? _c : 0
      };
    });
    const total = computed(() => length.value + 2);
    const slidesStyle = computed(() => {
      const index = activeIndex.value % total.value;
      const offset = vertical.value ? {
        top: `-${size.value.height * index}px`
      } : {
        left: `-${size.value.width * index}px`
      };
      return __spreadValues$o({
        width: `${total.value * size.value.width}px`
      }, offset);
    });
    const slideItemStyle = computed(() => {
      return {
        width: `${size.value.width}px`,
        height: "100%"
      };
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-vertical`]: vertical.value,
        [`${prefixCls}-horizontal`]: !vertical.value
      });
    });
    const slidesClass = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-slides`]: true
      });
    });
    const dotClass = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-dot`]: true,
        [`${prefixCls}-dot-${dotPlacement2.value}`]: true
      });
    });
    const {
      goTo,
      next,
      prev,
      onTransitionend,
      activeIndex
    } = useWalk(length, props);
    expose({
      goTo,
      next,
      prev
    });
    useAutoplay(autoplayTime, next);
    const onClick = (slideIndex) => {
      if (trigger.value === "click") {
        goTo(slideIndex);
      }
    };
    const onMouseenter = (slideIndex) => {
      if (trigger.value === "hover") {
        goTo(slideIndex);
      }
    };
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const startVNode = cloneVNode(children.value[length.value - 1]);
      const endVNode = cloneVNode(children.value[0]);
      const slides = [startVNode, ...children.value, endVNode].map((slideItem) => createVNode("div", {
        "class": itemClass.value,
        "style": slideItemStyle.value
      }, [slideItem]));
      const prevArrow = slots.arrow ? slots.arrow({
        type: "prev"
      }) : createVNode(IxIcon, {
        "name": "left-circle"
      }, null);
      const nextArrow = slots.arrow ? slots.arrow({
        type: "next"
      }) : createVNode(IxIcon, {
        "name": "right-circle"
      }, null);
      const dots = Array.from({
        length: length.value
      }).map((_, index) => {
        const isActive = index + 1 === activeIndex.value;
        const itemClass2 = {
          [`${prefixCls}-dot-item`]: true,
          [`${prefixCls}-dot-item-active`]: isActive
        };
        const children2 = slots.dot ? slots.dot({
          index,
          isActive
        }) : createVNode("button", {
          "class": `${prefixCls}-dot-item-default`
        }, null);
        return createVNode("li", {
          "class": itemClass2,
          "onClick": () => onClick(index),
          "onMouseenter": () => onMouseenter(index)
        }, [children2]);
      });
      return createVNode("div", {
        "ref": carouselRef,
        "class": classes.value,
        "style": {
          height: `${size.value.height}px`
        }
      }, [createVNode("div", {
        "class": slidesClass.value,
        "style": slidesStyle.value,
        "onTransitionend": onTransitionend
      }, [slides]), showArrow.value && createVNode(Fragment, null, [createVNode("div", {
        "class": `${prefixCls}-arrow ${prefixCls}-arrow-prev`,
        "onClick": prev
      }, [prevArrow]), createVNode("div", {
        "class": `${prefixCls}-arrow ${prefixCls}-arrow-next`,
        "onClick": next
      }, [nextArrow])]), dotPlacement2.value !== "none" && createVNode("ul", {
        "class": dotClass.value
      }, [dots])]);
    };
  }
});
const IxCarousel = Carousel;

const checkboxGroupToken = Symbol("checkboxGroupToken");
const checkboxProps = {
  control: controlPropDef,
  checked: IxPropTypes.oneOfType([String, Number, Boolean]),
  autofocus: IxPropTypes.bool.def(false),
  buttoned: IxPropTypes.bool,
  disabled: IxPropTypes.bool,
  indeterminate: IxPropTypes.bool.def(false),
  label: IxPropTypes.string,
  trueValue: IxPropTypes.oneOfType([String, Number, Boolean]).def(true),
  falseValue: IxPropTypes.oneOfType([String, Number, Boolean]).def(false),
  value: IxPropTypes.any,
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  "onUpdate:checked": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit()
};
const checkboxGroupProps = {
  control: controlPropDef,
  value: IxPropTypes.array(),
  buttoned: IxPropTypes.bool.def(false),
  dataSource: IxPropTypes.array(),
  disabled: IxPropTypes.bool.def(false),
  gap: IxPropTypes.oneOfType([Number, String]),
  name: IxPropTypes.string,
  options: IxPropTypes.array(),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]).def("md"),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
};
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __objRest$f = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$r.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$r.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Checkbox$1 = defineComponent({
  name: "IxCheckbox",
  inheritAttrs: false,
  props: checkboxProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-checkbox`);
    const config = useGlobalConfig$1("checkbox");
    const {
      elementRef,
      focus,
      blur
    } = useFormElement();
    expose({
      focus,
      blur
    });
    const formContext = inject(FORM_TOKEN, null);
    const checkboxGroup = inject(checkboxGroupToken, null);
    const mergedName = computed(() => {
      var _a;
      return (_a = attrs.name) != null ? _a : checkboxGroup == null ? void 0 : checkboxGroup.props.name;
    });
    const isButtoned = computed(() => {
      var _a, _b;
      return (_b = (_a = props.buttoned) != null ? _a : checkboxGroup == null ? void 0 : checkboxGroup.props.buttoned) != null ? _b : false;
    });
    const size = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = props.size) != null ? _a : checkboxGroup == null ? void 0 : checkboxGroup.props.size) != null ? _b : formContext == null ? void 0 : formContext.size.value) != null ? _c : config.size;
    });
    const {
      isChecked,
      isDisabled,
      isFocused,
      handleChange,
      handleBlur,
      handleFocus
    } = useCheckbox(props, checkboxGroup);
    const classes = computed(() => {
      const {
        indeterminate
      } = props;
      const buttoned = isButtoned.value;
      const prefixCls = mergedPrefixCls.value;
      const classes2 = {
        [prefixCls]: true,
        [`${prefixCls}-button`]: buttoned,
        [`${prefixCls}-checked`]: !indeterminate && isChecked.value,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-indeterminate`]: indeterminate,
        [`${prefixCls}-${size.value}`]: buttoned
      };
      return normalizeClass([classes2, attrs.class]);
    });
    return () => {
      const {
        autofocus,
        value,
        label
      } = props;
      const _a = attrs, {
        class: className,
        style,
        type,
        tabindex
      } = _a, restAttrs = __objRest$f(_a, [
        "class",
        "style",
        "type",
        "tabindex"
      ]);
      const prefixCls = mergedPrefixCls.value;
      const labelNode = covertStringVNode(slots.default, label);
      return createVNode("label", {
        "class": classes.value,
        "style": style,
        "role": "checkbox",
        "aria-checked": isChecked.value,
        "aria-disabled": isDisabled.value
      }, [createVNode("span", {
        "class": `${prefixCls}-input`
      }, [createVNode("input", mergeProps({
        "ref": elementRef,
        "type": "checkbox",
        "class": `${prefixCls}-input-inner`,
        "aria-hidden": true
      }, restAttrs, {
        "autofocus": autofocus,
        "name": mergedName.value,
        "value": value,
        "checked": isChecked.value,
        "disabled": isDisabled.value,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), null), !isButtoned.value && createVNode("span", {
        "class": `${prefixCls}-input-box`,
        "tabindex": tabindex
      }, null)]), labelNode && createVNode("span", {
        "class": `${prefixCls}-label`
      }, [labelNode]), isButtoned.value && createVNode("span", {
        "class": `${prefixCls}-button-tick`,
        "tabindex": tabindex
      }, null)]);
    };
  }
});
const useCheckbox = (props, checkboxGroup) => {
  let isChecked;
  let isDisabled;
  let handleChange;
  let handleBlur;
  const isFocused = ref(false);
  const handleFocus = (evt) => {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  };
  if (checkboxGroup) {
    const {
      props: groupProps,
      accessor
    } = checkboxGroup;
    isChecked = computed(() => {
      var _a, _b;
      return ((_a = accessor.valueRef.value) != null ? _a : []).includes((_b = props.value) != null ? _b : props.trueValue);
    });
    isDisabled = computed(() => {
      var _a;
      return (_a = accessor.disabled.value) != null ? _a : !!props.disabled;
    });
    handleBlur = (evt) => {
      isFocused.value = false;
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    handleChange = (evt) => {
      var _a;
      const checked = evt.target.checked;
      const {
        trueValue,
        falseValue,
        value
      } = props;
      const checkValue = checked ? trueValue : falseValue;
      const oldValue = (_a = accessor.valueRef.value) != null ? _a : [];
      const newValue = [...oldValue];
      const checkValueIndex = newValue.indexOf(value);
      if (checkValueIndex === -1) {
        newValue.push(value);
      } else {
        newValue.splice(checkValueIndex, 1);
      }
      accessor.setValue(newValue);
      callEmit(props.onChange, checkValue, !checkValue);
      callEmit(groupProps.onChange, newValue, oldValue);
    };
  } else {
    const accessor = useFormAccessor("checked");
    isChecked = computed(() => accessor.valueRef.value === props.trueValue);
    isDisabled = computed(() => accessor.disabled.value);
    handleBlur = (evt) => {
      isFocused.value = false;
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    handleChange = (evt) => {
      const checked = evt.target.checked;
      const {
        trueValue,
        falseValue
      } = props;
      const newChecked = checked ? trueValue : falseValue;
      accessor.setValue(newChecked);
      callEmit(props.onChange, newChecked, !newChecked);
    };
  }
  return {
    isChecked,
    isDisabled,
    isFocused,
    handleChange,
    handleBlur,
    handleFocus
  };
};
var CheckboxGroup = defineComponent({
  name: "IxCheckboxGroup",
  props: checkboxGroupProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-checkbox-group`);
    const accessor = useFormAccessor();
    provide(checkboxGroupToken, {
      props,
      accessor
    });
    const classes = computed(() => {
      const {
        gap
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-with-gap`]: gap != null
      });
    });
    const style = computed(() => {
      const {
        gap
      } = props;
      return gap != null ? `gap: ${convertCssPixel(gap)};` : void 0;
    });
    return () => {
      var _a;
      const {
        options,
        dataSource
      } = props;
      if (options) {
        Logger.warn("components/checkbox", "`options` was deprecated, please use `dataSource` instead");
      }
      const data = options != null ? options : dataSource;
      const children = data ? data.map((item) => createVNode(Checkbox$1, item, null)) : (_a = slots.default) == null ? void 0 : _a.call(slots);
      return createVNode("div", {
        "class": classes.value,
        "style": style.value
      }, [children]);
    };
  }
});
const IxCheckbox = Checkbox$1;
const IxCheckboxGroup = CheckboxGroup;

const collapseTransitionProps = {
  appear: IxPropTypes.bool.def(false),
  name: IxPropTypes.string,
  mode: IxPropTypes.oneOf(["height", "width"]).def("height"),
  onAfterEnter: IxPropTypes.emit(),
  onAfterLeave: IxPropTypes.emit()
};
var CollapseTransition = defineComponent({
  props: collapseTransitionProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-collapse-transition`);
    const onBeforeEnter = (el) => {
      const mode = props.mode;
      el.style[mode] = `0px`;
      el.style.opacity = "0";
    };
    const onEnter = (el) => {
      const mode = props.mode;
      el.style[mode] = `${mode === "width" ? el.scrollWidth : el.scrollHeight}px`;
      el.style.opacity = "1";
    };
    const onAfterEnter = (el) => {
      const mode = props.mode;
      el.style[mode] = "";
      el.style.opacity = "";
      callEmit(props.onAfterEnter);
    };
    const onBeforeLeave = (el) => {
      const mode = props.mode;
      el.style[mode] = `${mode === "width" ? el.offsetWidth : el.offsetHeight}px`;
    };
    const onLeave = (el) => {
      const mode = props.mode;
      el.style[mode] = `0px`;
      el.style.opacity = "0";
    };
    const onAfterLeave = (el) => {
      const mode = props.mode;
      el.style[mode] = "";
      el.style.opacity = "";
      callEmit(props.onAfterLeave);
    };
    return () => {
      const {
        appear,
        name = mergedPrefixCls.value
      } = props;
      return createVNode(Transition, {
        "appear": appear,
        "name": name,
        "onBeforeEnter": onBeforeEnter,
        "onEnter": onEnter,
        "onAfterEnter": onAfterEnter,
        "onBeforeLeave": onBeforeLeave,
        "onLeave": onLeave,
        "onAfterLeave": onAfterLeave
      }, {
        default: () => [slots.default()]
      });
    };
  }
});
const \u0275CollapseTransition = CollapseTransition;

const collapseToken = Symbol("collapseToken");
const collapseProps = {
  expandedKeys: IxPropTypes.array(),
  accordion: IxPropTypes.bool,
  borderless: IxPropTypes.bool,
  expandIcon: IxPropTypes.string,
  ghost: IxPropTypes.bool,
  "onUpdate:expandedKeys": IxPropTypes.emit()
};
const collapsePanelProps = {
  disabled: IxPropTypes.bool.def(false),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()])
};
var Collapse = defineComponent({
  name: "IxCollapse",
  props: collapseProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-collapse`);
    const config = useGlobalConfig$1("collapse");
    const accordion = computed(() => {
      var _a;
      return (_a = props.accordion) != null ? _a : config.accordion;
    });
    const borderless = computed(() => {
      var _a;
      return (_a = props.borderless) != null ? _a : config.borderless;
    });
    const expandIcon = computed(() => {
      var _a;
      return (_a = props.expandIcon) != null ? _a : config.expandIcon;
    });
    const ghost = computed(() => {
      var _a;
      return (_a = props.ghost) != null ? _a : config.ghost;
    });
    const [expandedKeys, setExpandedKeys] = useControlledProp(props, "expandedKeys", () => []);
    const handleExpand = (key) => {
      let tempKeys = [...expandedKeys.value];
      const index = tempKeys.indexOf(key);
      if (accordion.value) {
        tempKeys = index > -1 ? [] : [key];
      } else {
        index > -1 ? tempKeys.splice(index, 1) : tempKeys.push(key);
      }
      setExpandedKeys(tempKeys);
    };
    provide(collapseToken, {
      props,
      slots,
      expandedKeys,
      expandIcon,
      handleExpand
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-borderless`]: borderless.value,
        [`${prefixCls}-ghost`]: ghost.value
      });
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": classes.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var CollapsePanel = defineComponent({
  name: "IxCollapsePanel",
  props: collapsePanelProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-collapse-panel`);
    const {
      slots: collapseSlots,
      expandedKeys,
      expandIcon,
      handleExpand
    } = inject(collapseToken);
    const key = useKey();
    const isExpanded = computed(() => expandedKeys.value.includes(key));
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}`]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-expanded`]: isExpanded.value
      });
    });
    const handleClick = () => {
      if (props.disabled) {
        return;
      }
      handleExpand(key);
    };
    return () => {
      const expanded = isExpanded.value;
      const headerNode = renderHeader(props, slots, collapseSlots, key, expanded, expandIcon, handleClick);
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "class": classes.value
      }, [headerNode, createVNode(\u0275CollapseTransition, {
        "appear": true
      }, {
        default: () => {
          var _a;
          return [withDirectives(createVNode("div", {
            "class": `${prefixCls}-content`
          }, [createVNode("div", {
            "class": `${prefixCls}-content-box`
          }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]), [[vShow, expanded]])];
        }
      })]);
    };
  }
});
function renderHeader(props, slots, collapseSlots, key, expanded, expandIcon, handleClick) {
  if (slots.header) {
    return slots.header({
      expanded,
      onClick: handleClick
    });
  }
  let iconNode;
  if (collapseSlots.expandIcon) {
    const tempNode = collapseSlots.expandIcon({
      key,
      expanded
    });
    if (getFirstValidNode(tempNode)) {
      iconNode = tempNode;
    }
  } else {
    const iconName = expandIcon.value;
    iconNode = iconName ? createVNode(IxIcon, {
      "name": iconName,
      "rotate": expanded ? 90 : 0
    }, null) : void 0;
  }
  const headerSlots = iconNode ? {
    prefix: () => iconNode
  } : void 0;
  const {
    header,
    disabled
  } = props;
  const headerProps = isString(header) ? {
    title: header
  } : header;
  return createVNode(IxHeader, mergeProps({
    "disabled": disabled,
    "onClick": handleClick
  }, headerProps), headerSlots);
}
const IxCollapse = Collapse;
const IxCollapsePanel = CollapsePanel;

const monthTypes = ["date", "week"];
function useActiveDate(props, dateConfig, activeType) {
  var _a;
  const tempDate = shallowRef((_a = props.value) != null ? _a : dateConfig.now());
  const setActiveDate = (date) => {
    const type = monthTypes.includes(activeType.value) ? "month" : "year";
    if (!dateConfig.isSame(date, tempDate.value, type)) {
      tempDate.value = date;
    }
  };
  watch(() => props.value, (value) => value && setActiveDate(value));
  watch(() => props.visible, (visible) => visible && props.value && setActiveDate(props.value));
  const startActiveDate = computed(() => {
    const currDate = tempDate.value;
    const currType = activeType.value;
    const { startOf, set, get } = dateConfig;
    switch (currType) {
      case "date":
      case "week":
        return startOf(startOf(currDate, "month"), "week");
      case "month":
        return startOf(startOf(currDate, "year"), "month");
      case "quarter":
        return startOf(startOf(currDate, "year"), "quarter");
      case "year": {
        return set(currDate, parseInt(`${get(currDate, "year") / 10}`, 10) * 10 - 1, "year");
      }
      default:
        return currDate;
    }
  });
  return {
    activeDate: computed(() => tempDate.value),
    setActiveDate,
    startActiveDate
  };
}
function useActiveType(props) {
  const [activeType, setActiveType] = useState$1(props.type);
  watch(() => props.type, setActiveType);
  watch(() => props.visible, (visible) => visible && setActiveType(props.type));
  return {
    activeType,
    setActiveType
  };
}
function useMaxIndex(activeType, dateConfig, activeDate) {
  const maxRowIndex = computed(() => {
    const currType = activeType.value;
    const { weekStartsOn, get, startOf, endOf } = dateConfig;
    switch (currType) {
      case "date":
      case "week": {
        const currDate = activeDate.value;
        const weekStarts = weekStartsOn();
        let startDay = get(startOf(currDate, "month"), "day");
        if (startDay > weekStarts) {
          startDay = startDay - weekStarts;
        } else if (startDay < weekStarts) {
          startDay = startDay - weekStarts + 7;
        } else {
          startDay = 0;
        }
        const endDate = get(endOf(currDate, "month"), "date");
        return startDay + endDate > 35 ? 6 : 5;
      }
      case "month":
        return 4;
      case "quarter":
        return 1;
      case "year":
        return 4;
      default:
        return 0;
    }
  });
  const maxCellIndex = computed(() => {
    const currType = activeType.value;
    switch (currType) {
      case "date":
      case "week":
        return 7;
      case "month":
        return 3;
      case "quarter":
        return 4;
      case "year":
        return 3;
      default:
        return 0;
    }
  });
  return {
    maxRowIndex,
    maxCellIndex
  };
}
const datePanelToken = Symbol("datePanelToken");
const datePanelProps = {
  disabledDate: IxPropTypes.func(),
  type: IxPropTypes.oneOf(["date", "week", "month", "quarter", "year"]).def("date"),
  value: IxPropTypes.object(),
  visible: IxPropTypes.bool,
  onCellClick: IxPropTypes.emit(),
  onCellMouseenter: IxPropTypes.emit()
};
const panelRowProps = {
  rowIndex: IxPropTypes.number.isRequired
};
const panelCellProps = {
  rowIndex: IxPropTypes.number.isRequired,
  cellIndex: IxPropTypes.number.isRequired,
  isWeek: IxPropTypes.bool
};
const dayTypes = ["date", "week"];
const labelFormat = {
  date: "d",
  week: "d",
  month: "MMM",
  quarter: "'Q'Q",
  year: "yyyy"
};
var PanelCell$1 = defineComponent({
  props: panelCellProps,
  setup(props) {
    const {
      props: panelProps,
      slots,
      mergedPrefixCls,
      dateConfig,
      activeDate,
      setActiveDate,
      startActiveDate,
      activeType,
      setActiveType,
      maxRowIndex,
      maxCellIndex
    } = inject(datePanelToken);
    const offsetIndex = computed(() => props.rowIndex * maxCellIndex.value + props.cellIndex);
    const cellDate = computed(() => {
      const currType = activeType.value;
      const offsetUnit = dayTypes.includes(currType) ? "day" : currType;
      return dateConfig.add(startActiveDate.value, offsetIndex.value, offsetUnit);
    });
    const isDisabled = computed(() => {
      var _a;
      return (_a = panelProps.disabledDate) == null ? void 0 : _a.call(panelProps, cellDate.value);
    });
    const isSelected = computed(() => {
      const currValue = panelProps.value;
      return currValue && dateConfig.isSame(currValue, cellDate.value, activeType.value);
    });
    const isToday = computed(() => dayTypes.includes(activeType.value) && dateConfig.isSame(cellDate.value, dateConfig.now(), "day"));
    const outView = computed(() => {
      const currType = activeType.value;
      if (dayTypes.includes(activeType.value)) {
        return !dateConfig.isSame(cellDate.value, activeDate.value, "month");
      }
      if (currType === "year") {
        const offset = offsetIndex.value;
        return offset === 0 || offset === maxRowIndex.value * maxCellIndex.value;
      }
      return false;
    });
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-cell`;
      if (props.isWeek) {
        return normalizeClass({
          [prefixCls]: true,
          [`${prefixCls}-selected`]: isSelected.value,
          [`${prefixCls}-week-number`]: true
        });
      }
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-selected`]: isSelected.value,
        [`${prefixCls}-today`]: isToday.value,
        [`${prefixCls}-out-view`]: outView.value
      });
    });
    const handleClick = (evt) => {
      evt.stopPropagation();
      const currDate = cellDate.value;
      if (panelProps.type !== activeType.value) {
        setActiveType(panelProps.type);
        setActiveDate(currDate);
      } else {
        callEmit(panelProps.onCellClick, currDate);
      }
    };
    const handleMouseenter = () => {
      callEmit(panelProps.onCellMouseenter, cellDate.value);
    };
    return () => {
      var _a, _b;
      const currDate = cellDate.value;
      const {
        format
      } = dateConfig;
      if (props.isWeek) {
        return createVNode("td", {
          "class": classes.value,
          "role": "gridcell"
        }, [format(currDate, "ww")]);
      }
      const cellNode = (_b = (_a = slots.cell) == null ? void 0 : _a.call(slots, {
        date: currDate
      })) != null ? _b : createVNode("div", {
        "class": `${mergedPrefixCls.value}-cell-inner`
      }, [format(currDate, labelFormat[activeType.value])]);
      return createVNode("td", {
        "class": classes.value,
        "role": "gridcell",
        "onClick": isDisabled.value ? void 0 : handleClick,
        "onMouseenter": isDisabled.value ? void 0 : handleMouseenter
      }, [cellNode]);
    };
  }
});
var PanelRow = defineComponent({
  props: panelRowProps,
  setup(props) {
    const {
      mergedPrefixCls,
      activeType,
      maxCellIndex
    } = inject(datePanelToken);
    const cells = computed(() => {
      const {
        rowIndex
      } = props;
      const currType = activeType.value;
      const isWeek = currType === "week";
      const cells2 = isWeek ? [{
        key: `${currType}-${-1}`,
        rowIndex,
        cellIndex: 0,
        isWeek
      }] : [];
      const maxIndex = maxCellIndex.value;
      for (let cellIndex = 0; cellIndex < maxIndex; cellIndex++) {
        cells2.push({
          key: `${currType}-${cellIndex}`,
          rowIndex,
          cellIndex
        });
      }
      return cells2;
    });
    return () => {
      const children = cells.value.map((cell) => createVNode(PanelCell$1, cell, null));
      return createVNode("tr", {
        "role": "row",
        "class": `${mergedPrefixCls.value}-row`
      }, [children]);
    };
  }
});
var PanelBody = defineComponent({
  setup() {
    const {
      mergedPrefixCls,
      dateConfig,
      activeType,
      maxRowIndex,
      maxCellIndex
    } = inject(datePanelToken);
    const theadCells = useTheadCells(dateConfig, activeType, maxCellIndex);
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-body`;
      const thNodes = theadCells.value.map((cell) => {
        const {
          key,
          label
        } = cell;
        return createVNode("th", {
          "role": "columnheader",
          "key": key
        }, [label]);
      });
      const maxIndex = maxRowIndex.value;
      const rows = [];
      for (let rowIndex = 0; rowIndex < maxIndex; rowIndex++) {
        rows.push(createVNode(PanelRow, {
          "key": rowIndex,
          "rowIndex": rowIndex
        }, null));
      }
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("table", {
        "role": "grid"
      }, [thNodes.length > 0 && createVNode("thead", null, [createVNode("tr", {
        "role": "row"
      }, [thNodes])]), createVNode("tbody", null, [rows])])]);
    };
  }
});
function useTheadCells(dateConfig, activeType, maxCellIndex) {
  return computed(() => {
    const currType = activeType.value;
    const isWeek = currType === "week";
    const cols = isWeek ? [{
      key: -1
    }] : [];
    if (currType === "date" || isWeek) {
      const maxIndex = maxCellIndex.value;
      const labels = dateConfig.getLocalizedLabels("day", maxIndex, "narrow");
      const weekStarts = dateConfig.weekStartsOn();
      for (let colIndex = 0; colIndex < maxIndex; colIndex++) {
        cols.push({
          key: colIndex,
          label: labels[(colIndex + weekStarts) % maxIndex]
        });
      }
    }
    return cols;
  });
}
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __objRest$e = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const hidePrevNextTypes = ["month", "quarter", "year"];
var PanelHeader = defineComponent({
  setup() {
    const {
      locale,
      mergedPrefixCls,
      dateConfig,
      activeDate,
      setActiveDate,
      activeType,
      setActiveType
    } = inject(datePanelToken);
    const contents = useContents(activeType, activeDate, locale, dateConfig, setActiveType);
    const handleSuperPrevClick = () => {
      const offsetYear = activeType.value === "year" ? -10 : -1;
      setActiveDate(dateConfig.add(activeDate.value, offsetYear, "year"));
    };
    const handlePrevClick = () => {
      setActiveDate(dateConfig.add(activeDate.value, -1, "month"));
    };
    const handleSuperNextClick = () => {
      const offsetYear = activeType.value === "year" ? 10 : 1;
      setActiveDate(dateConfig.add(activeDate.value, offsetYear, "year"));
    };
    const handleNextClick = () => {
      setActiveDate(dateConfig.add(activeDate.value, 1, "month"));
    };
    return () => {
      const {
        previousDecade,
        previousYear,
        previousMonth,
        nextDecade,
        nextYear,
        nextMonth
      } = locale.value;
      const currType = activeType.value;
      const prev = !hidePrevNextTypes.includes(activeType.value);
      const next = !hidePrevNextTypes.includes(activeType.value);
      const contentNodes = contents.value.map((item) => {
        const _a = item, {
          label
        } = _a, rest = __objRest$e(_a, [
          "label"
        ]);
        return createVNode("button", mergeProps({
          "type": "button",
          "tabindex": "-1"
        }, rest), [label]);
      });
      const prefixCls = `${mergedPrefixCls.value}-header`;
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("button", {
        "class": `${prefixCls}-super-prev${" visible"}`,
        "type": "button",
        "tabindex": "-1",
        "title": currType === "year" ? previousDecade : previousYear,
        "onClick": handleSuperPrevClick
      }, [createVNode(IxIcon, {
        "name": "double-left"
      }, null)]), createVNode("button", {
        "class": `${prefixCls}-prev${prev ? " visible" : ""}`,
        "type": "button",
        "tabindex": "-1",
        "title": previousMonth,
        "onClick": handlePrevClick
      }, [createVNode(IxIcon, {
        "name": "left"
      }, null)]), createVNode("div", {
        "class": `${prefixCls}-content`
      }, [contentNodes]), createVNode("button", {
        "class": `${prefixCls}-super-next${next ? " visible" : ""}`,
        "type": "button",
        "tabindex": "-1",
        "title": nextMonth,
        "onClick": handleNextClick
      }, [createVNode(IxIcon, {
        "name": "right"
      }, null)]), createVNode("button", {
        "class": `${prefixCls}-super-prev${" visible"}`,
        "type": "button",
        "tabindex": "-1",
        "title": currType === "year" ? nextDecade : nextYear,
        "onClick": handleSuperNextClick
      }, [createVNode(IxIcon, {
        "name": "double-right"
      }, null)])]);
    };
  }
});
function useContents(activeType, activeDate, locale, dateConfig, setActiveType) {
  const handleClick = (evt, type) => {
    evt.stopPropagation();
    setActiveType(type);
  };
  return computed(() => {
    const currType = activeType.value;
    const currDate = activeDate.value;
    const {
      yearSelect,
      monthSelect,
      yearFormat,
      monthFormat
    } = locale.value;
    const {
      format,
      get
    } = dateConfig;
    switch (currType) {
      case "date":
      case "week":
        return [{
          key: "year",
          title: yearSelect,
          onClick: (evt) => handleClick(evt, "year"),
          label: format(currDate, yearFormat)
        }, {
          key: "month",
          title: monthSelect,
          onClick: (evt) => handleClick(evt, "month"),
          label: format(currDate, monthFormat)
        }];
      case "month":
      case "quarter":
        return [{
          key: "year",
          title: yearSelect,
          onClick: (evt) => handleClick(evt, "year"),
          label: format(currDate, yearFormat)
        }];
      case "year": {
        const startYear = parseInt(`${get(currDate, "year") / 10}`, 10) * 10;
        const endYear = startYear + 9;
        return [{
          key: "decade",
          label: `${startYear}-${endYear}`
        }];
      }
      default:
        return [];
    }
  });
}
var DatePanel = defineComponent({
  props: datePanelProps,
  setup(props, {
    slots
  }) {
    const locale = getLocale("datePicker");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-date-panel`);
    const dateConfig = useDateConfig();
    const {
      activeType,
      setActiveType
    } = useActiveType(props);
    const {
      activeDate,
      setActiveDate,
      startActiveDate
    } = useActiveDate(props, dateConfig, activeType);
    const {
      maxRowIndex,
      maxCellIndex
    } = useMaxIndex(activeType, dateConfig, activeDate);
    provide(datePanelToken, {
      props,
      slots,
      locale,
      mergedPrefixCls,
      dateConfig,
      activeType,
      setActiveType,
      activeDate,
      setActiveDate,
      startActiveDate,
      maxRowIndex,
      maxCellIndex
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "class": `${prefixCls} ${prefixCls}-${activeType.value}`
      }, [createVNode(PanelHeader, null, null), createVNode(PanelBody, null, null), slots.footer && createVNode("div", {
        "class": `${prefixCls}-footer`
      }, [slots.footer()])]);
    };
  }
});
const \u0275DatePanel = DatePanel;

const defaultFormat = {
  date: "yyyy-MM-dd",
  week: "RRRR-II",
  month: "yyyy-MM",
  quarter: "yyyy-'Q'Q",
  year: "yyyy"
};
function useFormat(props, config) {
  return computed(() => {
    let format = props.format;
    if (format) {
      return format;
    }
    const formatConfig = config.format;
    const type = props.type;
    if (formatConfig) {
      format = formatConfig[type];
    }
    return format != null ? format : defaultFormat[type];
  });
}
function useInputState$2(props, dateConfig, accessor, formatRef) {
  const initValue = accessor.valueRef.value;
  const formatText = formatRef.value;
  const initText = initValue ? dateConfig.format(dateConfig.convert(accessor.valueRef.value, formatText), formatText) : "";
  const [inputValue, setInputValue] = useState$1(initText);
  const [isFocused, setFocused] = useState$1(false);
  watch(accessor.valueRef, (value) => {
    if (!value) {
      setInputValue("");
      return;
    }
    const formatText2 = formatRef.value;
    const newValue = dateConfig.format(dateConfig.convert(value, formatText2), formatText2);
    if (newValue !== inputValue.value) {
      setInputValue(newValue);
    }
  });
  const handleInput = (evt) => {
    callEmit(props.onInput, evt);
    const { value } = evt.target;
    if (!value) {
      return;
    }
    const formatText2 = formatRef.value;
    const { parse, isValid, format } = dateConfig;
    const currDate = parse(value, formatText2);
    if (!isValid(currDate) || format(currDate, formatText2) != value) {
      return;
    }
    const oldDate = toRaw(accessor.valueRef.value);
    accessor.setValue(currDate);
    callEmit(props.onChange, currDate, oldDate);
  };
  const handleFocus = (evt) => {
    callEmit(props.onFocus, evt);
    setFocused(true);
  };
  const handleBlur = (evt) => {
    callEmit(props.onBlur, evt);
    accessor.markAsBlurred();
    setFocused(false);
  };
  const handleClear = (evt) => {
    callEmit(props.onClear, evt);
    evt.stopPropagation();
    accessor.setValue(void 0);
  };
  return {
    inputValue,
    isFocused,
    handleInput,
    handleFocus,
    handleBlur,
    handleClear
  };
}
function useOverlayState(props) {
  const [overlayOpened, setOverlayOpened] = useControlledProp(props, "open", false);
  onMounted(() => {
    if (props.autofocus) {
      setOverlayOpened(true);
    }
  });
  return { overlayOpened, setOverlayOpened };
}
function usePanelState(props, dateConfig, accessor, formatRef) {
  var _a;
  const initValue = (_a = accessor.valueRef.value) != null ? _a : props.defaultOpenValue;
  const initDate = initValue ? dateConfig.convert(accessor.valueRef.value, formatRef.value) : void 0;
  const [panelDate, setPanelDate] = useState$1(initDate);
  watch(accessor.valueRef, (value) => {
    const { convert, isSame } = dateConfig;
    const mergedValue = value != null ? value : props.defaultOpenValue;
    if (!mergedValue) {
      setPanelDate(void 0);
    }
    const currValue = convert(mergedValue, formatRef.value);
    if (!panelDate.value || !isSame(panelDate.value, currValue, props.type)) {
      setPanelDate(currValue);
    }
  });
  return {
    panelDate,
    setPanelDate
  };
}
const datePickerToken = Symbol("datePickerToken");
var Content$3 = defineComponent({
  setup() {
    const {
      props,
      slots,
      overlayOpened,
      panelDate,
      handlePanelCellClick
    } = inject(datePickerToken);
    return () => {
      const {
        overlayRender
      } = props;
      const children = createVNode(\u0275DatePanel, {
        "disabledDate": props.disabledDate,
        "type": props.type,
        "value": panelDate.value,
        "visible": overlayOpened.value,
        "onCellClick": handlePanelCellClick
      }, slots);
      return overlayRender ? overlayRender([children]) : createVNode("div", null, [children]);
    };
  }
});
var Trigger$3 = defineComponent({
  setup() {
    const {
      props,
      slots,
      locale,
      config,
      mergedPrefixCls,
      accessor,
      format,
      focusMonitor,
      inputRef,
      inputValue,
      isFocused,
      handleFocus,
      handleBlur,
      handleInput,
      handleClear,
      overlayOpened,
      setOverlayOpened
    } = inject(datePickerToken);
    const formContext = inject(FORM_TOKEN, null);
    const placeholder = computed(() => {
      var _a;
      return (_a = props.placeholder) != null ? _a : locale.value[`${props.type}Placeholder`];
    });
    const inputSize = computed(() => Math.max(10, format.value.length) + 2);
    const allowInput = computed(() => {
      var _a;
      return (_a = props.allowInput) != null ? _a : config.allowInput;
    });
    const clearable = computed(() => !accessor.disabled.value && props.clearable && inputValue.value.length > 0);
    const suffix = computed(() => {
      var _a;
      return (_a = props.suffix) != null ? _a : config.suffix;
    });
    const classes = computed(() => {
      var _a;
      const {
        borderless = config.borderless,
        size = (_a = formContext == null ? void 0 : formContext.size.value) != null ? _a : config.size
      } = props;
      const disabled = accessor.disabled.value;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-borderless`]: borderless,
        [`${prefixCls}-clearable`]: clearable.value,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-opened`]: overlayOpened.value,
        [`${prefixCls}-with-suffix`]: slots.suffix || suffix.value,
        [`${prefixCls}-${size}`]: true
      });
    });
    const handleClick = () => {
      const currOpened = overlayOpened.value;
      if (currOpened || accessor.disabled.value) {
        return;
      }
      setOverlayOpened(!currOpened);
    };
    const handleKeyDown = (evt) => {
      switch (evt.code) {
        case "Enter":
          evt.preventDefault();
          break;
        case "Escape":
          evt.preventDefault();
          setOverlayOpened(false);
          break;
      }
    };
    const triggerRef = ref();
    onMounted(() => {
      watch(focusMonitor.monitor(triggerRef.value, true), (evt) => {
        const {
          origin,
          event
        } = evt;
        if (event) {
          if (origin) {
            handleFocus(event);
          } else {
            handleBlur(event);
          }
        }
      });
    });
    onBeforeUnmount(() => focusMonitor.stopMonitoring(triggerRef.value));
    return () => {
      const {
        readonly
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("div", {
        "ref": triggerRef,
        "class": classes.value,
        "onClick": handleClick,
        "onKeydown": handleKeyDown
      }, [createVNode("div", {
        "class": `${prefixCls}-input`
      }, [createVNode("input", {
        "ref": inputRef,
        "class": `${prefixCls}-input-inner`,
        "autocomplete": "off",
        "disabled": accessor.disabled.value,
        "placeholder": placeholder.value,
        "readonly": readonly || allowInput.value !== true,
        "size": inputSize.value,
        "value": inputValue.value,
        "onInput": handleInput
      }, null), createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [createVNode(IxIcon, {
        "name": suffix.value
      }, null)]), clearable.value && createVNode("span", {
        "class": `${prefixCls}-clear`,
        "onClick": handleClear
      }, [createVNode(IxIcon, {
        "name": "close-circle"
      }, null)])])]);
    };
  }
});
var __defProp$1$a = Object.defineProperty;
var __defProps$1$4 = Object.defineProperties;
var __getOwnPropDescs$1$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$d = Object.getOwnPropertySymbols;
var __hasOwnProp$1$d = Object.prototype.hasOwnProperty;
var __propIsEnum$1$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$a = (obj, key, value) => key in obj ? __defProp$1$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$d.call(b, prop))
      __defNormalProp$1$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$d)
    for (var prop of __getOwnPropSymbols$1$d(b)) {
      if (__propIsEnum$1$d.call(b, prop))
        __defNormalProp$1$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$4 = (a, b) => __defProps$1$4(a, __getOwnPropDescs$1$4(b));
const datePickerCommonProps = {
  control: controlPropDef,
  open: IxPropTypes.bool,
  allowInput: IxPropTypes.oneOfType([Boolean, IxPropTypes.oneOf(["overlay"])]),
  autofocus: IxPropTypes.bool.def(false),
  borderless: IxPropTypes.bool,
  clearable: IxPropTypes.bool,
  clearIcon: IxPropTypes.string,
  disabled: IxPropTypes.bool.def(false),
  disabledDate: IxPropTypes.func(),
  format: IxPropTypes.string,
  overlayClassName: IxPropTypes.string,
  overlayContainer: IxPropTypes.oneOfType([String, HTMLElement, IxPropTypes.func()]),
  overlayRender: IxPropTypes.func(),
  readonly: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  target: portalTargetDef,
  type: IxPropTypes.oneOf(["date", "week", "month", "quarter", "year"]).def("date"),
  "onUpdate:open": IxPropTypes.emit(),
  onClear: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
};
const datePickerProps = __spreadProps$1$4(__spreadValues$1$a({}, datePickerCommonProps), {
  value: IxPropTypes.oneOfType([Number, String, Date]),
  defaultOpenValue: IxPropTypes.oneOfType([Number, String, Date]),
  placeholder: IxPropTypes.string,
  timePicker: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onInput: IxPropTypes.emit()
});
__spreadProps$1$4(__spreadValues$1$a({}, datePickerCommonProps), {
  value: IxPropTypes.array(),
  defaultOpenValue: IxPropTypes.array(),
  placeholder: IxPropTypes.arrayOf(String),
  separator: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  timePicker: IxPropTypes.oneOfType([
    Boolean,
    IxPropTypes.object(),
    IxPropTypes.array()
  ]),
  "onUpdate:value": IxPropTypes.emit()
});
({
  rowIndex: IxPropTypes.number.isRequired
});
({
  rowIndex: IxPropTypes.number.isRequired,
  cellIndex: IxPropTypes.number.isRequired,
  isWeek: IxPropTypes.bool
});
var __defProp$n = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$h = (a, b) => __defProps$h(a, __getOwnPropDescs$h(b));
const defaultOffset$3 = [0, 8];
var DatePicker = defineComponent({
  name: "IxDatePicker",
  inheritAttrs: false,
  props: datePickerProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const locale = getLocale("datePicker");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-date-picker`);
    const config = useGlobalConfig$1("datePicker");
    const dateConfig = useDateConfig();
    const focusMonitor = useSharedFocusMonitor();
    const {
      elementRef: inputRef,
      focus,
      blur
    } = useFormElement();
    expose({
      focus,
      blur
    });
    const {
      overlayOpened,
      setOverlayOpened
    } = useOverlayState(props);
    const accessor = useFormAccessor();
    const format = useFormat(props, config);
    const inputStateContext = useInputState$2(props, dateConfig, accessor, format);
    const {
      inputValue
    } = inputStateContext;
    const {
      panelDate,
      setPanelDate
    } = usePanelState(props, dateConfig, accessor, format);
    const handlePanelCellClick = (date) => {
      const oldDate = toRaw(accessor.valueRef.value);
      if (!oldDate || !dateConfig.isSame(date, dateConfig.convert(oldDate, format.value), props.type)) {
        setOverlayOpened(false);
        accessor.setValue(date);
        callEmit(props.onChange, date, oldDate);
      }
    };
    provide(datePickerToken, __spreadProps$h(__spreadValues$n({
      props,
      slots,
      locale,
      config,
      mergedPrefixCls,
      dateConfig,
      focusMonitor,
      inputRef,
      overlayOpened,
      setOverlayOpened,
      accessor,
      format
    }, inputStateContext), {
      panelDate,
      setPanelDate,
      handlePanelCellClick
    }));
    watch(overlayOpened, (opened) => {
      if (!opened && inputValue.value)
        ;
      opened ? focus() : blur();
    });
    const classes = computed(() => {
      const {
        overlayClassName
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-overlay`]: true,
        [overlayClassName || ""]: !!overlayClassName
      });
    });
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-overlay-container`;
    });
    return () => {
      const renderTrigger = () => createVNode(Trigger$3, attrs, null);
      const renderContent = () => createVNode(Content$3, null, null);
      const overlayProps = {
        "onUpdate:visible": setOverlayOpened
      };
      return createVNode(\u0275Overlay, mergeProps(overlayProps, {
        "visible": overlayOpened.value,
        "class": classes.value,
        "clickOutside": true,
        "disabled": accessor.disabled.value || props.readonly,
        "offset": defaultOffset$3,
        "placement": "bottomStart",
        "target": target.value,
        "trigger": "manual"
      }), {
        default: renderTrigger,
        content: renderContent
      });
    };
  }
});
const IxDatePicker = DatePicker;

const dividerProps = {
  dashed: IxPropTypes.bool,
  label: IxPropTypes.string,
  labelPlacement: IxPropTypes.oneOf(["start", "center", "end"]),
  plain: IxPropTypes.bool,
  position: IxPropTypes.oneOf(["left", "center", "right"]),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  type: IxPropTypes.oneOf(["horizontal", "vertical"]),
  vertical: IxPropTypes.bool
};
var Divider = defineComponent({
  name: "IxDivider",
  props: dividerProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-divider`);
    const config = useGlobalConfig$1("divider");
    const classes = computed(() => {
      const {
        dashed = config.dashed,
        label,
        labelPlacement = config.labelPlacement,
        plain = config.plain,
        position,
        size = config.size,
        type,
        vertical
      } = props;
      process.env.NODE_ENV !== "production" && position && Logger.warn("components/divider", "`position` was deprecated, please use `labelPlacement` instead");
      process.env.NODE_ENV !== "production" && type && Logger.warn("components/divider", "`type` was deprecated, please use `vertical` instead");
      const withLabel = !!label || !!slots.default;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}`]: true,
        [`${prefixCls}-${size}`]: true,
        [`${prefixCls}-dashed`]: dashed,
        [`${prefixCls}-horizontal`]: !(type === "vertical" || vertical),
        [`${prefixCls}-vertical`]: type === "vertical" || vertical,
        [`${prefixCls}-plain`]: withLabel && plain,
        [`${prefixCls}-with-label`]: withLabel,
        [`${prefixCls}-with-label-${position || labelPlacement}`]: withLabel
      });
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const labelNode = covertStringVNode(slots.default, props.label);
      return createVNode("div", {
        "class": classes.value
      }, [labelNode && createVNode("span", {
        "class": `${prefixCls}-label`
      }, [labelNode])]);
    };
  }
});
const IxDivider = Divider;

const maskProps = {
  mask: IxPropTypes.bool.def(true),
  transitionName: IxPropTypes.string.def("ix-fade"),
  visible: IxPropTypes.bool.def(true),
  zIndex: IxPropTypes.number
};
var Mask = defineComponent({
  props: maskProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-mask`);
    return () => {
      const {
        mask,
        transitionName,
        visible,
        zIndex
      } = props;
      if (!mask) {
        return null;
      }
      return createVNode(Transition, {
        "appear": true,
        "name": transitionName
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": mergedPrefixCls.value,
          "style": {
            zIndex
          }
        }, null), [[vShow, visible]])]
      });
    };
  }
});
const \u0275Mask = Mask;

const footerProps = {
  cancel: IxPropTypes.func(),
  cancelButton: IxPropTypes.object(),
  cancelLoading: IxPropTypes.bool,
  cancelText: IxPropTypes.string,
  cancelVisible: IxPropTypes.bool.def(true),
  footer: IxPropTypes.oneOfType([Boolean, IxPropTypes.array(), IxPropTypes.vNode]),
  ok: IxPropTypes.func(),
  okButton: IxPropTypes.object(),
  okLoading: IxPropTypes.bool,
  okText: IxPropTypes.string
};
var __defProp$m = Object.defineProperty;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __objRest$d = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$o.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$o.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Footer = defineComponent({
  props: footerProps,
  setup(props, {
    slots
  }) {
    const cancelButtonProps = computed(() => {
      const {
        cancel,
        cancelButton,
        cancelVisible,
        cancelLoading,
        cancelText
      } = props;
      if (!cancelVisible || !cancel && !cancelText && !cancelButton) {
        return void 0;
      }
      return __spreadValues$m({
        key: "__IDUX_FOOTER_BUTTON_CANCEL",
        text: cancelText,
        onClick: cancel,
        loading: cancelLoading
      }, cancelButton);
    });
    const okButtonProps = computed(() => {
      const {
        ok,
        okButton,
        okLoading,
        okText
      } = props;
      if (!ok && !okText && !okButton) {
        return void 0;
      }
      return __spreadValues$m({
        key: "__IDUX_FOOTER_BUTTON_OK",
        text: okText,
        onClick: ok,
        loading: okLoading,
        mode: cancelButtonProps.value ? "primary" : "default"
      }, okButton);
    });
    return () => {
      const footerProp = props.footer;
      const footerSlot = slots.footer;
      if (!footerProp && !footerSlot) {
        return void 0;
      }
      let children;
      if (footerSlot) {
        children = footerSlot(props);
      } else if (isVNode(footerProp)) {
        children = footerProp;
      } else {
        let buttonProps = footerProp;
        if (!Array.isArray(buttonProps)) {
          const cancelButton = cancelButtonProps.value;
          const okButton = okButtonProps.value;
          buttonProps = [];
          okButton && buttonProps.push(okButton);
          cancelButton && buttonProps.push(cancelButton);
        }
        children = buttonProps.map((item) => {
          const _a = item, {
            text
          } = _a, rest = __objRest$d(_a, [
            "text"
          ]);
          return createVNode(IxButton, rest, {
            default: () => [text]
          });
        });
      }
      return createVNode("div", null, [children]);
    };
  }
});
const \u0275Footer = Footer;

const drawerToken = Symbol("drawerToken");
const drawerProviderToken = Symbol("drawerProviderToken");
const DRAWER_TOKEN = Symbol("DRAWER_TOKEN");
var __defProp$1$9 = Object.defineProperty;
var __getOwnPropSymbols$1$c = Object.getOwnPropertySymbols;
var __hasOwnProp$1$c = Object.prototype.hasOwnProperty;
var __propIsEnum$1$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$9 = (obj, key, value) => key in obj ? __defProp$1$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$c.call(b, prop))
      __defNormalProp$1$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$c)
    for (var prop of __getOwnPropSymbols$1$c(b)) {
      if (__propIsEnum$1$c.call(b, prop))
        __defNormalProp$1$9(a, prop, b[prop]);
    }
  return a;
};
const drawerTransitionMap = {
  top: "move-up",
  bottom: "move-down",
  start: "move-start",
  end: "move-end"
};
const horizontalPlacement = ["start", "end"];
const defaultDistance = 160;
var DrawerWrapper = defineComponent({
  inheritAttrs: false,
  setup(_, {
    attrs
  }) {
    const {
      props,
      slots,
      common,
      config,
      mergedPrefixCls,
      visible,
      animatedVisible,
      level,
      levelAction
    } = inject(drawerToken);
    const {
      close
    } = inject(DRAWER_TOKEN);
    const {
      closable,
      closeIcon,
      closeOnEsc,
      mask,
      maskClosable,
      zIndex
    } = useConfig$1(props, config);
    const transitionName = computed(() => `${common.prefixCls}-${drawerTransitionMap[props.placement]}`);
    const isHorizontal = computed(() => horizontalPlacement.includes(props.placement));
    const placementStyle = computed(() => {
      const {
        width,
        height,
        offset,
        placement
      } = props;
      const horizontal = isHorizontal.value;
      const offsetPixel = convertCssPixel(offset);
      let offsetObj;
      if (horizontal) {
        const transformPlacement = placement === "start" ? "left" : "right";
        offsetObj = {
          top: offsetPixel,
          [transformPlacement]: 0
        };
      } else {
        offsetObj = {
          left: offsetPixel,
          [placement]: 0
        };
      }
      return __spreadValues$1$9({
        width: convertCssPixel(width || (horizontal ? config.width : "100%")),
        height: convertCssPixel(height || (horizontal ? "100%" : config.height))
      }, offsetObj);
    });
    const transformStyle = computed(() => {
      const {
        placement
      } = props;
      const horizontal = isHorizontal.value;
      const distance = level.value * defaultDistance;
      let transform;
      if (horizontal) {
        transform = distance > 0 ? `translateX(${placement === "start" ? distance : -distance}px)` : void 0;
      } else {
        transform = distance > 0 ? `translateY(${placement === "top" ? distance : -distance}px)` : void 0;
      }
      return transform;
    });
    const wrapperClasses = computed(() => {
      const {
        wrapperClassName = ""
      } = props;
      const action = levelAction.value;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-wrapper`]: true,
        [`${prefixCls}-${props.placement}`]: true,
        [`${prefixCls}-opened`]: animatedVisible.value,
        [`${prefixCls}-${action}`]: !!action,
        [`${prefixCls}-with-mask`]: mask.value,
        [wrapperClassName]: !!wrapperClassName
      });
    });
    const wrapperStyle = computed(() => {
      const placement = mask.value ? void 0 : placementStyle.value;
      return __spreadValues$1$9({
        zIndex: zIndex.value,
        transform: transformStyle.value
      }, placement);
    });
    const contentStyle = computed(() => {
      return mask.value ? placementStyle.value : void 0;
    });
    const wrapperRef = ref();
    const sentinelStartRef = ref();
    const sentinelEndRef = ref();
    const {
      onWrapperClick,
      onWrapperKeydown,
      onContentMousedown,
      onContentMouseup
    } = useEvent$1(close, mask, maskClosable, closeOnEsc, sentinelStartRef, sentinelEndRef);
    const {
      onEnter,
      onAfterEnter,
      onAfterLeave
    } = useEvents$4(props, wrapperRef, animatedVisible);
    onMounted(() => {
      watchVisibleChange$1(props, wrapperRef, sentinelStartRef, mask);
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(Transition, {
        "name": transitionName.value,
        "appear": true,
        "onEnter": onEnter,
        "onAfterEnter": onAfterEnter,
        "onAfterLeave": onAfterLeave
      }, {
        default: () => [withDirectives(createVNode("div", {
          "ref": wrapperRef,
          "class": wrapperClasses.value,
          "style": wrapperStyle.value,
          "tabindex": -1,
          "onClick": onWrapperClick,
          "onKeydown": onWrapperKeydown
        }, [createVNode(Transition, {
          "name": transitionName.value
        }, {
          default: () => {
            var _a;
            return [createVNode("div", mergeProps({
              "role": "document",
              "class": prefixCls,
              "style": contentStyle.value,
              "onMousedown": onContentMousedown,
              "onMouseup": onContentMouseup
            }, attrs), [createVNode("div", {
              "ref": sentinelStartRef,
              "tabindex": 0,
              "class": `${prefixCls}-sentinel`,
              "aria-hidden": true
            }, null), createVNode("div", {
              "class": `${prefixCls}-content`
            }, [createVNode(\u0275Header, {
              "closable": closable.value,
              "closeIcon": closeIcon.value,
              "header": props.header,
              "onClose": close
            }, slots), createVNode("div", {
              "class": `${prefixCls}-body`
            }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), createVNode(\u0275Footer, {
              "class": `${prefixCls}-footer`,
              "footer": props.footer
            }, slots)]), createVNode("div", {
              "ref": sentinelEndRef,
              "tabindex": 0,
              "class": `${prefixCls}-sentinel`,
              "aria-hidden": true
            }, null)])];
          }
        })]), [[vShow, visible.value]])]
      });
    };
  }
});
function useConfig$1(props, config) {
  const closable = computed(() => {
    var _a;
    return (_a = props.closable) != null ? _a : config.closable;
  });
  const closeIcon = computed(() => {
    var _a;
    return (_a = props.closeIcon) != null ? _a : config.closeIcon;
  });
  const closeOnEsc = computed(() => {
    var _a;
    return (_a = props.closeOnEsc) != null ? _a : config.closeOnEsc;
  });
  const mask = computed(() => {
    var _a;
    return (_a = props.mask) != null ? _a : config.mask;
  });
  const maskClosable = computed(() => {
    var _a;
    return (_a = props.maskClosable) != null ? _a : config.maskClosable;
  });
  const zIndex = computed(() => {
    var _a;
    return (_a = props.zIndex) != null ? _a : config.zIndex;
  });
  return {
    closable,
    closeIcon,
    closeOnEsc,
    mask,
    maskClosable,
    zIndex
  };
}
function watchVisibleChange$1(props, wrapperRef, sentinelStartRef, mask) {
  let lastOutSideActiveElement = null;
  watch(() => props.visible, (visible) => {
    var _a, _b;
    if (visible) {
      const wrapperElement = wrapperRef.value;
      const activeElement = document.activeElement;
      if (!wrapperElement.contains(activeElement)) {
        lastOutSideActiveElement = activeElement;
        (_a = sentinelStartRef.value) == null ? void 0 : _a.focus();
      }
    } else {
      if (mask.value) {
        (_b = lastOutSideActiveElement == null ? void 0 : lastOutSideActiveElement.focus) == null ? void 0 : _b.call(lastOutSideActiveElement);
        lastOutSideActiveElement = null;
      }
    }
  }, {
    immediate: true
  });
}
function useEvent$1(close, mask, maskClosable, closeOnEsc, sentinelStartRef, sentinelEndRef) {
  let timeId;
  let mouseDown = false;
  const clearTimer = () => {
    if (timeId) {
      clearTimeout(timeId);
      timeId = void 0;
    }
  };
  const onWrapperClick = (evt) => {
    if (evt.target === evt.currentTarget && !mouseDown && mask.value && maskClosable.value) {
      close(evt);
    }
  };
  const onWrapperKeydown = (evt) => {
    if (closeOnEsc.value && evt.code === "Escape") {
      evt.stopPropagation();
      close(evt);
      return;
    }
    if (evt.code === "Tab") {
      const activeElement = document.activeElement;
      const sentinelStartElement = sentinelStartRef.value;
      const sentinelEndElement = sentinelEndRef.value;
      if (evt.shiftKey) {
        if (activeElement === sentinelStartElement) {
          sentinelEndElement == null ? void 0 : sentinelEndElement.focus();
        }
      } else if (activeElement === sentinelEndElement) {
        sentinelStartElement == null ? void 0 : sentinelStartElement.focus();
      }
    }
  };
  const onContentMousedown = () => {
    clearTimer();
    mouseDown = true;
  };
  const onContentMouseup = () => {
    if (mouseDown) {
      timeId = setTimeout(() => mouseDown = false);
    }
  };
  onBeforeUnmount(() => clearTimer());
  return {
    onContentMousedown,
    onContentMouseup,
    onWrapperClick,
    onWrapperKeydown
  };
}
function useEvents$4(props, wrapperRef, animatedVisible) {
  let lastOutSideActiveElement = null;
  const onEnter = () => {
    const wrapperElement = wrapperRef.value;
    const activeElement = document.activeElement;
    if (!wrapperElement.contains(activeElement)) {
      lastOutSideActiveElement = activeElement;
    }
  };
  const onAfterEnter = () => {
    const wrapperElement = wrapperRef.value;
    const activeElement = document.activeElement;
    if (!wrapperElement.contains(activeElement)) {
      wrapperElement.focus();
    }
    callEmit(props.onAfterOpen);
    animatedVisible.value = true;
  };
  const onAfterLeave = () => {
    if (lastOutSideActiveElement && isFunction(lastOutSideActiveElement.focus)) {
      const wrapperElement = wrapperRef.value;
      const activeElement = document.activeElement;
      if (!activeElement || activeElement === document.body || activeElement === wrapperElement || wrapperElement.contains(activeElement)) {
        lastOutSideActiveElement.focus();
      }
    }
    callEmit(props.onAfterClose);
    animatedVisible.value = false;
  };
  return {
    onEnter,
    onAfterEnter,
    onAfterLeave
  };
}
const drawerProps = {
  visible: IxPropTypes.bool,
  closable: IxPropTypes.bool,
  closeIcon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  closeOnEsc: IxPropTypes.bool,
  destroyOnHide: IxPropTypes.bool.def(false),
  footer: IxPropTypes.oneOfType([IxPropTypes.array(), IxPropTypes.vNode]),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  height: IxPropTypes.oneOfType([String, Number]),
  mask: IxPropTypes.bool,
  maskClosable: IxPropTypes.bool,
  offset: IxPropTypes.oneOfType([String, Number]).def(0),
  placement: IxPropTypes.oneOf(["top", "bottom", "start", "end"]).def("end"),
  scrollStrategy: IxPropTypes.object(),
  target: portalTargetDef,
  width: IxPropTypes.oneOfType([String, Number]),
  wrapperClassName: IxPropTypes.string,
  zIndex: IxPropTypes.number,
  "onUpdate:visible": IxPropTypes.emit(),
  onAfterOpen: IxPropTypes.emit(),
  onAfterClose: IxPropTypes.emit(),
  onBeforeClose: IxPropTypes.emit(),
  onClose: IxPropTypes.emit()
};
var __async$7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Drawer = defineComponent({
  name: "IxDrawer",
  inheritAttrs: false,
  props: drawerProps,
  setup(props, {
    slots,
    expose,
    attrs
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-drawer`);
    const config = useGlobalConfig$1("drawer");
    const mask = computed(() => {
      var _a;
      return (_a = props.mask) != null ? _a : config.mask;
    });
    const zIndex = computed(() => {
      var _a;
      return (_a = props.zIndex) != null ? _a : config.zIndex;
    });
    const {
      visible,
      setVisible,
      animatedVisible,
      mergedVisible
    } = useVisible$2(props);
    const {
      open,
      close
    } = useTrigger$2(props, setVisible);
    const {
      level,
      levelAction,
      push,
      pull
    } = useLevel(visible);
    provide(drawerToken, {
      props,
      slots,
      common,
      config,
      mergedPrefixCls,
      visible,
      animatedVisible,
      mergedVisible,
      level,
      levelAction,
      push,
      pull
    });
    const apis = {
      open,
      close
    };
    provide(DRAWER_TOKEN, apis);
    expose(apis);
    useScrollStrategy$1(props, mask, mergedVisible);
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-container`;
    });
    return () => {
      if (!mergedVisible.value && props.destroyOnHide) {
        return null;
      }
      return createVNode(CdkPortal, {
        "target": target.value,
        "load": visible.value
      }, {
        default: () => [createVNode(\u0275Mask, {
          "class": `${mergedPrefixCls.value}-mask`,
          "mask": mask.value,
          "visible": visible.value,
          "zIndex": zIndex.value
        }, null), createVNode(DrawerWrapper, attrs, null)]
      });
    };
  }
});
function useVisible$2(props) {
  const [visible, setVisible] = useControlledProp(props, "visible", false);
  const animatedVisible = ref();
  const mergedVisible = computed(() => {
    const currVisible = visible.value;
    const currAnimatedVisible = animatedVisible.value;
    if (currAnimatedVisible === void 0 || currVisible) {
      return currVisible;
    }
    return currAnimatedVisible;
  });
  return {
    visible,
    setVisible,
    animatedVisible,
    mergedVisible
  };
}
function useScrollStrategy$1(props, mask, mergedVisible) {
  let scrollStrategy;
  onMounted(() => {
    watch([mask, mergedVisible], ([maskValue, visible]) => {
      var _a;
      if (!maskValue || !visible) {
        scrollStrategy == null ? void 0 : scrollStrategy.disable();
        return;
      }
      if (!scrollStrategy) {
        scrollStrategy = (_a = props.scrollStrategy) != null ? _a : new BlockScrollStrategy();
      }
      scrollStrategy.enable();
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => scrollStrategy == null ? void 0 : scrollStrategy.disable());
}
function useTrigger$2(props, setVisible) {
  const open = () => setVisible(true);
  const close = (evt) => __async$7(this, null, function* () {
    const result = yield callEmit(props.onBeforeClose, evt);
    if (result === false) {
      return;
    }
    setVisible(false);
    callEmit(props.onClose, evt);
  });
  return {
    open,
    close
  };
}
function useLevel(visible) {
  const parentContext = inject(drawerToken, null);
  const level = ref(0);
  const levelAction = ref();
  const push = () => {
    level.value++;
    parentContext == null ? void 0 : parentContext.push();
  };
  const pull = () => {
    level.value--;
    parentContext == null ? void 0 : parentContext.pull();
  };
  watch(visible, (value) => {
    if (value) {
      parentContext == null ? void 0 : parentContext.push();
    } else {
      parentContext == null ? void 0 : parentContext.pull();
      levelAction.value = void 0;
    }
  });
  watch(level, (currLevel, prevLevel) => {
    levelAction.value = currLevel > prevLevel ? "push" : "pull";
  });
  onMounted(() => {
    if (visible.value) {
      parentContext == null ? void 0 : parentContext.push();
    }
  });
  onBeforeUnmount(() => {
    if (visible.value) {
      parentContext == null ? void 0 : parentContext.pull();
    }
  });
  return {
    level,
    levelAction,
    push,
    pull
  };
}
var __defProp$l = Object.defineProperty;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
var __objRest$c = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$n.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$n.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var DrawerProvider = defineComponent({
  name: "IxDrawerProvider",
  setup(_, {
    expose,
    slots
  }) {
    const {
      drawers,
      setDrawerRef,
      open,
      update,
      destroy,
      destroyAll
    } = useDrawer$1();
    const apis = {
      open,
      update,
      destroy,
      destroyAll
    };
    provide(drawerProviderToken, apis);
    expose(apis);
    return () => {
      var _a;
      const children = drawers.value.map((item) => {
        const _a2 = item, {
          key,
          visible = true,
          destroyOnHide,
          onDestroy,
          content,
          contentProps
        } = _a2, rest = __objRest$c(_a2, [
          "key",
          "visible",
          "destroyOnHide",
          "onDestroy",
          "content",
          "contentProps"
        ]);
        const setRef = (instance) => setDrawerRef(key, instance);
        const onUpdateVisible = (visible2) => update(key, {
          visible: visible2
        });
        const onAfterClose = destroyOnHide ? () => destroy(key) : void 0;
        const mergedProps = {
          key,
          visible,
          ref: setRef,
          "onUpdate:visible": onUpdateVisible,
          onAfterClose
        };
        const contentNode = isVNode(content) ? cloneVNode(content, contentProps, true) : content;
        return createVNode(Drawer, mergeProps(mergedProps, rest), {
          default: () => [contentNode]
        });
      });
      return createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots), children]);
    };
  }
});
function useDrawer$1() {
  const drawers = shallowRef([]);
  const drawerRefMap = /* @__PURE__ */ new Map();
  const setDrawerRef = (key, instance) => {
    const ref2 = drawerRefMap.get(key);
    if (instance) {
      if (ref2 && !ref2.open) {
        ref2.open = instance.open;
        ref2.close = instance.close;
      }
    } else {
      if (ref2) {
        drawerRefMap.delete(key);
        ref2.open = NoopFunction;
        ref2.close = NoopFunction;
      }
    }
  };
  const getCurrIndex = (key) => {
    return drawers.value.findIndex((message) => message.key === key);
  };
  const add = (item) => {
    var _a;
    const currIndex = item.key ? getCurrIndex(item.key) : -1;
    const tempDrawers = [...drawers.value];
    if (currIndex !== -1) {
      tempDrawers.splice(currIndex, 1, item);
      drawers.value = tempDrawers;
      return item.key;
    }
    item.key = (_a = item.key) != null ? _a : uniqueId("ix-drawer");
    tempDrawers.push(item);
    drawers.value = tempDrawers;
    return item.key;
  };
  const update = (key, item) => {
    const currIndex = getCurrIndex(key);
    if (currIndex !== -1) {
      const tempDrawers = [...drawers.value];
      const newItem = __spreadValues$l(__spreadValues$l({}, drawers.value[currIndex]), item);
      tempDrawers.splice(currIndex, 1, newItem);
      drawers.value = tempDrawers;
    }
  };
  const destroy = (key) => {
    const keys = convertArray(key);
    keys.forEach((key2) => {
      const currIndex = getCurrIndex(key2);
      if (currIndex !== -1) {
        const tempDrawers = [...drawers.value];
        const item = tempDrawers.splice(currIndex, 1);
        drawers.value = tempDrawers;
        callEmit(item[0].onDestroy, key2);
      }
    });
  };
  const destroyAll = () => {
    drawers.value = [];
  };
  const open = (options) => {
    const key = add(options);
    const drawerRef = {
      key,
      update: (options2) => update(key, options2),
      destroy: () => destroy(key)
    };
    drawerRefMap.set(key, drawerRef);
    return drawerRef;
  };
  return {
    drawers,
    setDrawerRef,
    open,
    update,
    destroy,
    destroyAll
  };
}
const IxDrawer = Drawer;
const IxDrawerProvider = DrawerProvider;

const dropdownToken = Symbol("dropdownToken");
const dropdownProps = {
  visible: IxPropTypes.bool,
  autoAdjust: IxPropTypes.bool,
  destroyOnHide: IxPropTypes.bool,
  disabled: IxPropTypes.bool.def(false),
  hideOnClick: IxPropTypes.bool.def(true),
  offset: IxPropTypes.array(),
  placement: overlayPlacementDef,
  showArrow: IxPropTypes.bool,
  target: portalTargetDef,
  trigger: overlayTriggerDef,
  "onUpdate:visible": IxPropTypes.emit()
};
const defaultDelay$1 = [0, 100];
var Dropdown = defineComponent({
  name: "IxDropdown",
  props: dropdownProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-dropdown`);
    const config = useGlobalConfig$1("dropdown");
    const [visibility, setVisibility] = useControlledProp(props, "visible", false);
    const configProps = useConfigProps(props, config, mergedPrefixCls, setVisibility);
    provide(dropdownToken, {
      hideOnClick: toRef(props, "hideOnClick"),
      setVisibility
    });
    return () => {
      return createVNode(\u0275Overlay, mergeProps({
        "visible": visibility.value,
        "class": mergedPrefixCls.value,
        "delay": defaultDelay$1,
        "disabled": props.disabled,
        "transitionName": `${common.prefixCls}-fade`
      }, configProps.value), {
        default: slots.default,
        content: slots.overlay
      });
    };
  }
});
function useConfigProps(props, config, mergedPrefixCls, setVisibility) {
  return computed(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const trigger = (_a = props.trigger) != null ? _a : config.trigger;
    return {
      autoAdjust: (_b = props.autoAdjust) != null ? _b : config.autoAdjust,
      clickOutside: trigger === "click" || trigger === "contextmenu",
      destroyOnHide: (_c = props.destroyOnHide) != null ? _c : config.destroyOnHide,
      offset: (_d = props.offset) != null ? _d : config.offset,
      placement: (_e = props.placement) != null ? _e : config.placement,
      showArrow: (_f = props.showArrow) != null ? _f : config.showArrow,
      target: (_h = (_g = props.target) != null ? _g : config.target) != null ? _h : `${mergedPrefixCls.value}-container`,
      trigger,
      ["onUpdate:visible"]: setVisibility
    };
  });
}
const IxDropdown = Dropdown;

const emptyProps = {
  description: IxPropTypes.string,
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  image: IxPropTypes.oneOfType([String, IxPropTypes.vNode])
};
var Empty$1 = defineComponent({
  name: "IxEmpty",
  props: emptyProps,
  setup(props, {
    slots
  }) {
    const emptyLocale = getLocale("empty");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-empty`);
    const config = useGlobalConfig$1("empty");
    const description = computed(() => {
      var _a;
      return (_a = props.description) != null ? _a : emptyLocale.value.description;
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const descriptionNode = slots.description ? slots.description() : description.value;
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("div", {
        "class": `${prefixCls}-image`
      }, [renderImage(props, slots, config)]), descriptionNode && createVNode("div", {
        "class": `${prefixCls}-description`
      }, [descriptionNode]), slots.default && createVNode("div", {
        "class": `${prefixCls}-content`
      }, [slots.default()])]);
    };
  }
});
function renderImage(props, slots, config) {
  var _a, _b;
  if (slots.image) {
    return slots.image();
  }
  const image = (_a = props.image) != null ? _a : config.image;
  if (image) {
    if (isString(image)) {
      return createVNode("img", {
        "src": image,
        "alt": "empty image"
      }, null);
    }
    return image;
  }
  const icon = (_b = props.icon) != null ? _b : config.icon;
  return isString(icon) ? createVNode(IxIcon, {
    "name": icon
  }, null) : icon;
}
const IxEmpty = Empty$1;

var __defProp$1$8 = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$b = Object.getOwnPropertySymbols;
var __hasOwnProp$1$b = Object.prototype.hasOwnProperty;
var __propIsEnum$1$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$8 = (obj, key, value) => key in obj ? __defProp$1$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$b.call(b, prop))
      __defNormalProp$1$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$b)
    for (var prop of __getOwnPropSymbols$1$b(b)) {
      if (__propIsEnum$1$b.call(b, prop))
        __defNormalProp$1$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
const zoomValidator = {
  validator: (val) => val.length === 2,
  msg: "zoom only accepts the length of the array is 2"
};
const imageViewerProps = {
  visible: IxPropTypes.bool,
  activeIndex: IxPropTypes.number,
  images: IxPropTypes.array().isRequired,
  zoom: IxPropTypes.custom(zoomValidator.validator, zoomValidator.msg),
  loop: IxPropTypes.bool,
  target: portalTargetDef,
  maskClosable: IxPropTypes.bool,
  "onUpdate:visible": IxPropTypes.emit(),
  "onUpdate:activeIndex": IxPropTypes.emit()
};
const imageProps = {
  src: IxPropTypes.string.isRequired,
  preview: IxPropTypes.bool,
  imageViewer: IxPropTypes.shape(__spreadProps$g(__spreadValues$1$8({}, imageViewerProps), { images: IxPropTypes.array() })),
  onLoad: IxPropTypes.emit(),
  onError: IxPropTypes.emit()
};
const imageViewerContentProps = __spreadValues$1$8({
  mergedPrefixCls: IxPropTypes.string.isRequired
}, imageViewerProps);
const mousewheelEventName = isFirefox ? "DOMMouseScroll" : "mousewheel";
const debounceTime = 10;
var ImageViewerContent = defineComponent({
  name: "IxImageViewerContent",
  props: imageViewerContentProps,
  setup(props) {
    const config = useGlobalConfig$1("imageViewer");
    const zoom = useZoomRange(props, config);
    const maskClosable = useMaskClosable(props, config);
    const [visible, setVisible] = useControlledProp(props, "visible", false);
    const {
      calcTransform,
      scaleDisabled,
      rotateHandle,
      scaleHandle,
      resetTransform
    } = useStyleOpr(zoom);
    const {
      activeIndex,
      switchDisabled,
      switchVisible,
      goHandle
    } = useSwitch(props, config);
    const oprList = useOprList({
      goNext: () => goHandle("next"),
      goPrevious: () => goHandle("previous"),
      rotateLeft: () => rotateHandle("left"),
      rotateRight: () => rotateHandle("right"),
      zoomOut: () => scaleHandle("out"),
      zoomIn: () => scaleHandle("in"),
      close: () => setVisible(false)
    }, scaleDisabled, switchDisabled, switchVisible);
    const {
      onWheelScroll,
      onKeydown
    } = getImageEvent(visible, {
      setVisible,
      scaleHandle,
      goHandle
    });
    const onClickLayer = () => maskClosable.value && setVisible(false);
    onMounted(() => {
      window.addEventListener(mousewheelEventName, onWheelScroll, {
        passive: false,
        capture: false
      });
      window.addEventListener("keydown", onKeydown, false);
    });
    onBeforeUnmount(() => {
      window.removeEventListener(mousewheelEventName, onWheelScroll);
      window.removeEventListener("keydown", onKeydown);
    });
    watch([visible, activeIndex], ([visible$$]) => {
      visible$$ && resetTransform();
    });
    return () => createVNode("div", {
      "class": props.mergedPrefixCls
    }, [renderOprNode(props, oprList), renderPreviewImg(props, calcTransform, activeIndex, onClickLayer)]);
  }
});
function renderOprNode(props, oprList) {
  return createVNode("div", {
    "class": `${props.mergedPrefixCls}-opr`
  }, [oprList.value.filter((item) => item.visible).map((item) => {
    const iconClasses = computed(() => normalizeClass([`${props.mergedPrefixCls}-opr-item`, {
      [`${props.mergedPrefixCls}-opr-item-disabled`]: item.disabled
    }]));
    return createVNode(IxIcon, {
      "class": iconClasses.value,
      "name": item.icon,
      "onClick": item.opr,
      "key": item.key
    }, null);
  })]);
}
function renderPreviewImg(props, calcTransform, activeIndex, onClickLayer) {
  var _a;
  const curImgSrc = ((_a = props.images) != null ? _a : [])[activeIndex.value];
  return createVNode("div", {
    "class": `${props.mergedPrefixCls}-preview`,
    "onClick": onClickLayer
  }, [createVNode("img", {
    "class": `${props.mergedPrefixCls}-preview-img`,
    "src": curImgSrc,
    "style": calcTransform.value
  }, null)]);
}
function useOprList({
  goNext,
  goPrevious,
  rotateLeft,
  rotateRight,
  zoomOut,
  zoomIn,
  close
}, scaleDisabled, switchDisabled, switchVisible) {
  return computed(() => [{
    key: "goPrevious",
    icon: "left",
    opr: goPrevious,
    disabled: switchDisabled.value.previous,
    visible: switchVisible.value
  }, {
    key: "goNext",
    icon: "right",
    opr: goNext,
    disabled: switchDisabled.value.next,
    visible: switchVisible.value
  }, {
    key: "rotateLeft",
    icon: "rotate-left",
    opr: rotateLeft,
    visible: true
  }, {
    key: "rotateRight",
    icon: "rotate-right",
    opr: rotateRight,
    visible: true
  }, {
    key: "zoomOut",
    icon: "zoom-out",
    opr: zoomOut,
    disabled: scaleDisabled.value.out,
    visible: true
  }, {
    key: "zoomIn",
    icon: "zoom-in",
    opr: zoomIn,
    disabled: scaleDisabled.value.in,
    visible: true
  }, {
    key: "close",
    icon: "close",
    opr: close,
    visible: true
  }]);
}
function useSwitch(props, config) {
  const [activeIndex, setIndex] = useControlledProp(props, "activeIndex", 0);
  const loop = computed(() => {
    var _a;
    return (_a = props.loop) != null ? _a : config.loop;
  });
  const switchDisabled = computed(() => ({
    previous: !loop.value && activeIndex.value === 0,
    next: !loop.value && activeIndex.value === props.images.length - 1
  }));
  const switchVisible = computed(() => props.images.length > 1);
  const goHandle = debounce$1((direction = "next") => {
    if (direction === "next") {
      if (switchDisabled.value.next) {
        return;
      }
      setIndex(activeIndex.value >= props.images.length - 1 ? 0 : activeIndex.value + 1);
      return;
    }
    if (switchDisabled.value.previous) {
      return;
    }
    setIndex(activeIndex.value <= 0 ? props.images.length - 1 : activeIndex.value - 1);
  }, debounceTime);
  return {
    activeIndex,
    switchDisabled,
    switchVisible,
    goHandle
  };
}
function useStyleOpr(zoom) {
  const initScale = computed(() => getInitScale(zoom.value));
  const initRotate = 0;
  const scale = ref(1);
  const rotate = ref(initRotate);
  const rotateFactor = {
    left: -1,
    right: 1
  };
  const scaleFactor = {
    in: 1,
    out: -1
  };
  watchEffect(() => scale.value = initScale.value);
  const scaleDisabled = computed(() => ({
    in: scale.value >= zoom.value[1],
    out: scale.value <= zoom.value[0]
  }));
  const calcTransform = computed(() => ({
    transform: `scale(${scale.value}) rotate(${rotate.value}deg)`
  }));
  const rotateHandle = debounce$1((direction = "left", rotateStep = 90) => {
    rotate.value = rotate.value + rotateStep * rotateFactor[direction];
  }, debounceTime);
  const scaleHandle = debounce$1((direction, scaleStep = 0.2) => {
    if (scaleDisabled.value[direction]) {
      return;
    }
    scale.value = scale.value + scaleStep * scaleFactor[direction];
  }, debounceTime);
  const resetTransform = () => {
    scale.value = initScale.value;
    rotate.value = initRotate;
  };
  return {
    calcTransform,
    scaleDisabled,
    rotateHandle,
    scaleHandle,
    resetTransform
  };
}
function useZoomRange(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.zoom) != null ? _a : config.zoom;
  });
}
function useMaskClosable(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.maskClosable) != null ? _a : config.maskClosable;
  });
}
function getImageEvent(visible, {
  setVisible,
  scaleHandle,
  goHandle
}) {
  const scroll = (e) => {
    var _a;
    if (!visible.value) {
      return;
    }
    const event = e;
    event.preventDefault();
    const delta = (_a = event.wheelDelta) != null ? _a : -event.detail;
    if (delta > 0) {
      scaleHandle("in", 0.2);
    } else {
      scaleHandle("out", 0.2);
    }
  };
  const keyHandle = {
    ArrowUp: () => scaleHandle("in", 0.2),
    ArrowDown: () => scaleHandle("out", 0.2),
    ArrowLeft: () => goHandle("previous"),
    ArrowRight: () => goHandle("next"),
    Escape: () => setVisible(false)
  };
  const keyDown = (e) => {
    if (!visible.value) {
      return;
    }
    e.preventDefault();
    if (e.code in keyHandle) {
      keyHandle[e.code]();
    }
  };
  return {
    onWheelScroll: scroll,
    onKeydown: keyDown
  };
}
function getInitScale(zoom) {
  const defaultScale = 1;
  if (zoom[0] > defaultScale) {
    return zoom[0];
  }
  if (zoom[1] < defaultScale) {
    return zoom[1];
  }
  return defaultScale;
}
var ImageViewer = defineComponent({
  name: "IxImageViewer",
  props: imageViewerProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const config = useGlobalConfig$1("imageViewer");
    const [visible] = useControlledProp(props, "visible", false);
    const mergedPrefixCls = computed(() => `${common.prefixCls}-image-viewer`);
    const target = useTarget(props, config, mergedPrefixCls);
    return () => createVNode(CdkPortal, {
      "target": target.value,
      "load": visible.value
    }, {
      default: () => [createVNode(Transition, {
        "name": `${common.prefixCls}-zoom-big-fast`,
        "appear": true
      }, {
        default: () => [visible.value && createVNode(ImageViewerContent, mergeProps({
          "mergedPrefixCls": mergedPrefixCls.value
        }, props), null)]
      })]
    });
  }
});
function useTarget(props, config, mergedPrefixCls) {
  return computed(() => {
    var _a, _b;
    return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-container`;
  });
}
var __defProp$k = Object.defineProperty;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
var __objRest$b = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$m.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$m.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Image = defineComponent({
  name: "IxImage",
  inheritAttrs: false,
  props: imageProps,
  setup(props, {
    attrs,
    slots
  }) {
    const _a = attrs, {
      class: className,
      style
    } = _a, rest = __objRest$b(_a, [
      "class",
      "style"
    ]);
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-image`);
    const config = useGlobalConfig$1("image");
    const preview = usePreview(props, config);
    const {
      status,
      setFailed,
      setLoaded
    } = useStatus$1(props);
    const [viewerVisible, setVisible] = useViewerVisible();
    const {
      outerClasses,
      overLayerClasses,
      imageClasses
    } = useClasses$6(mergedPrefixCls, className, status, preview);
    return () => {
      var _a2;
      const imageViewerProps2 = __spreadValues$k({
        visible: viewerVisible.value,
        "onUpdate:visible": setVisible,
        images: [props.src]
      }, (_a2 = props.imageViewer) != null ? _a2 : {});
      return createVNode("div", {
        "class": outerClasses.value,
        "style": style
      }, [createVNode("div", {
        "class": overLayerClasses.value
      }, [renderPreviewIcon(props, slots, mergedPrefixCls, status, preview, setVisible), renderPlaceholder(slots, mergedPrefixCls, status), renderFallback(slots, mergedPrefixCls, status), createVNode(ImageViewer, imageViewerProps2, null)]), createVNode("img", mergeProps(rest, {
        "src": props.src,
        "class": imageClasses.value,
        "onLoad": setLoaded,
        "onError": setFailed
      }), null)]);
    };
  }
});
function renderPreviewIcon(props, slots, mergedPrefixCls, status, preview, setVisible) {
  var _a, _b;
  return status.value === "loaded" && preview.value && createVNode("span", {
    "class": `${mergedPrefixCls.value}-preview-wrapper`,
    "onClick": () => setVisible(true)
  }, [(_b = (_a = slots.previewIcon) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(IxIcon, {
    "class": `${mergedPrefixCls.value}-preview-icon`,
    "name": "zoom-in"
  }, null)]);
}
function renderPlaceholder(slots, mergedPrefixCls, status) {
  var _a, _b;
  return status.value === "loading" && ((_b = (_a = slots.placeholder) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(IxIcon, {
    "class": `${mergedPrefixCls.value}-placeholder`,
    "name": "loading"
  }, null));
}
function renderFallback(slots, mergedPrefixCls, status) {
  var _a, _b;
  return status.value === "failed" && ((_b = (_a = slots.fallback) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(IxIcon, {
    "class": `${mergedPrefixCls.value}-fallback`,
    "name": "file-image"
  }, null));
}
function useViewerVisible() {
  const viewerVisible = ref(false);
  const setVisible = (visible) => {
    viewerVisible.value = visible;
  };
  return [viewerVisible, setVisible];
}
function useClasses$6(mergedPrefixCls, className, status, preview) {
  const outerClasses = computed(() => normalizeClass([mergedPrefixCls.value, className, `${mergedPrefixCls.value}-${status.value}`, {
    [`${mergedPrefixCls.value}-preview`]: preview.value
  }]));
  const overLayerClasses = computed(() => normalizeClass(`${mergedPrefixCls.value}-layer`));
  const imageClasses = computed(() => normalizeClass([`${mergedPrefixCls.value}-inner`, {
    [`${mergedPrefixCls.value}-inner-hidden`]: status.value !== "loaded"
  }]));
  return {
    outerClasses,
    overLayerClasses,
    imageClasses
  };
}
function usePreview(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.preview) != null ? _a : config.preview;
  });
}
function useStatus$1(props) {
  const status = ref("loading");
  const setLoaded = (e) => {
    status.value = "loaded";
    callEmit(props.onLoad, e);
  };
  const setFailed = (e) => {
    status.value = "failed";
    callEmit(props.onError, e);
  };
  watch(() => props.src, () => {
    status.value = "loading";
  }, {
    immediate: true
  });
  return {
    status,
    setLoaded,
    setFailed
  };
}
const IxImage = Image;
const IxImageViewer = ImageViewer;

const inputProps$1 = {
  addonAfter: IxPropTypes.string,
  addonBefore: IxPropTypes.string,
  borderless: IxPropTypes.bool,
  clearable: IxPropTypes.bool,
  clearIcon: IxPropTypes.string,
  clearVisible: IxPropTypes.bool,
  disabled: IxPropTypes.bool,
  focused: IxPropTypes.bool,
  prefix: IxPropTypes.string,
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  onClear: IxPropTypes.func()
};
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __objRest$a = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$l.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$l.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Input$3 = defineComponent({
  inheritAttrs: false,
  props: inputProps$1,
  setup(props, {
    attrs,
    slots,
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-input`);
    const inputRef = ref();
    const getInputElement = () => inputRef.value;
    expose({
      getInputElement
    });
    const classes = computed(() => {
      const {
        borderless,
        clearable,
        disabled,
        focused,
        size,
        addonAfter,
        addonBefore,
        prefix,
        suffix
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${size}`]: true,
        [`${prefixCls}-borderless`]: borderless,
        [`${prefixCls}-clearable`]: clearable,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-focused`]: focused,
        [`${prefixCls}-with-addon-after`]: addonAfter || slots.addonAfter,
        [`${prefixCls}-with-addon-before`]: addonBefore || slots.addonBefore,
        [`${prefixCls}-with-prefix`]: prefix || slots.prefix,
        [`${prefixCls}-with-suffix`]: suffix || slots.suffix
      });
    });
    return () => {
      const {
        clearable,
        clearIcon,
        clearVisible,
        disabled,
        addonAfter,
        addonBefore,
        prefix,
        suffix,
        onClear
      } = props;
      const prefixCls = mergedPrefixCls.value;
      const addonBeforeNode = renderAddon(slots.addonBefore, addonBefore, `${prefixCls}-addon`);
      const addonAfterNode = renderAddon(slots.addonAfter, addonAfter, `${prefixCls}-addon`);
      const prefixNode = renderIcon$5(slots.prefix, prefix, `${prefixCls}-prefix`);
      const suffixNode = renderIcon$5(slots.suffix, suffix, `${prefixCls}-suffix`);
      const clearNode = clearable && createVNode("span", {
        "class": `${prefixCls}-clear${clearVisible ? " visible" : ""}`,
        "onClick": onClear
      }, [createVNode(IxIcon, {
        "name": clearIcon
      }, null)]);
      if (!(addonBeforeNode || addonAfterNode || prefixNode || suffixNode || clearNode)) {
        return createVNode("input", mergeProps({
          "ref": inputRef,
          "class": classes.value,
          "disabled": disabled
        }, attrs), null);
      }
      const _a = attrs, {
        class: className,
        style
      } = _a, rest = __objRest$a(_a, [
        "class",
        "style"
      ]);
      const classNames = normalizeClass([classes.value, className]);
      const inputNode = createVNode("input", mergeProps({
        "ref": inputRef,
        "class": `${prefixCls}-inner`,
        "disabled": disabled
      }, rest), null);
      if (!(addonBeforeNode || addonAfterNode)) {
        return createVNode("span", {
          "class": classNames,
          "style": style
        }, [prefixNode, inputNode, suffixNode, clearNode]);
      }
      if (!(prefixNode || suffixNode || clearNode)) {
        return createVNode("span", {
          "class": classNames,
          "style": style
        }, [addonBeforeNode, inputNode, addonAfterNode]);
      }
      return createVNode("span", {
        "class": classNames,
        "style": style
      }, [addonBeforeNode, createVNode("span", {
        "class": `${prefixCls}-wrapper`
      }, [prefixNode, inputNode, suffixNode, clearNode]), addonAfterNode]);
    };
  }
});
function renderAddon(slot, prop, cls) {
  if (!(slot || prop)) {
    return void 0;
  }
  return createVNode("span", {
    "class": cls
  }, [slot ? slot() : prop]);
}
function renderIcon$5(slot, prop, cls) {
  if (!(slot || prop)) {
    return void 0;
  }
  return createVNode("span", {
    "class": cls
  }, [slot ? slot() : createVNode(IxIcon, {
    "name": prop
  }, null)]);
}
const \u0275Input = Input$3;

var __defProp$j = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
const commonProps = {
  value: IxPropTypes.string,
  control: controlPropDef,
  clearable: IxPropTypes.bool,
  clearIcon: IxPropTypes.string,
  disabled: IxPropTypes.bool.def(false),
  readonly: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onClear: IxPropTypes.emit(),
  onCompositionStart: IxPropTypes.emit(),
  onCompositionEnd: IxPropTypes.emit(),
  onInput: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
};
const inputProps = __spreadProps$f(__spreadValues$j({}, commonProps), {
  addonAfter: IxPropTypes.string,
  addonBefore: IxPropTypes.string,
  borderless: IxPropTypes.bool,
  prefix: IxPropTypes.string,
  suffix: IxPropTypes.string
});
function useInput(props, config) {
  const accessor = useFormAccessor();
  const clearable = computed(() => {
    var _a;
    return (_a = props.clearable) != null ? _a : config.clearable;
  });
  const clearIcon = computed(() => {
    var _a;
    return (_a = props.clearIcon) != null ? _a : config.clearIcon;
  });
  const clearVisible = computed(() => !accessor.disabled.value && !props.readonly && !!accessor.valueRef.value);
  const isFocused = ref(false);
  const handleFocus = (evt) => {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  };
  const handleBlur = (evt) => {
    isFocused.value = false;
    callEmit(props.onBlur, evt);
    accessor.markAsBlurred();
  };
  const { elementRef, focus, blur } = useFormFocusMonitor({
    handleFocus,
    handleBlur
  });
  const syncValue = () => {
    var _a;
    const element = elementRef.value;
    const value = (_a = accessor.valueRef.value) != null ? _a : "";
    if (element && element.value !== value) {
      element.value = value;
    }
  };
  watch(accessor.valueRef, () => syncValue());
  const isComposing = ref(false);
  const handleInput = (evt) => {
    callEmit(props.onInput, evt);
    if (isComposing.value) {
      return;
    }
    const { value } = evt.target;
    const oldValue = toRaw(accessor.valueRef.value);
    if (value !== oldValue) {
      accessor.setValue(value);
      callEmit(props.onChange, value, oldValue);
      nextTick(() => syncValue());
    }
  };
  const handleCompositionStart = (evt) => {
    isComposing.value = true;
    callEmit(props.onCompositionStart, evt);
  };
  const handleCompositionEnd = (evt) => {
    callEmit(props.onCompositionEnd, evt);
    if (isComposing.value) {
      isComposing.value = false;
      handleInput(evt);
    }
  };
  const handleClear = (evt) => {
    callEmit(props.onClear, evt);
    accessor.setValue("");
  };
  return {
    elementRef,
    accessor,
    clearable,
    clearIcon,
    clearVisible,
    isFocused,
    focus,
    blur,
    handleInput,
    handleCompositionStart,
    handleCompositionEnd,
    handleFocus,
    handleBlur,
    handleClear,
    syncValue
  };
}
var Input$2 = defineComponent({
  name: "IxInput",
  props: inputProps,
  setup(props, {
    slots,
    expose
  }) {
    const config = useGlobalConfig$1("input");
    const formContext = inject(FORM_TOKEN, null);
    const size = computed(() => {
      var _a, _b;
      return (_b = (_a = props.size) != null ? _a : formContext == null ? void 0 : formContext.size.value) != null ? _b : config.size;
    });
    const {
      elementRef,
      accessor,
      clearable,
      clearIcon,
      clearVisible,
      isFocused,
      focus,
      blur,
      handleInput,
      handleCompositionStart,
      handleCompositionEnd,
      handleClear,
      syncValue
    } = useInput(props, config);
    expose({
      focus,
      blur
    });
    const inputRef = ref();
    onMounted(() => {
      elementRef.value = inputRef.value.getInputElement();
      syncValue();
    });
    return () => {
      const {
        addonAfter,
        addonBefore,
        borderless,
        prefix,
        suffix
      } = props;
      return createVNode(\u0275Input, {
        "ref": inputRef,
        "addonAfter": addonAfter,
        "addonBefore": addonBefore,
        "borderless": borderless,
        "clearable": clearable.value,
        "clearIcon": clearIcon.value,
        "clearVisible": clearVisible.value,
        "disabled": accessor.disabled.value,
        "focused": isFocused.value,
        "prefix": prefix,
        "size": size.value,
        "suffix": suffix,
        "onClear": handleClear,
        "readonly": props.readonly,
        "onInput": handleInput,
        "onCompositionstart": handleCompositionStart,
        "onCompositionend": handleCompositionEnd
      }, slots);
    };
  }
});
const IxInput = Input$2;

const inputNumberProps = {
  value: IxPropTypes.oneOfType([IxPropTypes.number]),
  control: controlPropDef,
  disabled: IxPropTypes.bool.def(false),
  keyboard: IxPropTypes.bool,
  max: IxPropTypes.number.def(Infinity),
  min: IxPropTypes.number.def(-Infinity),
  placeholder: IxPropTypes.string,
  precision: IxPropTypes.number,
  readonly: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  step: IxPropTypes.number.def(1),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
};
function useInputNumber(props, config) {
  const accessor = useFormAccessor();
  const displayValue = ref("");
  const isIllegal = ref(true);
  const nowValue = computed(() => {
    var _a;
    return (_a = accessor.valueRef.value) != null ? _a : void 0;
  });
  const isKeyboard = computed(() => {
    var _a;
    return (_a = props.keyboard) != null ? _a : config.keyboard;
  });
  const isDisabled = computed(() => accessor == null ? void 0 : accessor.disabled.value);
  const precision = computed(() => {
    const stepPrecision = getPrecision(props.step);
    if (props.precision !== void 0) {
      if (process.env.NODE_ENV !== "production" && stepPrecision > props.precision) {
        Logger.warn("components/input-number", `The precision(${props.precision}) should not be less than the decimal point of the step(${props.step}).`);
      }
      return props.precision;
    }
    return Math.max(getPrecision(accessor.valueRef.value), stepPrecision);
  });
  const disabledDec = computed(() => getIncValueFormAccessor(-props.step) < props.min);
  const disabledInc = computed(() => getIncValueFormAccessor(props.step) > props.max);
  function getIncValueFormAccessor(step) {
    const { value } = accessor.valueRef;
    let newVal = step;
    if (typeof value === "number" && !Number.isNaN(value)) {
      newVal = parseFloat((value + step).toFixed(precision.value));
    }
    return Math.max(props.min, Math.min(props.max, newVal));
  }
  function updateDisplayValueFromAccessor() {
    const { value } = accessor.valueRef;
    if (value === null || value === void 0) {
      displayValue.value = "";
    } else if (Number.isNaN(value)) {
      displayValue.value = "";
      if (process.env.NODE_ENV !== "production") {
        Logger.warn("components/input-number", `model value(${value}) is not a number.`);
      }
    } else {
      if (displayValue.value === "" || value !== Number(displayValue.value)) {
        displayValue.value = value.toFixed(precision.value);
      }
    }
  }
  function updateModelValueFromDisplayValue() {
    const { value: strVal } = displayValue;
    const numberVal = parseFloat(Number(strVal).toFixed(precision.value));
    if (strVal === "") {
      updateModelValue(null);
    } else if (Number.isNaN(numberVal)) {
      updateDisplayValueFromAccessor();
    } else {
      const newVal = Math.max(props.min, Math.min(props.max, numberVal));
      displayValue.value = newVal.toFixed(precision.value);
      updateModelValue(newVal);
    }
  }
  function updateModelValue(newVal) {
    const oldVal = toRaw(accessor.valueRef.value);
    if (newVal !== oldVal) {
      accessor.setValue(newVal);
      callEmit(props.onChange, newVal, oldVal);
      nextTick(() => {
        if (newVal !== accessor.valueRef.value) {
          updateDisplayValueFromAccessor();
        }
      });
    }
  }
  function handleInput(evt) {
    const { value: inputVal } = evt.target;
    const strVal = inputVal.trim().replace(//g, ".");
    displayValue.value = strVal;
    if (strVal === "") {
      updateModelValue(null);
      return;
    }
    const numberVal = Number(strVal);
    if (!Number.isNaN(numberVal)) {
      if (numberVal >= props.min && numberVal <= props.max) {
        updateModelValue(numberVal);
      }
    }
  }
  function handleDec() {
    if (props.readonly || isDisabled.value || disabledDec.value) {
      return;
    }
    const newVal = getIncValueFormAccessor(-props.step);
    updateModelValue(newVal);
  }
  function handleInc() {
    if (props.readonly || isDisabled.value || disabledInc.value) {
      return;
    }
    const newVal = getIncValueFormAccessor(props.step);
    updateModelValue(newVal);
  }
  function handleKeyDown(evt) {
    if (isKeyboard.value) {
      if (evt.code === "Enter" || evt.code === "NumpadEnter") {
        updateModelValueFromDisplayValue();
      } else if (evt.code === "ArrowUp") {
        evt.preventDefault();
        handleInc();
      } else if (evt.code === "ArrowDown") {
        evt.preventDefault();
        handleDec();
      }
    }
  }
  const isFocused = ref(false);
  function handleFocus(evt) {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  }
  function handleBlur(evt) {
    isFocused.value = false;
    updateModelValueFromDisplayValue();
    callEmit(props.onBlur, evt);
    accessor.markAsBlurred();
  }
  watch(displayValue, (value) => {
    if (value !== "") {
      const numberVal = Number(value);
      isIllegal.value = Number.isNaN(numberVal) || numberVal < props.min || numberVal > props.max;
    } else {
      isIllegal.value = false;
    }
  }, { immediate: true });
  watch(accessor.valueRef, () => updateDisplayValueFromAccessor(), { immediate: true });
  return {
    displayValue,
    isIllegal,
    isDisabled,
    isFocused,
    nowValue,
    handleKeyDown,
    handleDec,
    handleInc,
    handleInput,
    handleFocus,
    handleBlur
  };
}
function getPrecision(value) {
  if (value === void 0 || value === null) {
    return 0;
  }
  const decimal = String(value).split(".")[1];
  return decimal ? decimal.length : 0;
}
var InputNumber = defineComponent({
  name: "IxInputNumber",
  props: inputNumberProps,
  setup(props, {
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const config = useGlobalConfig$1("inputNumber");
    const {
      displayValue,
      nowValue,
      isIllegal,
      isDisabled,
      isFocused,
      handleInput,
      handleFocus,
      handleBlur,
      handleKeyDown,
      handleDec,
      handleInc
    } = useInputNumber(props, config);
    const {
      elementRef,
      focus,
      blur
    } = useFormFocusMonitor({
      handleBlur,
      handleFocus
    });
    expose({
      focus,
      blur
    });
    const formContext = inject(FORM_TOKEN, null);
    const mergedPrefixCls = computed(() => `${common.prefixCls}-input-number`);
    const size = computed(() => {
      var _a, _b;
      return (_b = (_a = props.size) != null ? _a : formContext == null ? void 0 : formContext.size.value) != null ? _b : config.size;
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-illegal`]: isIllegal.value
      });
    });
    const inputRef = ref();
    onMounted(() => {
      elementRef.value = inputRef.value.getInputElement();
    });
    return () => {
      return createVNode(\u0275Input, {
        "class": classes.value,
        "ref": inputRef,
        "type": "text",
        "autocomplete": "off",
        "aria-valuemin": props.min,
        "aria-valuemax": props.max,
        "aria-valuenow": nowValue.value,
        "disabled": isDisabled.value,
        "focused": isFocused.value,
        "readonly": props.readonly,
        "placeholder": props.placeholder,
        "size": size.value,
        "value": displayValue.value,
        "onInput": handleInput,
        "onKeydown": handleKeyDown
      }, {
        addonBefore: () => createVNode("span", {
          "class": "ix-input-number-decrease",
          "role": "button",
          "onClick": handleDec
        }, [createVNode(IxIcon, {
          "name": "minus"
        }, null)]),
        addonAfter: () => createVNode("span", {
          "class": "ix-input-number-increase",
          "role": "button",
          "onClick": handleInc
        }, [createVNode(IxIcon, {
          "name": "plus"
        }, null)])
      });
    };
  }
});
const IxInputNumber = InputNumber;

const layoutProps = {};
const layoutHeaderProps = {};
const layoutContentProps = {};
const layoutFooterProps = {};
const layoutSiderProps = {
  collapsed: IxPropTypes.bool,
  breakpoint: IxPropTypes.oneOf(["xs", "sm", "md", "lg", "xl"]),
  "onUpdate:collapsed": IxPropTypes.emit()
};
var Layout = defineComponent({
  name: "IxLayout",
  props: layoutProps,
  setup(_, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout`);
    return () => {
      var _a;
      return createVNode("section", {
        "class": mergedPrefixCls.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var LayoutContent = defineComponent({
  name: "IxLayoutContent",
  props: layoutContentProps,
  setup(_, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout-content`);
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("main", {
        "class": `${prefixCls}`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var LayoutFooter = defineComponent({
  name: "IxLayoutFooter",
  props: layoutFooterProps,
  setup(_, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout-footer`);
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("footer", {
        "class": prefixCls
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var LayoutHeader = defineComponent({
  name: "IxLayoutHeader",
  props: layoutHeaderProps,
  setup(_, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout-header`);
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return createVNode("header", {
        "class": prefixCls
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var LayoutSider = defineComponent({
  name: "IxLayoutSider",
  props: layoutSiderProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout-sider`);
    const collapsed = useCollapsed(props);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-collapsed`]: collapsed.value
      });
    });
    return () => {
      var _a;
      return createVNode("aside", {
        "class": classes.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
const useCollapsed = (props) => {
  const [collapsed, setCollapsed] = useControlledProp(props, "collapsed", false);
  const breakpointIndex = computed(() => {
    const {
      breakpoint
    } = props;
    return breakpoint ? BREAKPOINTS_KEYS.indexOf(breakpoint) : -1;
  });
  const useBreakpoint = computed(() => breakpointIndex.value > -1);
  let stopBreakpoints;
  watch(useBreakpoint, (breakpoint) => {
    stopBreakpoints == null ? void 0 : stopBreakpoints();
    if (breakpoint) {
      const breakpoints = useSharedBreakpoints();
      stopBreakpoints = watchEffect(() => {
        const currBreakpointIndex = BREAKPOINTS_KEYS.findIndex((key) => breakpoints[key]);
        setCollapsed(currBreakpointIndex <= breakpointIndex.value);
      });
    }
  }, {
    immediate: true
  });
  return collapsed;
};
const IxLayout = Layout;
const IxLayoutContent = LayoutContent;
const IxLayoutFooter = LayoutFooter;
const IxLayoutHeader = LayoutHeader;
const IxLayoutSider = LayoutSider;

const loadingProps = {
  strokeWidth: IxPropTypes.number.def(4),
  radius: IxPropTypes.number.def(14),
  duration: IxPropTypes.number.def(2)
};
var Loading = defineComponent({
  name: "IxLoading",
  props: loadingProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-loading`);
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const {
        duration,
        strokeWidth,
        radius
      } = props;
      const animationDur = `${duration}s`;
      const viewBoxSize = radius * 2;
      const circleLength = Math.PI * 2 * radius;
      const fstArchLength = 0.23 * circleLength;
      const sndArchLength = 0.11 * circleLength;
      return createVNode("div", {
        "class": prefixCls,
        "role": "img",
        "aria-label": "loading"
      }, [createVNode("svg", {
        "class": `${prefixCls}-icon`,
        "viewBox": `0 0 ${viewBoxSize} ${viewBoxSize}`
      }, [createVNode("g", {
        "id": "loading-48",
        "fill": "none",
        "fill-rule": "evenodd",
        "transform": `rotate(-90,${radius},${radius})`
      }, [createVNode("circle", {
        "class": `${prefixCls}-snd-arch`,
        "cx": radius,
        "cy": radius,
        "r": radius - strokeWidth / 2,
        "stroke-width": strokeWidth,
        "stroke-linecap": "round",
        "stroke-dasharray": `${sndArchLength} ${circleLength + 1}`
      }, [createVNode("animate", {
        "attributeName": "stroke-dashoffset",
        "values": `${sndArchLength};${sndArchLength};${-circleLength}`,
        "dur": animationDur,
        "begin": "0s",
        "repeatCount": "indefinite",
        "calcMode": "spline",
        "keyTimes": "0;0.3333;1",
        "keySplines": "0 0 0 0;0.42 0 0.58 1;"
      }, null)]), createVNode("circle", {
        "class": `${prefixCls}-fst-arch`,
        "cx": radius,
        "cy": radius,
        "r": radius - strokeWidth / 2,
        "stroke-width": strokeWidth,
        "stroke-linecap": "round",
        "stroke-dasharray": `${fstArchLength} ${circleLength + 1}`
      }, [createVNode("animate", {
        "attributeName": "stroke-dashoffset",
        "values": `${fstArchLength};${fstArchLength};${-circleLength};${-circleLength}`,
        "dur": animationDur,
        "begin": "0s",
        "repeatCount": "indefinite",
        "calcMode": "spline",
        "keyTimes": "0;0.3333;0.7;1",
        "keySplines": "0 0 0 0;0.42 0 0.58 1;0 0 0 0"
      }, null)]), createVNode("circle", {
        "class": `${prefixCls}-bg-circle`,
        "cx": radius,
        "cy": radius,
        "r": radius - strokeWidth / 2,
        "stroke-width": strokeWidth,
        "stroke-linecap": "round",
        "stroke-dasharray": `${circleLength} ${circleLength + 1}`
      }, [createVNode("animate", {
        "attributeName": "stroke-dashoffset",
        "values": `${circleLength};0;${-circleLength};${-circleLength}`,
        "dur": animationDur,
        "begin": "0s",
        "repeatCount": "indefinite",
        "calcMode": "spline",
        "keyTimes": "0;0.3333;0.666;1",
        "keySplines": "0.6 0 0.4 1;0.6 0 0.4 1;0,0,0,0"
      }, null)])])])]);
    };
  }
});
const IxLoading = Loading;

const spinProps = {
  strokeWidth: IxPropTypes.number,
  radius: IxPropTypes.number,
  duration: IxPropTypes.number,
  spinning: IxPropTypes.bool.def(true),
  rotate: IxPropTypes.bool.def(true),
  icon: IxPropTypes.string,
  tip: IxPropTypes.string,
  tipAlign: IxPropTypes.oneOf(["horizontal", "vertical"]),
  size: IxPropTypes.oneOf(["lg", "md", "sm"])
};
const defaultStrokeWidth$1 = {
  sm: 3,
  md: 3,
  lg: 4
};
const defaultRadius = {
  sm: 14,
  md: 14,
  lg: 24
};
var Spin = defineComponent({
  name: "IxSpin",
  props: spinProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-spin`);
    const spinConfig = useGlobalConfig$1("spin");
    const {
      size,
      strokeWidth,
      radius
    } = useSize(props, spinConfig);
    const hasDefaultSlot = computed(() => hasSlot(slots));
    const mregedIcon = computed(() => {
      var _a;
      return (_a = props.icon) != null ? _a : spinConfig.icon;
    });
    const mergedTip = computed(() => {
      var _a;
      return (_a = props.tip) != null ? _a : spinConfig.tip;
    });
    const {
      spinnerClassName,
      containerClassName
    } = useClasses$5(props, spinConfig, size, hasDefaultSlot, mergedPrefixCls);
    const renderContent = () => {
      if (!slots.default) {
        return null;
      }
      return createVNode("div", {
        "class": containerClassName.value
      }, [slots.default()]);
    };
    const renderTip = () => {
      if (!mergedTip.value) {
        return null;
      }
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-spinner-tip`
      }, [mergedTip.value]);
    };
    const renderIcon = () => {
      const iconCls = `${mergedPrefixCls.value}-spinner-icon`;
      if (slots.icon) {
        return createVNode("div", {
          "class": iconCls
        }, [slots.icon()]);
      }
      if (mregedIcon.value) {
        const iconStyle = normalizeStyle(props.duration && {
          animationDuration: `${props.duration}s`
        });
        return createVNode("div", {
          "class": [iconCls, props.rotate && `${iconCls}--rotate`],
          "style": iconStyle
        }, [createVNode(IxIcon, {
          "name": mregedIcon.value
        }, null)]);
      }
      return createVNode("div", {
        "class": iconCls
      }, [createVNode(IxLoading, {
        "strokeWidth": strokeWidth.value,
        "radius": radius.value,
        "duration": props.duration
      }, null)]);
    };
    const renderSpinner = () => {
      if (!props.spinning) {
        return null;
      }
      return createVNode("div", {
        "class": spinnerClassName.value
      }, [renderIcon(), renderTip()]);
    };
    return () => createVNode("div", {
      "class": mergedPrefixCls.value
    }, [renderSpinner(), renderContent()]);
  }
});
const useSize = (props, config) => {
  const size = computed(() => {
    var _a;
    return (_a = props.size) != null ? _a : config.size;
  });
  const strokeWidth = computed(() => {
    var _a, _b, _c;
    return (_c = (_b = props.strokeWidth) != null ? _b : (_a = config.strokeWidth) == null ? void 0 : _a[size.value]) != null ? _c : defaultStrokeWidth$1[size.value];
  });
  const radius = computed(() => {
    var _a, _b, _c;
    return (_c = (_b = props.radius) != null ? _b : (_a = config.radius) == null ? void 0 : _a[size.value]) != null ? _c : defaultRadius[size.value];
  });
  return {
    size,
    strokeWidth,
    radius
  };
};
const useClasses$5 = (props, config, size, hasDefaultSlot, mergedPrefixCls) => {
  const prefixCls = mergedPrefixCls.value;
  const spinnerClassName = computed(() => {
    var _a;
    const tipAlign = (_a = props.tipAlign) != null ? _a : config.tipAlign;
    return normalizeClass([`${prefixCls}-spinner`, `${prefixCls}-spinner-tip-${tipAlign}`, `${prefixCls}-spinner-${size.value}`]);
  });
  const containerClassName = computed(() => {
    if (!hasDefaultSlot.value) {
      return [];
    }
    return normalizeClass([`${prefixCls}-container`, props.spinning ? `${prefixCls}-container-blur` : ""]);
  });
  return {
    spinnerClassName,
    containerClassName
  };
};
const IxSpin = Spin;

const listProps = {
  header: IxPropTypes.string,
  footer: IxPropTypes.string,
  loadMore: IxPropTypes.string,
  empty: IxPropTypes.string,
  borderless: IxPropTypes.bool,
  split: IxPropTypes.bool.def(true),
  loading: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  grid: IxPropTypes.object()
};
const listItemProps = {
  title: IxPropTypes.string,
  content: IxPropTypes.string,
  extra: IxPropTypes.string
};
const listWrapProps = {
  gutter: IxPropTypes.object(),
  isUseGrid: IxPropTypes.bool
};
const listItemWrapProps = {
  grid: IxPropTypes.object()
};
var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$3 = defineComponent({
  components: { IxRow },
  props: listWrapProps
});
const _hoisted_1$3 = { key: 1 };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IxRow = resolveComponent("IxRow");
  return _ctx.isUseGrid ? (openBlock(), createBlock(_component_IxRow, {
    key: 0,
    gutter: _ctx.gutter
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["gutter"])) : (openBlock(), createElementBlock("div", _hoisted_1$3, [
    renderSlot(_ctx.$slots, "default")
  ]));
}
var ListWrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$3]]);
const listToken = Symbol("list");
const _sfc_main$2 = defineComponent({
  name: "IxList",
  components: {
    ListWrap,
    IxSpin,
    IxButton,
    IxEmpty
  },
  props: listProps,
  emits: ["loadMore"],
  setup(props, { slots, emit }) {
    provide(listToken, computed(() => props.grid));
    const isUseGrid = computed(() => !!props.grid);
    const isShowEmpty = computed(() => !slots.default);
    const isShowLoadMore = computed(() => slots.loadMore || props.loadMore);
    const isShowHeader = computed(() => slots.header || props.header);
    const isShowFooter = computed(() => slots.footer || props.footer);
    const listConfig = useGlobalConfig$1("list");
    const classes = useClasses$4(props, listConfig);
    const loadMoreLoading = ref(false);
    const handleLoadMoreClick = () => {
      loadMoreLoading.value = true;
      const done = () => {
        loadMoreLoading.value = false;
      };
      emit("loadMore", done);
    };
    return {
      isUseGrid,
      isShowEmpty,
      isShowLoadMore,
      isShowHeader,
      isShowFooter,
      loadMoreLoading,
      handleLoadMoreClick,
      classes
    };
  }
});
const useClasses$4 = (props, listConfig) => {
  return computed(() => {
    var _a, _b;
    const borderless = (_a = props.borderless) != null ? _a : listConfig.borderless;
    const size = (_b = props.size) != null ? _b : listConfig.size;
    const split = props.split;
    return [
      `ix-list-${size}`,
      split ? "ix-list-split" : "",
      {
        "ix-list-border": !borderless
      }
    ];
  });
};
const _hoisted_1$2 = {
  key: 0,
  class: "ix-list-header"
};
const _hoisted_2$1 = { class: "ix-list-empty" };
const _hoisted_3$1 = {
  key: 0,
  class: "ix-list-loadMore"
};
const _hoisted_4 = {
  key: 1,
  class: "ix-list-footer"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_list_wrap = resolveComponent("list-wrap");
  const _component_IxEmpty = resolveComponent("IxEmpty");
  const _component_IxButton = resolveComponent("IxButton");
  const _component_IxSpin = resolveComponent("IxSpin");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["ix-list", _ctx.classes])
  }, [
    _ctx.isShowHeader ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
      renderSlot(_ctx.$slots, "header", {}, () => [
        createTextVNode(toDisplayString(_ctx.header), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    createVNode(_component_IxSpin, { spinning: _ctx.loading }, {
      default: withCtx(() => {
        var _a;
        return [
          createVNode(_component_list_wrap, {
            isUseGrid: _ctx.isUseGrid,
            gutter: (_a = _ctx.grid) == null ? void 0 : _a.gutter
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["isUseGrid", "gutter"]),
          withDirectives(createElementVNode("div", _hoisted_2$1, [
            renderSlot(_ctx.$slots, "empty", {}, () => [
              createVNode(_component_IxEmpty, { description: _ctx.empty }, null, 8, ["description"])
            ])
          ], 512), [
            [vShow, _ctx.isShowEmpty]
          ]),
          _ctx.isShowLoadMore ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
            renderSlot(_ctx.$slots, "loadMore", {}, () => [
              createVNode(_component_IxButton, {
                loading: _ctx.loadMoreLoading,
                onClick: _ctx.handleLoadMoreClick
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.loadMore), 1)
                ]),
                _: 1
              }, 8, ["loading", "onClick"])
            ])
          ])) : createCommentVNode("v-if", true)
        ];
      }),
      _: 3
    }, 8, ["spinning"]),
    _ctx.isShowFooter ? (openBlock(), createElementBlock("div", _hoisted_4, [
      renderSlot(_ctx.$slots, "footer", {}, () => [
        createTextVNode(toDisplayString(_ctx.footer), 1)
      ])
    ])) : createCommentVNode("v-if", true)
  ], 2);
}
var List = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1$1 = defineComponent({
  components: { IxCol },
  props: listItemWrapProps
});
const _hoisted_1$1 = {
  key: 0,
  class: "ix-list-item"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IxCol = resolveComponent("IxCol");
  return !_ctx.grid ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
    renderSlot(_ctx.$slots, "default")
  ])) : (openBlock(), createBlock(_component_IxCol, {
    key: 1,
    xs: _ctx.grid.xs,
    sm: _ctx.grid.sm,
    md: _ctx.grid.md,
    lg: _ctx.grid.lg,
    xl: _ctx.grid.xl
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["xs", "sm", "md", "lg", "xl"]));
}
var ListItemWrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$1$1, [["render", _sfc_render$1]]);
const _sfc_main$4 = defineComponent({
  name: "IxListItem",
  components: { ListItemWrap },
  props: listItemProps,
  setup() {
    const listGrid = inject(listToken, null);
    const gird = (listGrid == null ? void 0 : listGrid.value) && useGrid(listGrid == null ? void 0 : listGrid.value);
    return { gird };
  }
});
const getGrid = (grid, dim) => {
  const v = grid[dim];
  if (typeof v === "number") {
    return Math.floor(24 / v);
  }
  return void 0;
};
const useGrid = (grid) => {
  const defaultSpan = getGrid(grid, "column");
  const xsSpan = getGrid(grid, "xs");
  const smSpan = getGrid(grid, "sm");
  const mdSpan = getGrid(grid, "md");
  const lgSpan = getGrid(grid, "lg");
  const xlSpan = getGrid(grid, "xl");
  return {
    xs: xsSpan || defaultSpan,
    sm: smSpan || defaultSpan,
    md: mdSpan || defaultSpan,
    ld: lgSpan || defaultSpan,
    xl: xlSpan || defaultSpan
  };
};
const _hoisted_1$4 = { class: "ix-list-item-title" };
const _hoisted_2$2 = { class: "ix-list-item-content" };
const _hoisted_3$2 = { class: "ix-list-item-extra" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_list_item_wrap = resolveComponent("list-item-wrap");
  return openBlock(), createBlock(_component_list_item_wrap, { grid: _ctx.gird }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$4, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ]),
      createElementVNode("div", _hoisted_2$2, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(_ctx.content), 1)
        ])
      ]),
      createElementVNode("div", _hoisted_3$2, [
        renderSlot(_ctx.$slots, "extra", {}, () => [
          createTextVNode(toDisplayString(_ctx.extra), 1)
        ])
      ])
    ]),
    _: 3
  }, 8, ["grid"]);
}
var ListItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["render", _sfc_render$4]]);
const IxList = List;
const IxListItem = ListItem;

const itemKey = "__IDUX_MENU_ITEM";
const MenuItem$1 = () => {
};
MenuItem$1.displayName = "IxMenuItem";
MenuItem$1[itemKey] = true;
const itemGroupKey = "__IDUX_MENU_ITEM_GROUP";
const MenuGroupItem = () => {
};
MenuGroupItem.displayName = "IxMenuItemGroup";
MenuGroupItem[itemGroupKey] = true;
const subKey = "__IDUX_MENU_SUB";
const MenuSub$1 = () => {
};
MenuSub$1.displayName = "IxMenuSub";
MenuSub$1[subKey] = true;
const dividerKey = "__IDUX_MENU_DIVIDER";
const MenuDivider$1 = () => {
};
MenuDivider$1.displayName = "IxMenuDivider";
MenuDivider$1[dividerKey] = true;
var __getOwnPropSymbols$2$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$5 = Object.prototype.propertyIsEnumerable;
var __objRest$9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2$5)
    for (var prop of __getOwnPropSymbols$2$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useDataSource$1(props, slots) {
  return computed(() => {
    var _a;
    const { dataSource } = props;
    if (dataSource) {
      return dataSource;
    } else {
      return convertDataSource((_a = slots.default) == null ? void 0 : _a.call(slots));
    }
  });
}
const filterKeys$1 = [itemKey, itemGroupKey, subKey, dividerKey];
function convertDataSource(nodes) {
  const dataSource = [];
  flattenNode(nodes, { key: filterKeys$1 }).forEach((node) => {
    var _a, _b, _e, _g;
    const type = node.type;
    const slots = (_a = node.children) != null ? _a : {};
    const props = (_b = node.props) != null ? _b : {};
    let data;
    if (type[itemKey]) {
      const _c = props, { key, disabled, icon, label } = _c, additional = __objRest$9(_c, ["key", "disabled", "icon", "label"]);
      const { icon: customIcon, label: customLabel, default: customLabel2 } = slots;
      data = {
        key,
        disabled: disabled || disabled === "",
        icon,
        label,
        additional,
        customIcon,
        customLabel: customLabel != null ? customLabel : customLabel2
      };
    } else if (type[itemGroupKey]) {
      const _d = props, { key, children, icon, label } = _d, additional = __objRest$9(_d, ["key", "children", "icon", "label"]);
      const { icon: customIcon, label: customLabel } = slots;
      data = {
        type: "itemGroup",
        key,
        children: children != null ? children : convertDataSource((_e = slots.default) == null ? void 0 : _e.call(slots)),
        icon,
        label,
        additional,
        customIcon,
        customLabel
      };
    } else if (type[subKey]) {
      const _f = props, { key, children, disabled, icon, label, suffix } = _f, additional = __objRest$9(_f, ["key", "children", "disabled", "icon", "label", "suffix"]);
      const { icon: customIcon, label: customLabel, suffix: customSuffix } = slots;
      data = {
        type: "sub",
        key,
        children: children != null ? children : convertDataSource((_g = slots.default) == null ? void 0 : _g.call(slots)),
        disabled: disabled || disabled === "",
        icon,
        label,
        additional,
        customIcon,
        customLabel,
        customSuffix
      };
    } else {
      const _h = props, { key } = _h, additional = __objRest$9(_h, ["key"]);
      data = { type: "divider", key, additional };
    }
    if (process.env.NODE_ENV !== "production" && data.type !== "divider" && !data.key) {
      Logger.warn("components/menu", "key must exist", data);
    }
    dataSource.push(data);
  });
  return dataSource;
}
function useExpanded$1(props) {
  const [expandedKeys, setExpandedKeys] = useControlledProp(props, "expandedKeys", () => []);
  const handleExpand = (key, expanded) => {
    const index = expandedKeys.value.indexOf(key);
    if (expanded) {
      index === -1 && setExpandedKeys([...expandedKeys.value, key]);
    } else {
      if (index > -1) {
        const tempKeys = [...expandedKeys.value];
        tempKeys.splice(index, 1);
        setExpandedKeys(tempKeys);
      }
    }
  };
  watch(() => props.collapsed, (collapsed) => {
    if (collapsed) {
      setExpandedKeys([]);
    }
  });
  return { expandedKeys, handleExpand };
}
function useSelected(props, dropdownContext) {
  const [selectedKeys, setSelectedKeys] = useControlledProp(props, "selectedKeys", () => []);
  const handleSelected = (key) => {
    if (dropdownContext) {
      const { hideOnClick, setVisibility } = dropdownContext;
      hideOnClick.value && setVisibility(false);
    }
    if (!props.selectable) {
      return;
    }
    const index = selectedKeys.value.indexOf(key);
    if (index > -1) {
      if (props.multiple) {
        const tempKeys = [...selectedKeys.value];
        tempKeys.splice(index, 1);
        setSelectedKeys(tempKeys);
      }
    } else {
      setSelectedKeys(props.multiple ? [...selectedKeys.value, key] : [key]);
    }
  };
  return { selectedKeys, handleSelected };
}
const menuToken = Symbol("menuToken");
const menuSubToken = Symbol("menuSubToken");
const menuItemGroupToken = Symbol("menuItemGroupToken");
const MenuDivider = () => {
  const {
    mergedPrefixCls
  } = inject(menuToken);
  return createVNode("li", {
    "class": `${mergedPrefixCls.value}-divider`
  }, null);
};
MenuDivider.displayName = "MenuDivider";
const usePaddingLeft = (mode, indent, level, grouped) => {
  return computed(() => {
    if (mode.value !== "inline") {
      return void 0;
    }
    const groupedLeft = grouped ? 8 : 0;
    return `${indent.value * level + groupedLeft}px`;
  });
};
const menuProps = {
  expandedKeys: IxPropTypes.arrayOf(IxPropTypes.oneOfType([String, Number, Symbol])),
  selectedKeys: IxPropTypes.arrayOf(IxPropTypes.oneOfType([String, Number, Symbol])),
  collapsed: IxPropTypes.bool.def(false),
  dataSource: IxPropTypes.array(),
  indent: IxPropTypes.number,
  mode: IxPropTypes.oneOf(["vertical", "horizontal", "inline"]).def("vertical"),
  multiple: IxPropTypes.bool.def(false),
  selectable: IxPropTypes.bool.def(true),
  target: portalTargetDef,
  theme: IxPropTypes.oneOf(["light", "dark"]),
  overlayClassName: IxPropTypes.string,
  "onUpdate:expandedKeys": IxPropTypes.emit(),
  "onUpdate:selectedKeys": IxPropTypes.emit(),
  onClick: IxPropTypes.emit()
};
const menuItemProps = {
  data: IxPropTypes.object().isRequired
};
const menuItemGroupProps = {
  data: IxPropTypes.object().isRequired
};
const menuSubProps = {
  data: IxPropTypes.object().isRequired
};
var __defProp$1$7 = Object.defineProperty;
var __defProps$1$3 = Object.defineProperties;
var __getOwnPropDescs$1$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$a = Object.getOwnPropertySymbols;
var __hasOwnProp$1$a = Object.prototype.hasOwnProperty;
var __propIsEnum$1$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$7 = (obj, key, value) => key in obj ? __defProp$1$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$a.call(b, prop))
      __defNormalProp$1$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$a)
    for (var prop of __getOwnPropSymbols$1$a(b)) {
      if (__propIsEnum$1$a.call(b, prop))
        __defNormalProp$1$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$3 = (a, b) => __defProps$1$3(a, __getOwnPropDescs$1$3(b));
var MenuItem = defineComponent({
  name: "MenuItem",
  props: menuItemProps,
  setup(props) {
    const key = useKey();
    const {
      slots: menuSlots,
      mergedPrefixCls,
      indent,
      mode,
      selectedKeys,
      handleSelected,
      handleClick
    } = inject(menuToken);
    const menuSubContext = inject(menuSubToken, null);
    const menuItemGroupContext = inject(menuItemGroupToken, false);
    const isSelected = computed(() => selectedKeys.value.includes(key));
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-item`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.data.disabled,
        [`${prefixCls}-selected`]: isSelected.value
      });
    });
    const level = menuSubContext ? menuSubContext.level + 1 : 1;
    const paddingLeft = usePaddingLeft(mode, indent, level, menuItemGroupContext);
    const style = computed(() => {
      return {
        paddingLeft: paddingLeft.value
      };
    });
    const onClick = (evt) => {
      evt.stopPropagation();
      handleSelected(key);
      handleClick(key, "item", evt);
      menuSubContext == null ? void 0 : menuSubContext.handleItemClick();
    };
    return () => {
      var _a, _b;
      const {
        additional,
        disabled,
        icon,
        label,
        slots = {},
        customIcon,
        customLabel
      } = props.data;
      if (process.env.NODE_ENV !== "production" && (slots.icon || slots.label)) {
        Logger.warn("components/menu", "`slots` of `MenuItem` was deprecated, please use `customIcon` and `customLabel` instead");
      }
      const iconRender = (_a = customIcon != null ? customIcon : slots.icon) != null ? _a : "itemIcon";
      const iconSlot = isString(iconRender) ? menuSlots[iconRender] : iconRender;
      const labelRender = (_b = customLabel != null ? customLabel : slots.label) != null ? _b : "itemLabel";
      const labelSlot = isString(labelRender) ? menuSlots[labelRender] : labelRender;
      const slotProps = iconSlot || labelSlot ? __spreadProps$1$3(__spreadValues$1$7({}, props.data), {
        selected: isSelected.value
      }) : void 0;
      const iconNode = coverIcon(iconSlot, slotProps, icon);
      const labelNode = labelSlot ? labelSlot(slotProps) : label;
      return createVNode("li", mergeProps({
        "class": classes.value,
        "style": style.value
      }, additional, {
        "onClick": disabled ? void 0 : onClick
      }), [iconNode, createVNode("span", null, [labelNode])]);
    };
  }
});
var MenuItemGroup = defineComponent({
  name: "MenuItemGroup",
  props: menuItemGroupProps,
  setup(props) {
    const key = useKey();
    provide(menuItemGroupToken, true);
    const {
      slots: menuSlots,
      mergedPrefixCls,
      mode,
      indent,
      handleClick
    } = inject(menuToken);
    const menuSubContext = inject(menuSubToken, null);
    const menuItemGroupContext = inject(menuItemGroupToken, null);
    const level = menuSubContext ? menuSubContext.level + 1 : 1;
    const paddingLeft = usePaddingLeft(mode, indent, level, !!menuItemGroupContext);
    const labelStyle = computed(() => ({
      paddingLeft: paddingLeft.value
    }));
    const onClick = (evt) => {
      evt.stopPropagation();
      handleClick(key, "itemGroup", evt);
    };
    return () => {
      var _a, _b;
      const {
        additional,
        icon,
        label,
        children,
        slots = {},
        customIcon,
        customLabel
      } = props.data;
      if (process.env.NODE_ENV !== "production" && (slots.icon || slots.label)) {
        Logger.warn("components/menu", "`slots` of `MenuItemGroup` was deprecated, please use `customIcon` and `customLabel` instead");
      }
      const iconRender = (_a = customIcon != null ? customIcon : slots.icon) != null ? _a : "itemGroupIcon";
      const iconSlot = isString(iconRender) ? menuSlots[iconRender] : iconRender;
      const labelRender = (_b = customLabel != null ? customLabel : slots.label) != null ? _b : "itemGroupLabel";
      const labelSlot = isString(labelRender) ? menuSlots[labelRender] : labelRender;
      const slotProps = props.data;
      const iconNode = coverIcon(iconSlot, slotProps, icon);
      const labelNode = labelSlot ? labelSlot(slotProps) : label;
      const prefixCls = `${mergedPrefixCls.value}-item-group`;
      return createVNode("li", mergeProps({
        "class": prefixCls
      }, additional, {
        "onClick": onClick
      }), [createVNode("div", {
        "class": `${prefixCls}-label`,
        "style": labelStyle.value
      }, [iconNode, createVNode("span", null, [labelNode])]), createVNode("ul", {
        "class": `${prefixCls}-content`
      }, [coverChildren(children)])]);
    };
  }
});
var InlineContent = defineComponent({
  name: "MenuSubInlineContent",
  setup() {
    const {
      mergedPrefixCls
    } = inject(menuToken);
    const {
      props,
      isExpanded
    } = inject(menuSubToken);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-inline`]: true
      });
    });
    return () => {
      return createVNode(\u0275CollapseTransition, {
        "appear": true
      }, {
        default: () => [withDirectives(createVNode("ul", {
          "class": classes.value
        }, [coverChildren(props.data.children)]), [[vShow, isExpanded.value]])]
      });
    };
  }
});
var __defProp$i = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
var Label = defineComponent({
  name: "MenuSubLabel",
  setup() {
    const {
      slots: menuSlots,
      config,
      mergedPrefixCls
    } = inject(menuToken);
    const {
      props,
      isExpanded,
      isSelected,
      changeExpanded,
      handleMouseEvent,
      mode,
      paddingLeft
    } = inject(menuSubToken);
    const suffix = computed(() => {
      var _a;
      return (_a = props.data.suffix) != null ? _a : config.suffix;
    });
    const rotate = computed(() => {
      if (mode.value === "inline") {
        return isExpanded.value ? -90 : 90;
      }
      return 0;
    });
    const events = computed(() => {
      if (props.data.disabled) {
        return void 0;
      }
      if (mode.value === "inline") {
        return {
          onClick: () => changeExpanded(!isExpanded.value)
        };
      } else {
        return {
          onMouseenter: () => handleMouseEvent(true),
          onMouseleave: () => handleMouseEvent(false)
        };
      }
    });
    const style = computed(() => {
      return {
        paddingLeft: paddingLeft.value
      };
    });
    return () => {
      var _a, _b, _c;
      const {
        icon,
        label,
        slots = {},
        customIcon,
        customLabel,
        customSuffix
      } = props.data;
      if (process.env.NODE_ENV !== "production" && (slots.icon || slots.label || slots.suffix)) {
        Logger.warn("components/menu", "`slots` of `MenuSub` was deprecated, please use `customIcon`, `customLabel` and `customSuffix` instead");
      }
      const iconRender = (_a = customIcon != null ? customIcon : slots.icon) != null ? _a : "subIcon";
      const iconSlot = isString(iconRender) ? menuSlots[iconRender] : iconRender;
      const labelRender = (_b = customLabel != null ? customLabel : slots.label) != null ? _b : "subLabel";
      const labelSlot = isString(labelRender) ? menuSlots[labelRender] : labelRender;
      const suffixRender = (_c = customSuffix != null ? customSuffix : slots.suffix) != null ? _c : "subSuffix";
      const suffixSlot = isString(suffixRender) ? menuSlots[suffixRender] : suffixRender;
      const slotProps = iconSlot || labelSlot || suffixSlot ? __spreadProps$e(__spreadValues$i({}, props.data), {
        expanded: isExpanded.value,
        selected: isSelected.value
      }) : void 0;
      const iconNode = coverIcon(iconSlot, slotProps, icon);
      const labelNode = labelSlot ? labelSlot(slotProps) : label;
      const suffixNode = coverIcon(suffixSlot, slotProps, suffix.value, rotate.value);
      const prefixCls = `${mergedPrefixCls.value}-sub-label`;
      return createVNode("div", mergeProps({
        "class": prefixCls,
        "style": style.value
      }, events.value), [iconNode, createVNode("span", null, [labelNode]), suffixNode && createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [suffixNode])]);
    };
  }
});
var OverlayContent = defineComponent({
  name: "MenuSubOverlayContent",
  setup() {
    const {
      mergedPrefixCls,
      theme
    } = inject(menuToken);
    const {
      props,
      handleMouseEvent
    } = inject(menuSubToken);
    const dropdownContext = inject(dropdownToken, null);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-dropdown`]: !!dropdownContext,
        [`${prefixCls}-vertical`]: true,
        [`${prefixCls}-${theme.value}`]: true
      });
    });
    const events = computed(() => {
      if (props.data.disabled) {
        return void 0;
      }
      return {
        onMouseenter: () => handleMouseEvent(true),
        onMouseleave: () => handleMouseEvent(false)
      };
    });
    return () => createVNode("ul", mergeProps({
      "class": classes.value
    }, events.value), [coverChildren(props.data.children)]);
  }
});
const defaultDelay = [0, 100];
var MenuSub = defineComponent({
  name: "MenuSub",
  props: menuSubProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const mergedTransitionName = computed(() => `${common.prefixCls}-fade`);
    const {
      props: menuProps2,
      config,
      mergedPrefixCls,
      indent,
      mode: menuMode,
      selectedKeys,
      expandedKeys,
      handleExpand,
      handleClick
    } = inject(menuToken);
    const menuSubContext = inject(menuSubToken, null);
    const menuItemGroupContext = inject(menuItemGroupToken, false);
    const key = useKey();
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = menuProps2.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-overlay-container`;
    });
    const mode = useMode(menuMode, menuSubContext);
    const level = menuSubContext ? menuSubContext.level + 1 : 1;
    const paddingLeft = usePaddingLeft(mode, indent, level, menuItemGroupContext);
    const isSelected = computed(() => getState(props.data.children, selectedKeys.value));
    const {
      isExpanded,
      changeExpanded,
      handleMouseEvent
    } = useExpanded(props, key, expandedKeys, handleExpand, mode);
    const handleItemClick = () => {
      if (!props.data.disabled && mode.value !== "inline" && !menuProps2.multiple) {
        handleExpand(key, false);
      }
    };
    provide(menuSubToken, {
      props,
      isExpanded,
      isSelected,
      mode,
      level,
      paddingLeft,
      changeExpanded,
      handleMouseEvent,
      handleItemClick
    });
    const placement = computed(() => mode.value === "vertical" ? "rightStart" : "bottomStart");
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-sub`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.data.disabled,
        [`${prefixCls}-expanded`]: isExpanded.value,
        [`${prefixCls}-selected`]: isSelected.value,
        [`${prefixCls}-${mode.value}`]: true
      });
    });
    const overlayClasses = computed(() => {
      const {
        overlayClassName
      } = menuProps2;
      return normalizeClass({
        [`${mergedPrefixCls.value}-overlay`]: true,
        [overlayClassName || ""]: !!overlayClassName
      });
    });
    const offset = computed(() => {
      var _a;
      return (_a = props.data.offset) != null ? _a : config.offset;
    });
    const onClick = (evt) => {
      evt.stopPropagation();
      handleClick(key, "sub", evt);
    };
    return () => {
      const {
        additional,
        disabled
      } = props.data;
      let children;
      if (mode.value === "inline") {
        children = [createVNode(Label, null, null), createVNode(InlineContent, null, null)];
      } else {
        const trigger = () => createVNode(Label, null, null);
        const content = () => createVNode(OverlayContent, null, null);
        children = createVNode(\u0275Overlay, {
          "visible": isExpanded.value,
          "class": overlayClasses.value,
          "autoAdjust": true,
          "destroyOnHide": false,
          "delay": defaultDelay,
          "disabled": disabled,
          "offset": offset.value,
          "placement": placement.value,
          "target": target.value,
          "transitionName": mergedTransitionName.value,
          "trigger": "manual"
        }, {
          default: trigger,
          content
        });
      }
      return createVNode("li", mergeProps({
        "class": classes.value
      }, additional, {
        "onClick": disabled ? void 0 : onClick
      }), [children]);
    };
  }
});
function useMode(menuMode, menuSubContext) {
  const currMode = menuMode.value;
  const defaultMode = currMode !== "inline" && !!menuSubContext ? "vertical" : currMode;
  const [mode, setMode] = useState$1(defaultMode);
  watch(menuMode, (mode2) => {
    nextTick(() => setMode(mode2 !== "inline" && !!menuSubContext ? "vertical" : mode2));
  });
  return mode;
}
function useExpanded(props, key, expandedKeys, handleExpand, mode) {
  const isHover = ref(false);
  const isExpanded = computed(() => {
    if (mode.value === "inline") {
      return expandedKeys.value.includes(key);
    }
    return isHover.value && expandedKeys.value.includes(key) || childExpanded.value;
  });
  const changeExpanded = (expanded) => handleExpand(key, expanded);
  const childExpanded = computed(() => getState(props.data.children, expandedKeys.value));
  const handleMouseEvent = debounce$1((value) => isHover.value = value, 100);
  watch([mode, childExpanded, isHover], ([currMode, currChildExpanded, currIsHover]) => {
    if (currMode !== "inline") {
      changeExpanded(currChildExpanded || currIsHover);
    }
  });
  return {
    isExpanded,
    changeExpanded,
    handleMouseEvent
  };
}
function getState(children, selectedKeys) {
  if (!children || children.length === 0) {
    return false;
  }
  return children.some((item) => {
    return item.key && selectedKeys.includes(item.key) || "children" in item && getState(item.children, selectedKeys);
  });
}
function coverChildren(data) {
  if (!data || data.length === 0) {
    return [];
  }
  const nodes = [];
  data.forEach((item) => {
    const {
      type
    } = item;
    if (!type || type === "item") {
      nodes.push(createVNode(MenuItem, {
        "key": item.key,
        "data": item
      }, null));
    } else if (type === "sub") {
      nodes.push(createVNode(MenuSub, {
        "key": item.key,
        "data": item
      }, null));
    } else if (type === "itemGroup") {
      nodes.push(createVNode(MenuItemGroup, {
        "key": item.key,
        "data": item
      }, null));
    } else if (type === "divider") {
      nodes.push(createVNode(MenuDivider, mergeProps({
        "key": item.key
      }, item.additional), null));
    } else {
      process.env.NODE_ENV !== "production" && Logger.warn("components/menu", `type [${type}] not supported`);
    }
  });
  return nodes;
}
function coverIcon(slot, slotProps, iconOrName, rotate) {
  if (slot) {
    return slot(slotProps);
  }
  return isString(iconOrName) ? createVNode(IxIcon, {
    "name": iconOrName,
    "rotate": rotate
  }, null) : iconOrName;
}
var Menu = defineComponent({
  name: "IxMenu",
  props: menuProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-menu`);
    const config = useGlobalConfig$1("menu");
    const indent = computed(() => {
      var _a;
      return (_a = props.indent) != null ? _a : config.indent;
    });
    const mode = computed(() => {
      const {
        collapsed,
        mode: mode2
      } = props;
      return collapsed && mode2 !== "horizontal" ? "vertical" : mode2;
    });
    const theme = computed(() => {
      var _a;
      return (_a = props.theme) != null ? _a : config.theme;
    });
    const dropdownContext = inject(dropdownToken, null);
    const {
      expandedKeys,
      handleExpand
    } = useExpanded$1(props);
    const {
      selectedKeys,
      handleSelected
    } = useSelected(props, dropdownContext);
    const handleClick = (key, type, evt) => {
      callEmit(props.onClick, {
        key,
        type,
        event: evt
      });
    };
    provide(menuToken, {
      props,
      slots,
      config,
      mergedPrefixCls,
      indent,
      mode,
      theme,
      expandedKeys,
      handleExpand,
      selectedKeys,
      handleSelected,
      handleClick
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${theme.value}`]: true,
        [`${prefixCls}-${mode.value}`]: true,
        [`${prefixCls}-collapsed`]: props.collapsed,
        [`${prefixCls}-dropdown`]: !!dropdownContext
      });
    });
    const dateSource = useDataSource$1(props, slots);
    return () => {
      return createVNode("ul", {
        "class": classes.value
      }, [coverChildren(dateSource.value)]);
    };
  }
});
const IxMenu = Menu;
const IxMenuDivider = MenuDivider$1;
const IxMenuItem = MenuItem$1;
const IxMenuItemGroup = MenuGroupItem;
const IxMenuSub = MenuSub$1;

const messageProps = {
  visible: IxPropTypes.bool,
  destroyOnHover: IxPropTypes.bool,
  duration: IxPropTypes.number,
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  type: IxPropTypes.oneOf(["info", "success", "warning", "error", "loading"]).def("info"),
  "onUpdate:visible": IxPropTypes.emit(),
  onClose: IxPropTypes.emit()
};
const messageProviderProps = {
  maxCount: IxPropTypes.number,
  top: IxPropTypes.oneOfType([String, Number]),
  target: portalTargetDef
};
var Message = defineComponent({
  name: "IxMessage",
  props: messageProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-message`);
    const config = useGlobalConfig$1("message");
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return [prefixCls, `${prefixCls}-${props.type}`];
    });
    const mergedIcon = computed(() => {
      const {
        icon,
        type
      } = props;
      return icon != null ? icon : config.icon[type];
    });
    const {
      visible,
      onMouseEnter,
      onMouseLeave
    } = useEvents$3(props, config);
    return () => {
      var _a;
      const icon = mergedIcon.value;
      const iconNode = isString(icon) ? createVNode(IxIcon, {
        "name": icon
      }, null) : icon;
      const prefixCls = mergedPrefixCls.value;
      return withDirectives(createVNode("div", {
        "class": classes.value,
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave
      }, [createVNode("div", {
        "class": `${prefixCls}-content`
      }, [createVNode("span", {
        "class": `${prefixCls}-content-icon`
      }, [iconNode]), createVNode("span", {
        "class": `${prefixCls}-content-text`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])])]), [[vShow, visible.value]]);
    };
  }
});
const useEvents$3 = (props, config) => {
  const duration = computed(() => {
    var _a;
    return (_a = props.duration) != null ? _a : config.duration;
  });
  const destroyOnHover = computed(() => {
    var _a;
    return (_a = props.destroyOnHover) != null ? _a : config.destroyOnHover;
  });
  const autoClose = computed(() => duration.value > 0);
  const [visible, setVisible] = useControlledProp(props, "visible", false);
  let timer = null;
  const startTimer = () => {
    timer = setTimeout(() => close(), duration.value);
  };
  const clearTimer = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  const close = () => {
    clearTimer();
    setVisible(false);
    callEmit(props.onClose);
  };
  const onMouseEnter = () => {
    if (autoClose.value && !destroyOnHover.value) {
      clearTimer();
    }
  };
  const onMouseLeave = () => {
    if (autoClose.value && !destroyOnHover.value) {
      startTimer();
    }
  };
  onMounted(() => {
    watchEffect(() => {
      clearTimer();
      if (visible.value && autoClose.value) {
        startTimer();
      }
    });
  });
  onBeforeUnmount(() => clearTimer());
  return {
    visible,
    onMouseEnter,
    onMouseLeave
  };
};
const messageProviderToken = Symbol("messageProviderToken");
var __defProp$h = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
var __objRest$8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var MessageProvider = defineComponent({
  name: "IxMessageProvider",
  inheritAttrs: false,
  props: messageProviderProps,
  setup(props, {
    expose,
    slots,
    attrs
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-message`);
    const config = useGlobalConfig$1("message");
    const style = computed(() => {
      var _a;
      return {
        top: convertCssPixel((_a = props.top) != null ? _a : config.top)
      };
    });
    const maxCount = computed(() => {
      var _a;
      return (_a = props.maxCount) != null ? _a : config.maxCount;
    });
    const {
      messages,
      loadContainer,
      open,
      info,
      success,
      warning,
      error,
      loading,
      update,
      destroy,
      destroyAll
    } = useMessage$1(maxCount);
    const apis = {
      open,
      info,
      success,
      warning,
      error,
      loading,
      update,
      destroy,
      destroyAll
    };
    provide(messageProviderToken, apis);
    expose(apis);
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-container`;
    });
    return () => {
      var _a;
      const child = messages.value.map((item) => {
        const _a2 = item, {
          key,
          content,
          visible = true,
          onDestroy
        } = _a2, restProps = __objRest$8(_a2, [
          "key",
          "content",
          "visible",
          "onDestroy"
        ]);
        const onClose = () => destroy(key);
        const mergedProps = {
          key,
          visible,
          onClose
        };
        return createVNode(Message, mergeProps(mergedProps, restProps), {
          default: () => [content]
        });
      });
      return createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots), createVNode(CdkPortal, {
        "target": target.value,
        "load": loadContainer.value
      }, {
        default: () => [createVNode(TransitionGroup, mergeProps({
          "tag": "div",
          "appear": true,
          "name": `${common.prefixCls}-move-up`,
          "class": `${mergedPrefixCls.value}-wrapper`,
          "style": style.value
        }, attrs), {
          default: () => [child]
        })]
      })]);
    };
  }
});
const useMessage$1 = (maxCount) => {
  const messages = ref([]);
  const getCurrIndex = (key) => {
    return messages.value.findIndex((message) => message.key === key);
  };
  const add = (item) => {
    var _a;
    const currIndex = item.key ? getCurrIndex(item.key) : -1;
    if (currIndex !== -1) {
      messages.value.splice(currIndex, 1, item);
      return item.key;
    }
    if (messages.value.length >= maxCount.value) {
      messages.value = messages.value.slice(-maxCount.value + 1);
    }
    const key = (_a = item.key) != null ? _a : uniqueId("ix-message");
    messages.value.push(__spreadProps$d(__spreadValues$h({}, item), {
      key
    }));
    return key;
  };
  const update = (key, item) => {
    const currIndex = getCurrIndex(key);
    if (currIndex !== -1) {
      const newItem = __spreadValues$h(__spreadValues$h({}, messages.value[currIndex]), item);
      messages.value.splice(currIndex, 1, newItem);
    }
  };
  const destroy = (key) => {
    const keys = convertArray(key);
    keys.forEach((key2) => {
      const currIndex = getCurrIndex(key2);
      if (currIndex !== -1) {
        const item = messages.value.splice(currIndex, 1);
        callEmit(item[0].onDestroy, key2);
      }
    });
  };
  const destroyAll = () => {
    messages.value = [];
  };
  const loadContainer = ref(false);
  const open = (options) => {
    const key = add(options);
    const ref2 = {
      key,
      update: (options2) => update(key, options2),
      destroy: () => destroy(key)
    };
    if (!loadContainer.value) {
      loadContainer.value = true;
    }
    return ref2;
  };
  const messageTypes = ["info", "success", "warning", "error", "loading"];
  const [info, success, warning, error, loading] = messageTypes.map((type) => {
    return (content, options) => open(__spreadProps$d(__spreadValues$h({}, options), {
      content,
      type
    }));
  });
  return {
    messages,
    loadContainer,
    open,
    info,
    success,
    warning,
    error,
    loading,
    update,
    destroy,
    destroyAll
  };
};
const IxMessage = Message;
const IxMessageProvider = MessageProvider;

const modalToken = Symbol("modalToken");
const modalProviderToken = Symbol("modalProviderToken");
const MODAL_TOKEN = Symbol("MODAL_TOKEN");
const defaultIconTypes = {
  default: "",
  confirm: "question-circle-filled",
  info: "info-circle-filled",
  success: "check-circle-filled",
  warning: "exclamation-circle-filled",
  error: "close-circle-filled"
};
var ModalBody = defineComponent({
  setup() {
    const {
      props,
      slots,
      config,
      mergedPrefixCls
    } = inject(modalToken);
    const isDefault = computed(() => props.type === "default");
    const iconName = computed(() => {
      var _a, _b;
      const {
        icon,
        type
      } = props;
      return (_b = icon != null ? icon : (_a = config.icon) == null ? void 0 : _a[type]) != null ? _b : defaultIconTypes[type];
    });
    return () => {
      var _a, _b;
      const prefixCls = `${mergedPrefixCls.value}-body`;
      if (isDefault.value) {
        return createVNode("div", {
          "class": prefixCls
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      }
      const classes = `${prefixCls} ${prefixCls}-${props.type}`;
      const iconNode = renderIcon$4(prefixCls, slots.icon, iconName.value);
      const titleNode = renderTitle(prefixCls, slots.title, props.title);
      return createVNode("div", {
        "class": classes
      }, [iconNode, createVNode("div", {
        "class": `${prefixCls}-content`
      }, [titleNode, (_b = slots.default) == null ? void 0 : _b.call(slots)])]);
    };
  }
});
const renderIcon$4 = (prefixCls, iconSlot, icon) => {
  if (!iconSlot && !icon) {
    return null;
  }
  let children;
  if (iconSlot) {
    children = iconSlot();
  } else {
    children = isString(icon) ? createVNode(IxIcon, {
      "name": icon
    }, null) : icon;
  }
  return createVNode("div", {
    "class": `${prefixCls}-icon`
  }, [children]);
};
const renderTitle = (prefixCls, titleSlot, title) => {
  if (!titleSlot && !title) {
    return null;
  }
  const children = titleSlot ? titleSlot() : title;
  return createVNode("div", {
    "class": `${prefixCls}-title`
  }, [children]);
};
var __defProp$1$6 = Object.defineProperty;
var __getOwnPropSymbols$1$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$6 = (obj, key, value) => key in obj ? __defProp$1$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$9.call(b, prop))
      __defNormalProp$1$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$9)
    for (var prop of __getOwnPropSymbols$1$9(b)) {
      if (__propIsEnum$1$9.call(b, prop))
        __defNormalProp$1$6(a, prop, b[prop]);
    }
  return a;
};
var ModalWrapper = defineComponent({
  inheritAttrs: false,
  setup(_, {
    attrs
  }) {
    const {
      props,
      slots,
      common,
      config,
      mergedPrefixCls,
      visible,
      animatedVisible,
      mergedVisible,
      cancelLoading,
      okLoading
    } = inject(modalToken);
    const {
      close,
      cancel,
      ok
    } = inject(MODAL_TOKEN);
    const {
      centered,
      closable,
      closeIcon,
      closeOnEsc,
      width,
      mask,
      maskClosable,
      zIndex
    } = useConfig(props, config);
    const locale = getLocale("modal");
    const cancelVisible = computed(() => props.type === "default" || props.type === "confirm");
    const cancelText = computed(() => {
      var _a;
      return (_a = props.cancelText) != null ? _a : locale.value.cancelText;
    });
    const okText = computed(() => {
      if (props.okText) {
        return props.okText;
      }
      return cancelVisible.value ? locale.value.okText : locale.value.justOkText;
    });
    const placementStyle = computed(() => {
      const top = centered.value ? 0 : convertCssPixel(props.offset);
      return {
        top,
        width: width.value
      };
    });
    const wrapperClasses = computed(() => {
      const {
        wrapperClassName = ""
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return {
        [`${prefixCls}-wrapper`]: true,
        [`${prefixCls}-centered`]: centered.value,
        [`${prefixCls}-with-mask`]: mask.value,
        [wrapperClassName]: !!wrapperClassName
      };
    });
    const wrapperStyle = computed(() => {
      return {
        zIndex: zIndex.value
      };
    });
    const modalTransformOrigin = ref();
    const contentStyle = computed(() => {
      return __spreadValues$1$6({
        transformOrigin: modalTransformOrigin.value
      }, placementStyle.value);
    });
    const wrapperRef = ref();
    const modalRef = ref();
    const sentinelStartRef = ref();
    const sentinelEndRef = ref();
    const {
      onWrapperClick,
      onWrapperKeydown,
      onContentMousedown,
      onContentMouseup
    } = useEvent(close, mask, maskClosable, closeOnEsc, sentinelStartRef, sentinelEndRef);
    const {
      onEnter,
      onAfterEnter,
      onAfterLeave
    } = useEvents$2(props, wrapperRef, modalRef, animatedVisible, modalTransformOrigin);
    onMounted(() => watchVisibleChange(props, wrapperRef, sentinelStartRef, mask));
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return withDirectives(createVNode("div", {
        "ref": wrapperRef,
        "class": wrapperClasses.value,
        "style": wrapperStyle.value,
        "tabindex": -1,
        "onClick": onWrapperClick,
        "onKeydown": onWrapperKeydown
      }, [createVNode(Transition, {
        "name": props.animatable ? `${common.prefixCls}-zoom` : void 0,
        "appear": true,
        "onEnter": onEnter,
        "onAfterEnter": onAfterEnter,
        "onAfterLeave": onAfterLeave
      }, {
        default: () => [withDirectives(createVNode("div", mergeProps({
          "ref": modalRef,
          "role": "document",
          "class": prefixCls,
          "style": contentStyle.value,
          "onMousedown": onContentMousedown,
          "onMouseup": onContentMouseup
        }, attrs), [createVNode("div", {
          "ref": sentinelStartRef,
          "tabindex": 0,
          "class": `${prefixCls}-sentinel`,
          "aria-hidden": true
        }, null), createVNode("div", {
          "class": `${prefixCls}-content`
        }, [createVNode(\u0275Header, {
          "closable": closable.value,
          "closeIcon": closeIcon.value,
          "header": props.header,
          "onClose": close
        }, slots), createVNode(ModalBody, null, null), createVNode(\u0275Footer, {
          "class": `${prefixCls}-footer`,
          "cancel": cancel,
          "cancelButton": props.cancelButton,
          "cancelLoading": cancelLoading.value,
          "cancelText": cancelText.value,
          "cancelVisible": cancelVisible.value,
          "footer": props.footer,
          "ok": ok,
          "okButton": props.okButton,
          "okLoading": okLoading.value,
          "okText": okText.value
        }, slots)]), createVNode("div", {
          "ref": sentinelEndRef,
          "tabindex": 0,
          "class": `${prefixCls}-sentinel`,
          "aria-hidden": true
        }, null)]), [[vShow, visible.value]])]
      })]), [[vShow, mergedVisible.value]]);
    };
  }
});
function useConfig(props, config) {
  const centered = computed(() => {
    var _a;
    return (_a = props.centered) != null ? _a : config.centered;
  });
  const closable = computed(() => {
    var _a;
    return (_a = props.closable) != null ? _a : config.closable;
  });
  const closeIcon = computed(() => {
    var _a;
    return (_a = props.closeIcon) != null ? _a : config.closeIcon;
  });
  const closeOnEsc = computed(() => {
    var _a;
    return (_a = props.closeOnEsc) != null ? _a : config.closeOnEsc;
  });
  const mask = computed(() => {
    var _a;
    return (_a = props.mask) != null ? _a : config.mask;
  });
  const maskClosable = computed(() => {
    var _a;
    return (_a = props.maskClosable) != null ? _a : config.maskClosable;
  });
  const width = computed(() => {
    var _a;
    return convertCssPixel((_a = props.width) != null ? _a : config.width);
  });
  const zIndex = computed(() => {
    var _a;
    return (_a = props.zIndex) != null ? _a : config.zIndex;
  });
  return {
    centered,
    closable,
    closeIcon,
    closeOnEsc,
    width,
    mask,
    maskClosable,
    zIndex
  };
}
function watchVisibleChange(props, wrapperRef, sentinelStartRef, mask) {
  let lastOutSideActiveElement = null;
  watch(() => props.visible, (visible) => {
    var _a, _b;
    if (visible) {
      const wrapperElement = wrapperRef.value;
      const activeElement = document.activeElement;
      if (!wrapperElement.contains(activeElement)) {
        lastOutSideActiveElement = activeElement;
        (_a = sentinelStartRef.value) == null ? void 0 : _a.focus();
      }
    } else {
      if (mask.value) {
        (_b = lastOutSideActiveElement == null ? void 0 : lastOutSideActiveElement.focus) == null ? void 0 : _b.call(lastOutSideActiveElement);
        lastOutSideActiveElement = null;
      }
    }
  }, {
    immediate: true
  });
}
function useEvent(close, mask, maskClosable, closeOnEsc, sentinelStartRef, sentinelEndRef) {
  let timeId;
  let mouseDown = false;
  const clearTimer = () => {
    if (timeId) {
      clearTimeout(timeId);
      timeId = void 0;
    }
  };
  const onWrapperClick = (evt) => {
    if (evt.target === evt.currentTarget && !mouseDown && mask.value && maskClosable.value) {
      close(evt);
    }
  };
  const onWrapperKeydown = (evt) => {
    if (closeOnEsc.value && evt.code === "Escape") {
      evt.stopPropagation();
      close(evt);
      return;
    }
    if (evt.code === "Tab") {
      const activeElement = document.activeElement;
      const sentinelStartElement = sentinelStartRef.value;
      const sentinelEndElement = sentinelEndRef.value;
      if (evt.shiftKey) {
        if (activeElement === sentinelStartElement) {
          sentinelEndElement == null ? void 0 : sentinelEndElement.focus();
        }
      } else if (activeElement === sentinelEndElement) {
        sentinelStartElement == null ? void 0 : sentinelStartElement.focus();
      }
    }
  };
  const onContentMousedown = () => {
    clearTimer();
    mouseDown = true;
  };
  const onContentMouseup = () => {
    if (mouseDown) {
      timeId = setTimeout(() => mouseDown = false);
    }
  };
  onBeforeUnmount(() => clearTimer());
  return {
    onWrapperClick,
    onWrapperKeydown,
    onContentMousedown,
    onContentMouseup
  };
}
function useEvents$2(props, wrapperRef, modalRef, animatedVisible, modalTransformOrigin) {
  let lastOutSideActiveElement = null;
  const onEnter = () => {
    const wrapperElement = wrapperRef.value;
    const activeElement = document.activeElement;
    if (!wrapperElement.contains(activeElement)) {
      lastOutSideActiveElement = activeElement;
    }
    if (!modalTransformOrigin.value && lastOutSideActiveElement) {
      const modalElement = modalRef.value;
      const previouslyDOMRect = lastOutSideActiveElement.getBoundingClientRect();
      const lastPosition = getOffset(lastOutSideActiveElement);
      const x = lastPosition.left + previouslyDOMRect.width / 2;
      const y = lastPosition.top + previouslyDOMRect.height / 2;
      modalTransformOrigin.value = `${x - modalElement.offsetLeft}px ${y - modalElement.offsetTop}px`;
    }
  };
  const onAfterEnter = () => {
    const wrapperElement = wrapperRef.value;
    const activeElement = document.activeElement;
    if (!wrapperElement.contains(activeElement)) {
      wrapperElement.focus();
    }
    callEmit(props.onAfterOpen);
    animatedVisible.value = true;
  };
  const onAfterLeave = () => {
    if (lastOutSideActiveElement && isFunction(lastOutSideActiveElement.focus)) {
      const wrapperElement = wrapperRef.value;
      const activeElement = document.activeElement;
      if (!activeElement || activeElement === document.body || activeElement === wrapperElement || wrapperElement.contains(activeElement)) {
        lastOutSideActiveElement.focus();
      }
    }
    callEmit(props.onAfterClose);
    animatedVisible.value = false;
  };
  return {
    onEnter,
    onAfterEnter,
    onAfterLeave
  };
}
const modalProps = {
  visible: IxPropTypes.bool,
  cancelButton: IxPropTypes.object(),
  cancelText: IxPropTypes.string,
  centered: IxPropTypes.bool,
  closable: IxPropTypes.bool,
  closeIcon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  closeOnEsc: IxPropTypes.bool,
  destroyOnHide: IxPropTypes.bool.def(false),
  footer: IxPropTypes.oneOfType([Boolean, IxPropTypes.array(), IxPropTypes.vNode]).def(true),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  mask: IxPropTypes.bool,
  maskClosable: IxPropTypes.bool,
  animatable: IxPropTypes.bool.def(true),
  offset: IxPropTypes.oneOfType([String, Number]).def(128),
  okButton: IxPropTypes.object(),
  okText: IxPropTypes.string,
  scrollStrategy: IxPropTypes.object(),
  target: portalTargetDef,
  title: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  type: IxPropTypes.oneOf(["default", "confirm", "info", "success", "warning", "error"]).def("default"),
  width: IxPropTypes.oneOfType([String, Number]),
  wrapperClassName: IxPropTypes.string,
  zIndex: IxPropTypes.number,
  "onUpdate:visible": IxPropTypes.emit(),
  onAfterOpen: IxPropTypes.emit(),
  onAfterClose: IxPropTypes.emit(),
  onBeforeClose: IxPropTypes.emit(),
  onClose: IxPropTypes.emit(),
  onCancel: IxPropTypes.emit(),
  onOk: IxPropTypes.emit()
};
var __async$6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Modal = defineComponent({
  name: "IxModal",
  inheritAttrs: false,
  props: modalProps,
  setup(props, {
    slots,
    expose,
    attrs
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-modal`);
    const config = useGlobalConfig$1("modal");
    const mask = computed(() => {
      var _a;
      return (_a = props.mask) != null ? _a : config.mask;
    });
    const zIndex = computed(() => {
      var _a;
      return (_a = props.zIndex) != null ? _a : config.zIndex;
    });
    const {
      visible,
      setVisible,
      animatedVisible,
      mergedVisible
    } = useVisible$1(props);
    const {
      cancelLoading,
      okLoading,
      open,
      close,
      cancel,
      ok
    } = useTrigger$1(props, setVisible);
    provide(modalToken, {
      props,
      slots,
      common,
      config,
      mergedPrefixCls,
      visible,
      animatedVisible,
      mergedVisible,
      cancelLoading,
      okLoading
    });
    const apis = {
      open,
      close,
      cancel,
      ok
    };
    provide(MODAL_TOKEN, apis);
    expose(apis);
    useScrollStrategy(props, mask, mergedVisible);
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-container`;
    });
    return () => {
      if (!mergedVisible.value && props.destroyOnHide) {
        return null;
      }
      return createVNode(CdkPortal, {
        "target": target.value,
        "load": visible.value
      }, {
        default: () => [createVNode(\u0275Mask, {
          "class": `${mergedPrefixCls.value}-mask`,
          "mask": mask.value,
          "visible": visible.value,
          "zIndex": zIndex.value
        }, null), createVNode(ModalWrapper, attrs, null)]
      });
    };
  }
});
function useVisible$1(props) {
  const [visible, setVisible] = useControlledProp(props, "visible", false);
  const animatedVisible = ref();
  const mergedVisible = computed(() => {
    const currVisible = visible.value;
    const currAnimatedVisible = animatedVisible.value;
    if (currAnimatedVisible === void 0 || currVisible) {
      return currVisible;
    }
    return currAnimatedVisible;
  });
  return {
    visible,
    setVisible,
    animatedVisible,
    mergedVisible
  };
}
function useScrollStrategy(props, mask, mergedVisible) {
  let scrollStrategy;
  onMounted(() => {
    watch([mask, mergedVisible], ([maskValue, visible]) => {
      var _a;
      if (!maskValue || !visible) {
        scrollStrategy == null ? void 0 : scrollStrategy.disable();
        return;
      }
      if (!scrollStrategy) {
        scrollStrategy = (_a = props.scrollStrategy) != null ? _a : new BlockScrollStrategy();
      }
      scrollStrategy.enable();
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => scrollStrategy == null ? void 0 : scrollStrategy.disable());
}
function useTrigger$1(props, setVisible) {
  const open = () => setVisible(true);
  const close = (evt) => __async$6(this, null, function* () {
    const result = yield callEmit(props.onBeforeClose, evt);
    if (result === false) {
      return;
    }
    setVisible(false);
    callEmit(props.onClose, evt);
  });
  const cancelLoading = ref(false);
  const cancel = (evt) => __async$6(this, null, function* () {
    let result = callEmit(props.onCancel, evt);
    if (isPromise(result)) {
      cancelLoading.value = true;
      result = yield result;
      cancelLoading.value = false;
    }
    if (result === false) {
      return;
    }
    setVisible(false);
  });
  const okLoading = ref(false);
  const ok = (evt) => __async$6(this, null, function* () {
    let result = callEmit(props.onOk, evt);
    if (isPromise(result)) {
      okLoading.value = true;
      result = yield result;
      okLoading.value = false;
    }
    if (result === false) {
      return;
    }
    setVisible(false);
  });
  return {
    cancelLoading,
    okLoading,
    open,
    close,
    cancel,
    ok
  };
}
var __defProp$g = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
var __objRest$7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var ModalProvider = defineComponent({
  name: "IxModalProvider",
  setup(_, {
    expose,
    slots
  }) {
    const {
      modals,
      setModalRef,
      open,
      confirm,
      info,
      success,
      warning,
      error,
      update,
      destroy,
      destroyAll
    } = useModal$1();
    const apis = {
      open,
      confirm,
      info,
      success,
      warning,
      error,
      update,
      destroy,
      destroyAll
    };
    provide(modalProviderToken, apis);
    expose(apis);
    return () => {
      var _a;
      const children = modals.value.map((item) => {
        const _a2 = item, {
          key,
          visible = true,
          destroyOnHide,
          onDestroy,
          content,
          contentProps
        } = _a2, restProps = __objRest$7(_a2, [
          "key",
          "visible",
          "destroyOnHide",
          "onDestroy",
          "content",
          "contentProps"
        ]);
        const setRef = (instance) => setModalRef(key, instance);
        const onUpdateVisible = (visible2) => update(key, {
          visible: visible2
        });
        const onAfterClose = destroyOnHide ? () => destroy(key) : void 0;
        const mergedProps = {
          key,
          visible,
          ref: setRef,
          "onUpdate:visible": onUpdateVisible,
          onAfterClose
        };
        const contentNode = isVNode(content) ? cloneVNode(content, contentProps, true) : content;
        return createVNode(Modal, mergeProps(mergedProps, restProps), {
          default: () => [contentNode]
        });
      });
      return createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots), children]);
    };
  }
});
function useModal$1() {
  const modals = shallowRef([]);
  const modalRefMap = /* @__PURE__ */ new Map();
  const setModalRef = (key, instance) => {
    const ref2 = modalRefMap.get(key);
    if (instance) {
      if (ref2 && !ref2.open) {
        ref2.open = instance.open;
        ref2.close = instance.close;
        ref2.cancel = instance.cancel;
        ref2.ok = instance.ok;
      }
    } else {
      if (ref2) {
        modalRefMap.delete(key);
        ref2.open = NoopFunction;
        ref2.close = NoopFunction;
        ref2.cancel = NoopFunction;
        ref2.ok = NoopFunction;
      }
    }
  };
  const getCurrIndex = (key) => {
    return modals.value.findIndex((message) => message.key === key);
  };
  const add = (item) => {
    var _a;
    const currIndex = item.key ? getCurrIndex(item.key) : -1;
    const tempModals = [...modals.value];
    if (currIndex !== -1) {
      tempModals.splice(currIndex, 1, item);
      modals.value = tempModals;
      return item.key;
    }
    item.key = (_a = item.key) != null ? _a : uniqueId("ix-modal");
    tempModals.push(item);
    modals.value = tempModals;
    return item.key;
  };
  const update = (key, item) => {
    const currIndex = getCurrIndex(key);
    if (currIndex !== -1) {
      const tempModals = [...modals.value];
      const newItem = __spreadValues$g(__spreadValues$g({}, modals.value[currIndex]), item);
      tempModals.splice(currIndex, 1, newItem);
      modals.value = tempModals;
    }
  };
  const destroy = (key) => {
    const keys = convertArray(key);
    keys.forEach((key2) => {
      const currIndex = getCurrIndex(key2);
      if (currIndex !== -1) {
        const tempModals = [...modals.value];
        const item = tempModals.splice(currIndex, 1);
        modals.value = tempModals;
        callEmit(item[0].onDestroy, key2);
      }
    });
  };
  const destroyAll = () => {
    modals.value = [];
  };
  const open = (options) => {
    const key = add(options);
    const modalRef = {
      key,
      update: (options2) => update(key, options2),
      destroy: () => destroy(key)
    };
    modalRefMap.set(key, modalRef);
    return modalRef;
  };
  const modalTypes = ["confirm", "info", "success", "warning", "error"];
  const [confirm, info, success, warning, error] = modalTypes.map((type) => {
    return (options) => open(__spreadProps$c(__spreadValues$g({}, options), {
      type
    }));
  });
  return {
    modals,
    setModalRef,
    open,
    confirm,
    info,
    success,
    warning,
    error,
    update,
    destroy,
    destroyAll
  };
}
const IxModal = Modal;
const IxModalProvider = ModalProvider;

const spaceProps = {
  align: IxPropTypes.oneOf(["start", "center", "end", "baseline", "stretch"]),
  block: IxPropTypes.bool,
  direction: IxPropTypes.oneOf(["vertical", "horizontal"]),
  justify: IxPropTypes.oneOf(["start", "center", "end", "space-around", "space-between"]),
  size: IxPropTypes.oneOfType([Number, String, IxPropTypes.array()]),
  split: IxPropTypes.string,
  separator: IxPropTypes.string,
  vertical: IxPropTypes.bool,
  wrap: IxPropTypes.bool
};
const flexGapSupported = supportsFlexGap();
const defaultSizeMap = {
  sm: "8px",
  md: "16px",
  lg: "24px"
};
var Space = defineComponent({
  name: "IxSpace",
  props: spaceProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-space`);
    const config = useGlobalConfig$1("space");
    const wrap = computed(() => {
      var _a;
      return (_a = props.wrap) != null ? _a : config.wrap;
    });
    const vertical = computed(() => {
      const {
        direction,
        vertical: vertical2
      } = props;
      if (direction) {
        process.env.NODE_ENV !== "production" && Logger.warn("components/space", "`direction` was deprecated, please use `vertical` instead");
        return direction === "vertical";
      }
      return vertical2;
    });
    const mergedGaps = computed(() => {
      const {
        size = config.size
      } = props;
      const sizes = Array.isArray(size) ? size : [size, size];
      return sizes.map((size2) => defaultSizeMap[size2] || convertCssPixel(size2));
    });
    const classes = computed(() => {
      const {
        align,
        justify,
        block
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-align-${align}`]: align,
        [`${prefixCls}-justify-${justify}`]: justify,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-vertical`]: vertical.value,
        [`${prefixCls}-nowrap`]: !wrap.value
      });
    });
    const style = computed(() => {
      const [rowGap, columnGap] = mergedGaps.value;
      if (flexGapSupported) {
        return `gap: ${rowGap} ${columnGap}`;
      } else {
        return !vertical.value && wrap.value ? `margin-bottom: -${convertCssPixel(rowGap)}` : void 0;
      }
    });
    return () => {
      var _a;
      const nodes = flattenNode((_a = slots.default) == null ? void 0 : _a.call(slots));
      if (nodes.length === 0) {
        return;
      }
      const prefixCls = mergedPrefixCls.value;
      const children = [];
      let separatorNode = covertStringVNode(slots, props, "split");
      if (separatorNode) {
        process.env.NODE_ENV !== "production" && Logger.warn("components/space", "`split` was deprecated, please use `separator` instead");
      } else {
        separatorNode = covertStringVNode(slots, props, "separator");
      }
      const lastIndex = nodes.length - 1;
      nodes.forEach((node, index) => {
        const style2 = calcItemStyle(mergedGaps, wrap, vertical, index, lastIndex);
        children.push(createVNode("div", {
          "key": `item-${index}`,
          "class": `${prefixCls}-item`,
          "style": style2
        }, [node]));
        if (separatorNode && index < lastIndex) {
          children.push(createVNode("div", {
            "key": `separator-${index}`,
            "class": `${prefixCls}-item-separator`,
            "style": style2
          }, [separatorNode]));
        }
      });
      return createVNode("div", {
        "class": classes.value,
        "style": style.value
      }, [children]);
    };
  }
});
const calcItemStyle = (mergedGaps, wrap, vertical, index, lastIndex) => {
  if (flexGapSupported) {
    return void 0;
  }
  const [rowGap, columnGap] = mergedGaps.value;
  if (vertical.value) {
    const marginBottom = index < lastIndex ? convertCssPixel(rowGap) : void 0;
    return {
      marginBottom
    };
  } else {
    const marginRight = index < lastIndex ? convertCssPixel(columnGap) : void 0;
    const paddingBottom = wrap.value ? convertCssPixel(rowGap) : void 0;
    return {
      marginRight,
      paddingBottom
    };
  }
};
const IxSpace = Space;

const notificationType = ["info", "success", "warning", "error"];
const notificationPlacement = ["topStart", "topEnd", "bottomStart", "bottomEnd"];
const notificationProps = {
  visible: IxPropTypes.bool,
  destroyOnHover: IxPropTypes.bool,
  duration: IxPropTypes.number,
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  closeIcon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  type: IxPropTypes.oneOf(["info", "success", "warning", "error"]),
  key: IxPropTypes.oneOfType([String, Number, Symbol]),
  title: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  content: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  footer: IxPropTypes.oneOfType([
    IxPropTypes.array(),
    IxPropTypes.vNode,
    String
  ]),
  placement: IxPropTypes.oneOf(["topStart", "topEnd", "bottomStart", "bottomEnd"]),
  "onUpdate:visible": IxPropTypes.emit(),
  onClose: IxPropTypes.emit()
};
const notificationProviderProps = {
  offset: IxPropTypes.oneOfType([String, Number, Array]),
  maxCount: IxPropTypes.number,
  target: portalTargetDef
};
var __defProp$1$5 = Object.defineProperty;
var __getOwnPropSymbols$1$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$5 = (obj, key, value) => key in obj ? __defProp$1$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$8.call(b, prop))
      __defNormalProp$1$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$8)
    for (var prop of __getOwnPropSymbols$1$8(b)) {
      if (__propIsEnum$1$8.call(b, prop))
        __defNormalProp$1$5(a, prop, b[prop]);
    }
  return a;
};
var __objRest$6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1$8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1$8)
    for (var prop of __getOwnPropSymbols$1$8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1$8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const defaultCloseIcon = "close";
const defaultIcon = {
  success: "check-circle-filled",
  error: "close-circle-filled",
  info: "info-circle-filled",
  warning: "exclamation-circle-filled"
};
var Notification = defineComponent({
  name: "IxNotification",
  props: notificationProps,
  setup(props, {
    slots
  }) {
    const commonCfg = useGlobalConfig$1("common");
    const comPrefix = computed(() => `${commonCfg.prefixCls}-notification`);
    const config = useGlobalConfig$1("notification");
    const wrapCls = useClasses$3(props, comPrefix);
    const icon = useIcon$2(props, config);
    const closeIcon = useCloseIcon(props, config);
    const {
      visible,
      close,
      onMouseEnter,
      onMouseLeave
    } = useVisible(props, config);
    return () => {
      const iconNode = icon.value && getIconNode$1(icon.value);
      const closeIconNode = getIconNode$1(closeIcon.value);
      return withDirectives(createVNode("div", null, [createVNode("div", {
        "class": wrapCls.value,
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave
      }, [withDirectives(createVNode("div", {
        "class": `${comPrefix.value}-icon`
      }, [iconNode]), [[vShow, icon.value]]), createVNode("span", {
        "class": `${comPrefix.value}-close-icon`,
        "onClick": close
      }, [closeIconNode]), createVNode("div", {
        "class": `${comPrefix.value}-main`
      }, [createVNode("div", {
        "class": `${comPrefix.value}-title`
      }, [getNode(props, slots, "title")]), createVNode("div", {
        "class": `${comPrefix.value}-content`
      }, [getNode(props, slots, "content")])]), createVNode("div", {
        "class": `${comPrefix.value}-footer`
      }, [getNode(props, slots, "footer", {
        visible: visible.value,
        close
      })])])]), [[vShow, visible.value]]);
    };
  }
});
function useClasses$3(props, comPrefix) {
  return computed(() => [comPrefix.value, {
    [`${comPrefix.value}-${props.type}`]: props.type
  }]);
}
function useIcon$2(props, config) {
  return computed(() => {
    var _a;
    const iconMap = __spreadValues$1$5(__spreadValues$1$5({}, defaultIcon), config.icon);
    return (_a = props.icon) != null ? _a : props.type && iconMap[props.type];
  });
}
function useCloseIcon(props, config) {
  return computed(() => {
    var _a, _b;
    return (_b = (_a = props.closeIcon) != null ? _a : config.closeIcon) != null ? _b : defaultCloseIcon;
  });
}
function useVisible(props, config) {
  const duration = computed(() => {
    var _a;
    return (_a = props.duration) != null ? _a : config.duration;
  });
  const destroyOnHover = computed(() => {
    var _a;
    return (_a = props.destroyOnHover) != null ? _a : config.destroyOnHover;
  });
  const autoClose = computed(() => duration.value > 0);
  const [visible, setVisible] = useControlledProp(props, "visible", false);
  let timer = null;
  const startTimer = () => {
    timer = setTimeout(() => close(), duration.value);
  };
  const clearTimer = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  const close = () => {
    clearTimer();
    setVisible(false);
    callEmit(props.onClose);
  };
  const onMouseEnter = () => {
    if (autoClose.value && !destroyOnHover.value) {
      clearTimer();
    }
  };
  const onMouseLeave = () => {
    if (autoClose.value && !destroyOnHover.value) {
      startTimer();
    }
  };
  onMounted(() => {
    watchEffect(() => {
      clearTimer();
      if (visible.value && autoClose.value) {
        startTimer();
      }
    });
  });
  onBeforeUnmount(() => clearTimer());
  return {
    visible,
    close,
    onMouseEnter,
    onMouseLeave
  };
}
function getIconNode$1(icon) {
  return isString(icon) ? createVNode(IxIcon, {
    "name": icon
  }, null) : icon;
}
function getNode(props, slots, nodeKey, slotProps) {
  var _a, _b, _c;
  const slotMap = {
    title: "title",
    content: "default",
    footer: "footer"
  };
  const getHandlePropsMap = {
    title: (propsValue) => propsValue,
    content: (propsValue) => propsValue,
    footer: (propsValue) => getFooterNode(propsValue)
  };
  return (_c = (_a = slots[slotMap[nodeKey]]) == null ? void 0 : _a.call(slots, slotProps)) != null ? _c : (_b = getHandlePropsMap[nodeKey]) == null ? void 0 : _b.call(getHandlePropsMap, props[nodeKey]);
}
function getFooterNode(footer) {
  if (!footer) {
    return "";
  }
  if (!isArray$1(footer)) {
    return footer;
  }
  const footerButtons = footer.map((item) => {
    const _a = item, {
      text
    } = _a, rest = __objRest$6(_a, [
      "text"
    ]);
    return createVNode(IxButton, rest, {
      default: () => [text]
    });
  });
  return createVNode(IxSpace, null, {
    default: () => [footerButtons]
  });
}
const notificationProviderToken = Symbol("notificationProviderToken");
var __defProp$f = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
const groupPositions = {
  topStart: ["top", "left"],
  topEnd: ["top", "right"],
  bottomStart: ["bottom", "left"],
  bottomEnd: ["bottom", "right"]
};
var NotificationProvider = defineComponent({
  name: "IxNotificationProvider",
  inheritAttrs: false,
  props: notificationProviderProps,
  setup(props, {
    slots,
    expose
  }) {
    const commonCfg = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${commonCfg.prefixCls}-notification`);
    const config = useGlobalConfig$1("notification");
    const maxCount = computed(() => {
      var _a;
      return (_a = props.maxCount) != null ? _a : config.maxCount;
    });
    const {
      notifications,
      loadContainer,
      open,
      info,
      success,
      warning,
      error,
      update,
      destroy,
      destroyAll
    } = useNotification$1(maxCount);
    const apis = {
      open,
      info,
      success,
      warning,
      error,
      update,
      destroy,
      destroyAll
    };
    const placementNotifications = usePlacementNotifications(props, config, notifications);
    provide(notificationProviderToken, apis);
    expose(apis);
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-container`;
    });
    return () => {
      var _a;
      const getChild = (notifications2) => {
        return notifications2.map((item) => {
          const {
            key,
            visible = true
          } = item;
          const onClose = () => destroy(key);
          return createVNode(Notification, mergeProps(item, {
            "onClose": onClose,
            "visible": visible
          }), null);
        });
      };
      const placementGroup = Object.entries(placementNotifications.value).map(([key, notificationsRecord]) => {
        const placement = key;
        const child = getChild(notificationsRecord);
        const moveName = getMoveName(placement, commonCfg);
        const position = getGroupPosition(props, config, placement);
        return createVNode(TransitionGroup, {
          "key": placement,
          "tag": "div",
          "appear": true,
          "name": moveName,
          "class": [`${mergedPrefixCls.value}-wrapper`, `${mergedPrefixCls.value}-wrapper-${placement}`],
          "style": position
        }, {
          default: () => [child]
        });
      });
      return createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots), createVNode(CdkPortal, {
        "target": target.value,
        "load": loadContainer.value
      }, {
        default: () => [placementGroup]
      })]);
    };
  }
});
function usePlacementNotifications(props, config, notifications) {
  return computed(() => {
    const initValue = getPlacementInitValue(() => []);
    const {
      destroyOnHover,
      duration,
      closeIcon,
      placement
    } = config;
    if (notifications.value.length === 0) {
      return initValue;
    }
    return notifications.value.reduce((acc, item) => {
      const notificationProps2 = getRealObj(__spreadValues$f({
        destroyOnHover,
        duration,
        closeIcon,
        placement
      }, item));
      const curPlacement = notificationProps2.placement;
      acc[curPlacement].push(notificationProps2);
      return acc;
    }, initValue);
  });
}
function useNotification$1(maxCount) {
  const notifications = ref([]);
  const getCurrIndex = (key) => {
    return notifications.value.findIndex((notification) => notification.key === key);
  };
  const add = (item) => {
    var _a;
    const currIndex = item.key ? getCurrIndex(item.key) : -1;
    if (currIndex !== -1) {
      notifications.value.splice(currIndex, 1, item);
      return item.key;
    }
    if (notifications.value.length >= maxCount.value) {
      notifications.value = notifications.value.slice(-maxCount.value + 1);
    }
    const key = (_a = item.key) != null ? _a : uniqueId("ix-notification");
    notifications.value.push(__spreadProps$b(__spreadValues$f({}, item), {
      key
    }));
    return key;
  };
  const update = (key, item) => {
    const currIndex = getCurrIndex(key);
    if (currIndex !== -1) {
      const newItem = __spreadValues$f(__spreadValues$f({}, notifications.value[currIndex]), item);
      notifications.value.splice(currIndex, 1, newItem);
    }
  };
  const destroy = (key) => {
    const keys = convertArray(key);
    keys.forEach((key2) => {
      const currIndex = getCurrIndex(key2);
      if (currIndex !== -1) {
        const item = notifications.value.splice(currIndex, 1);
        callEmit(item[0].onDestroy, key2);
      }
    });
  };
  const destroyAll = () => {
    notifications.value = [];
  };
  const loadContainer = ref(false);
  const open = (options) => {
    const key = add(options);
    const ref2 = {
      key,
      update: (options2) => update(key, options2),
      destroy: () => destroy(key)
    };
    if (!loadContainer.value) {
      loadContainer.value = true;
    }
    return ref2;
  };
  const [info, success, warning, error] = notificationType.map((type) => (options) => open(__spreadProps$b(__spreadValues$f({}, options), {
    type
  })));
  return {
    notifications,
    loadContainer,
    open,
    info,
    success,
    warning,
    error,
    update,
    destroy,
    destroyAll
  };
}
function getGroupPosition(props, config, placement) {
  var _a;
  const realPlacement = placement != null ? placement : config.placement;
  const realOffset = (_a = props.offset) != null ? _a : config.offset;
  return getPosition(realOffset, realPlacement);
}
function getPosition(offset, placement) {
  const offsets = isArray$1(offset) ? offset : [offset, offset];
  const [verticalOffset, horizontalOffset] = offsets.map(convertCssPixel);
  const [verticalPosition, horizontalPosition] = groupPositions[placement];
  return {
    [verticalPosition]: verticalOffset,
    [horizontalPosition]: horizontalOffset
  };
}
function getMoveName(placement, commonCfg) {
  const prefixCls = commonCfg.prefixCls;
  const moveNameMap = {
    topEnd: `${prefixCls}-move-end`,
    bottomEnd: `${prefixCls}-move-end`,
    topStart: `${prefixCls}-move-start`,
    bottomStart: `${prefixCls}-move-start`
  };
  return moveNameMap[placement];
}
function getRealObj(obj) {
  return pickBy(obj, (val) => !isUndefined(val));
}
function getPlacementInitValue(initValueFn) {
  return notificationPlacement.reduce((acc, item) => {
    const cloneValue = initValueFn();
    return __spreadProps$b(__spreadValues$f({}, acc), {
      [item]: cloneValue
    });
  }, {});
}
const IxNotification = Notification;
const IxNotificationProvider = NotificationProvider;

const Empty = (props, {
  slots
}) => {
  if (slots.empty) {
    return slots.empty(props);
  }
  const {
    empty
  } = props;
  const emptyProps = isString(empty) ? {
    description: empty
  } : empty;
  return createVNode(IxEmpty, emptyProps, null);
};
const \u0275Empty = Empty;

function useActiveState(props, flattedOptions, selectedValue, inputValue, scrollTo) {
  const activeIndex = ref(0);
  onMounted(() => {
    watchEffect(() => {
      const { compareWith, allowInput } = props;
      const options = flattedOptions.value;
      let currIndex;
      if (allowInput && inputValue.value) {
        const searchValue = inputValue.value;
        currIndex = options.findIndex((option) => option.value === searchValue);
      } else {
        const currValue = selectedValue.value;
        currIndex = options.findIndex((option) => currValue.some((value) => compareWith(option.value, value)));
      }
      currIndex = currIndex === -1 ? 0 : currIndex;
      activeIndex.value = getEnabledActiveIndex(options, currIndex, 1);
    });
  });
  const activeOption = computed(() => flattedOptions.value[activeIndex.value]);
  const changeActive = (currIndex, offset) => {
    const enabledIndex = getEnabledActiveIndex(flattedOptions.value, currIndex, offset);
    if (enabledIndex !== activeIndex.value) {
      activeIndex.value = enabledIndex;
      if (offset !== 0) {
        scrollToActivated();
      }
    }
  };
  const scrollToActivated = () => {
    scrollTo({ index: activeIndex.value });
  };
  return {
    activeIndex,
    activeOption,
    changeActive,
    scrollToActivated
  };
}
function getEnabledActiveIndex(options, currIndex, offset) {
  const length = options.length;
  for (let index = 0; index < length; index++) {
    const current = (currIndex + index * offset + length) % length;
    const { type, disabled } = options[current];
    if (type !== "group" && !disabled) {
      return current;
    }
  }
  return -1;
}
function useInputState$1(props, inputRef, accessor) {
  const mirrorRef = ref();
  const inputValue = ref("");
  const inputWidth = ref("");
  const isComposing = ref(false);
  const isFocused = ref(false);
  const syncMirrorWidth = () => {
    if (props.multiple) {
      const inputElement = inputRef.value;
      const mirrorElement = mirrorRef.value;
      if (inputElement && mirrorElement) {
        mirrorElement.innerText = ` ${inputElement.value}`;
        inputWidth.value = `${mirrorElement.scrollWidth}px`;
      }
    }
  };
  const handleCompositionStart = (evt) => {
    isComposing.value = true;
    callEmit(props.onCompositionStart, evt);
  };
  const handleCompositionEnd = (evt) => {
    if (isComposing.value) {
      isComposing.value = false;
    }
    callEmit(props.onCompositionEnd, evt);
  };
  const handleInput = (evt) => {
    callEmit(props.onInput, evt);
    if (isComposing.value) {
      return;
    }
    if (props.allowInput || props.searchable) {
      const { value } = evt.target;
      if (value !== inputValue.value) {
        inputValue.value = value;
      }
      callEmit(props.onSearch, value);
      syncMirrorWidth();
    }
  };
  const handleFocus = (evt) => {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  };
  const handleBlur = (evt) => {
    isFocused.value = false;
    callEmit(props.onBlur, evt);
    accessor.markAsBlurred();
  };
  const clearInput = () => {
    const inputElement = inputRef.value;
    if (inputElement) {
      inputElement.value = "";
    }
    inputValue.value = "";
    syncMirrorWidth();
  };
  onMounted(() => syncMirrorWidth());
  return {
    mirrorRef,
    inputValue,
    inputWidth,
    isComposing,
    isFocused,
    handleCompositionStart,
    handleCompositionEnd,
    handleInput,
    handleFocus,
    handleBlur,
    clearInput
  };
}
const optionKey = "__IDUX_SELECT_OPTION";
const SelectOption = () => {
};
SelectOption.displayName = "IxSelectOption";
SelectOption[optionKey] = true;
const optionGroupKey = "__IDUX_SELECT_OPTION_GROUP";
const SelectOptionGroup = () => {
};
SelectOptionGroup.displayName = "IxSelectOptionGroup";
SelectOptionGroup[optionGroupKey] = true;
const keyPrefix = "__IDUX_SELECT_GENERATE_OPTION_KEY_";
function generateOption(value) {
  const rawOption = { label: value, value };
  return { key: keyPrefix + value, label: value, value, rawOption };
}
var __getOwnPropSymbols$2$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$4 = Object.prototype.propertyIsEnumerable;
var __objRest$1$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2$4)
    for (var prop of __getOwnPropSymbols$2$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useMergedOptions(props, slots, config) {
  return computed(() => {
    var _a;
    const { options } = props;
    if (options) {
      return mergeOptions(props, config, options);
    } else {
      return convertOptions((_a = slots.default) == null ? void 0 : _a.call(slots));
    }
  });
}
function useFlattedOptions(props, mergedOptions, inputValue) {
  const searchFilter = useSearchFilter(props);
  return computed(() => {
    const options = mergedOptions.value;
    const searchValue = inputValue.value;
    if (!searchValue) {
      return options;
    }
    const filter = searchFilter.value;
    const filteredOptions = !filter ? options : options.filter((option) => filter(searchValue, option.rawOption));
    const { allowInput } = props;
    if (allowInput) {
      const matchedOption = filteredOptions.find((option) => option.label === searchValue);
      if (!matchedOption) {
        return [generateOption(searchValue), ...filteredOptions];
      }
    }
    return filteredOptions;
  });
}
function mergeOptions(props, config, originalOptions) {
  const { childrenKey = config.childrenKey, labelKey = config.labelKey, valueKey = config.valueKey } = props;
  const mergedOptions = [];
  originalOptions.forEach((item, index) => {
    const { key } = item;
    const label = item[labelKey];
    const children = item[childrenKey];
    if (children && children.length > 0) {
      const groupKey = key != null ? key : index;
      mergedOptions.push({ key: groupKey, label, type: "group", rawOption: item });
      mergedOptions.push(...children.map((option, index2) => {
        var _a;
        return {
          key: (_a = option.key) != null ? _a : `${isSymbol(groupKey) ? String(groupKey) : groupKey}-${index2}`,
          label: option[labelKey],
          value: option[valueKey],
          disabled: option.disabled,
          type: "grouped",
          parentKey: groupKey,
          rawOption: option
        };
      }));
    } else {
      const value = item[valueKey];
      mergedOptions.push({ key: key != null ? key : index, disabled: item.disabled, label, value, rawOption: item });
    }
  });
  return mergedOptions;
}
const filterKeys = [optionKey, optionGroupKey];
function convertOptions(nodes, parentKey, grouped) {
  const mergedOptions = [];
  flattenNode(nodes, { key: filterKeys }).forEach((node, index) => {
    var _a, _b;
    const type = node.type;
    const slots = (_a = node.children) != null ? _a : {};
    const props = (_b = node.props) != null ? _b : {};
    const isOption = type[optionKey];
    if (isOption) {
      const _c = props, { key, disabled, label, value } = _c, additional = __objRest$1$1(_c, ["key", "disabled", "label", "value"]);
      const { label: customLabel, default: customLabel2 } = slots;
      const _disabled = disabled || disabled === "";
      const rawOption = { key, disabled: _disabled, label, value, additional, customLabel: customLabel != null ? customLabel : customLabel2 };
      const option = {
        key: key != null ? key : `${isSymbol(parentKey) ? String(parentKey) : parentKey}-${index}`,
        label,
        value,
        disabled: _disabled,
        rawOption,
        parentKey,
        type: grouped ? "grouped" : void 0
      };
      mergedOptions.push(option);
    } else {
      const _d = props, { key, label, children } = _d, additional = __objRest$1$1(_d, ["key", "label", "children"]);
      const { label: customLabel, default: defaultSlot } = slots;
      const _children = children != null ? children : convertOptions(defaultSlot == null ? void 0 : defaultSlot(), key, true);
      const rawOption = { key, label, children: _children, additional, customLabel };
      mergedOptions.push({ key: key != null ? key : index, label, type: "group", rawOption });
      mergedOptions.push(..._children);
    }
  });
  return mergedOptions;
}
const getDefaultFilter = (props) => {
  return (searchValue, option) => {
    var _a, _b, _c;
    const filterField = (_a = props.labelKey) != null ? _a : "label";
    return (_c = (_b = option[filterField]) == null ? void 0 : _b.toLowerCase().includes(searchValue.toLowerCase())) != null ? _c : false;
  };
};
function useSearchFilter(props) {
  return computed(() => {
    const { searchFilter } = props;
    if (isFunction(searchFilter)) {
      return searchFilter;
    }
    return searchFilter ? getDefaultFilter(props) : false;
  });
}
function useOverlayProps$1(props, triggerRef) {
  const overlayRef = ref();
  const overlayWidth = ref();
  const overlayStyle = computed(() => ({ width: overlayWidth.value }));
  const [overlayOpened, setOverlayOpened] = useControlledProp(props, "open", false);
  const updatePopper = () => {
    var _a, _b;
    overlayWidth.value = convertCssPixel((_a = triggerRef.value) == null ? void 0 : _a.getBoundingClientRect().width);
    (_b = overlayRef.value) == null ? void 0 : _b.updatePopper();
  };
  onMounted(() => {
    if (props.autofocus) {
      setOverlayOpened(true);
    }
    watchEffect(() => {
      if (overlayOpened.value) {
        updatePopper();
      }
    });
    onResize(triggerRef.value, updatePopper);
  });
  onBeforeUnmount(() => {
    offResize(triggerRef.value, updatePopper);
  });
  return { overlayRef, overlayStyle, overlayOpened, setOverlayOpened };
}
function useSelectedState$1(props, accessor, mergedOptions) {
  const selectedValue = computed(() => convertArray(accessor.valueRef.value));
  const selectedOptions = computed(() => {
    const { compareWith } = props;
    const options = mergedOptions.value;
    return selectedValue.value.map((value) => {
      var _a;
      return (_a = options.find((option) => compareWith(option.value, value))) != null ? _a : generateOption(value);
    });
  });
  const setValue = (value) => {
    const currValue = props.multiple ? value : value[0];
    const oldValue = toRaw(accessor.valueRef.value);
    if (currValue !== oldValue) {
      accessor.setValue(currValue);
      callEmit(props.onChange, currValue, oldValue);
    }
  };
  const changeSelected = (value) => {
    const { compareWith, multiple, multipleLimit } = props;
    const currValue = selectedValue.value;
    const targetIndex = currValue.findIndex((item) => compareWith(item, value));
    const isSelected = targetIndex > -1;
    if (!multiple) {
      !isSelected && setValue([value]);
    } else {
      if (isSelected) {
        setValue(currValue.filter((_, index) => targetIndex !== index));
      } else {
        if (currValue.length < multipleLimit) {
          setValue([...currValue, value]);
        } else {
          setValue([...currValue.slice(-multipleLimit + 1), value]);
        }
      }
    }
  };
  const handleItemRemove = (value) => {
    setValue(selectedValue.value.filter((item) => !props.compareWith(value, item)));
  };
  const handleClear = (evt) => {
    evt.stopPropagation();
    setValue([]);
    callEmit(props.onClear, evt);
  };
  return {
    selectedValue,
    selectedOptions,
    changeSelected,
    handleItemRemove,
    handleClear
  };
}
const selectToken = Symbol("selectToken");
function renderOptionLabel(slots, rawOption, label) {
  var _a, _b;
  const labelRender = (_a = rawOption.customLabel) != null ? _a : "optionLabel";
  const labelSlot = isString(labelRender) ? slots[labelRender] : labelRender;
  return (_b = labelSlot == null ? void 0 : labelSlot(rawOption)) != null ? _b : label;
}
const defaultStyle = {
  height: 0,
  width: 0,
  overflow: "hidden"
};
const ListBox = () => {
  const {
    props,
    slots,
    selectedValue,
    mergedOptions,
    activeIndex,
    activeOption
  } = inject(selectToken);
  const currSelectedValue = selectedValue.value;
  const {
    compareWith
  } = props;
  return createVNode("div", {
    "role": "listbox",
    "style": defaultStyle
  }, [renderOption(slots, mergedOptions.value[activeIndex.value - 1], currSelectedValue, compareWith), renderOption(slots, activeOption.value, currSelectedValue, compareWith), renderOption(slots, mergedOptions.value[activeIndex.value + 1], currSelectedValue, compareWith)]);
};
const renderOption = (slots, option, selectedValue, compareWith) => {
  if (!option) {
    return void 0;
  }
  const {
    key,
    label,
    rawOption,
    value
  } = option;
  const selected = compareWith(selectedValue, value);
  return createVNode("div", {
    "key": key,
    "role": "option",
    "aria-label": label,
    "aria-selected": selected
  }, [renderOptionLabel(slots, rawOption, label)]);
};
const defaultCompareWith = (o1, o2) => o1 === o2;
const selectProps = {
  value: IxPropTypes.oneOfType([String, Number, Object]),
  control: controlPropDef,
  open: IxPropTypes.bool,
  allowInput: IxPropTypes.bool.def(false),
  autofocus: IxPropTypes.bool.def(false),
  borderless: IxPropTypes.bool,
  childrenKey: IxPropTypes.string,
  clearable: IxPropTypes.bool.def(false),
  compareWith: IxPropTypes.func().def(defaultCompareWith),
  disabled: IxPropTypes.bool.def(false),
  empty: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  maxLabelCount: IxPropTypes.number.def(Number.MAX_SAFE_INTEGER),
  multiple: IxPropTypes.bool.def(false),
  multipleLimit: IxPropTypes.number.def(Number.MAX_SAFE_INTEGER),
  labelKey: IxPropTypes.string,
  options: IxPropTypes.array(),
  overlayClassName: IxPropTypes.string,
  overlayRender: IxPropTypes.func(),
  placeholder: IxPropTypes.string,
  readonly: IxPropTypes.bool.def(false),
  searchable: IxPropTypes.oneOfType([Boolean, IxPropTypes.oneOf(["overlay"])]).def(false),
  searchFilter: IxPropTypes.oneOfType([Boolean, IxPropTypes.func()]).def(true),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  target: portalTargetDef,
  valueKey: IxPropTypes.string,
  virtual: IxPropTypes.bool.def(false),
  "onUpdate:value": IxPropTypes.emit(),
  "onUpdate:open": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onClear: IxPropTypes.emit(),
  onCompositionStart: IxPropTypes.emit(),
  onCompositionEnd: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onInput: IxPropTypes.emit(),
  onSearch: IxPropTypes.emit(),
  onScroll: IxPropTypes.emit(),
  onScrolledChange: IxPropTypes.emit(),
  onScrolledBottom: IxPropTypes.emit(),
  overlayHeight: IxPropTypes.number.def(256),
  overlayItemHeight: IxPropTypes.number.def(32)
};
const selectorProps = {
  clearable: IxPropTypes.bool,
  suffix: IxPropTypes.string
};
const optionProps = {
  disabled: IxPropTypes.bool,
  index: IxPropTypes.number.isRequired,
  label: IxPropTypes.string,
  type: IxPropTypes.oneOf(["grouped", "group"]),
  rawOption: IxPropTypes.object().isRequired,
  value: IxPropTypes.oneOfType([String, Number, Object])
};
const optionGroupProps = {
  label: IxPropTypes.string,
  rawOption: IxPropTypes.object().isRequired
};
var Option = defineComponent({
  props: optionProps,
  setup(props) {
    const {
      props: selectProps2,
      slots,
      mergedPrefixCls,
      selectedValue,
      handleOptionClick,
      activeOption,
      changeActive
    } = inject(selectToken);
    const isActive = computed(() => {
      var _a;
      const {
        value
      } = props;
      const {
        compareWith
      } = selectProps2;
      const activeValue = (_a = activeOption.value) == null ? void 0 : _a.value;
      return compareWith(activeValue, value);
    });
    const isSelected = computed(() => {
      const {
        value
      } = props;
      const {
        compareWith
      } = selectProps2;
      return selectedValue.value.some((item) => compareWith(item, value));
    });
    const classes = computed(() => {
      const {
        disabled,
        type
      } = props;
      const prefixCls = `${mergedPrefixCls.value}-option`;
      return {
        [prefixCls]: true,
        [`${prefixCls}-active`]: isActive.value,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-grouped`]: type === "grouped",
        [`${prefixCls}-selected`]: isSelected.value
      };
    });
    const handleMouseEnter = () => changeActive(props.index, 0);
    const handleClick = () => handleOptionClick(props.value);
    return () => {
      const {
        disabled,
        label,
        rawOption
      } = props;
      const {
        multiple
      } = selectProps2;
      const selected = isSelected.value;
      const prefixCls = `${mergedPrefixCls.value}-option`;
      return createVNode("div", mergeProps({
        "class": classes.value,
        "onMouseenter": disabled ? void 0 : handleMouseEnter,
        "onClick": disabled ? void 0 : handleClick
      }, rawOption.additional, {
        "aria-label": label,
        "aria-selected": selected
      }), [multiple && createVNode(IxCheckbox, {
        "checked": isSelected.value,
        "disabled": disabled
      }, null), createVNode("span", {
        "class": `${prefixCls}-label`
      }, [renderOptionLabel(slots, rawOption, label)])]);
    };
  }
});
var OptionGroup = defineComponent({
  props: optionGroupProps,
  setup(props) {
    const {
      slots,
      mergedPrefixCls
    } = inject(selectToken);
    return () => {
      var _a;
      const {
        label,
        rawOption
      } = props;
      const prefixCls = `${mergedPrefixCls.value}-option-group`;
      const labelRender = (_a = rawOption.customLabel) != null ? _a : "optionGroupLabel";
      const labelSlot = isString(labelRender) ? slots[labelRender] : labelRender;
      return createVNode("div", mergeProps({
        "class": prefixCls
      }, rawOption.additional, {
        "aria-label": label
      }), [createVNode("span", {
        "class": `${prefixCls}-label`
      }, [labelSlot ? labelSlot(rawOption) : label])]);
    };
  }
});
var __getOwnPropSymbols$1$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$7 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1$7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1$7)
    for (var prop of __getOwnPropSymbols$1$7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1$7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Content$2 = defineComponent({
  setup() {
    const {
      props,
      slots,
      mergedPrefixCls,
      flattedOptions,
      virtualScrollRef,
      scrollToActivated,
      inputValue,
      handleInput,
      handleClear
    } = inject(selectToken);
    onMounted(() => scrollToActivated());
    const handleScrolledChange = (startIndex, endIndex, visibleOptions) => {
      const {
        onScrolledChange
      } = props;
      if (onScrolledChange) {
        callEmit(onScrolledChange, startIndex, endIndex, visibleOptions.map((item) => item.rawOption));
      }
    };
    return () => {
      const {
        overlayHeight,
        overlayItemHeight,
        virtual,
        onScroll,
        onScrolledBottom,
        overlayRender
      } = props;
      const options = flattedOptions.value;
      const children = [createVNode(ListBox, null, null)];
      if (options.length > 0) {
        const itemRender = ({
          item,
          index
        }) => {
          const _a = item, {
            type
          } = _a, rest = __objRest$5(_a, [
            "type"
          ]);
          return type === "group" ? createVNode(OptionGroup, rest, null) : createVNode(Option, mergeProps({
            "index": index
          }, rest), null);
        };
        children.push(createVNode(CdkVirtualScroll, {
          "ref": virtualScrollRef,
          "dataSource": options,
          "height": overlayHeight,
          "itemHeight": overlayItemHeight,
          "itemKey": "key",
          "itemRender": itemRender,
          "virtual": virtual,
          "onScroll": onScroll,
          "onScrolledBottom": onScrolledBottom,
          "onScrolledChange": handleScrolledChange
        }, null));
      } else {
        children.push(createVNode(\u0275Empty, {
          "empty": props.empty
        }, slots));
      }
      if (props.searchable === "overlay") {
        children.unshift(createVNode("div", {
          "class": `${mergedPrefixCls.value}-overlay-search-wrapper`
        }, [createVNode(\u0275Input, {
          "clearable": true,
          "size": "sm",
          "suffix": "search",
          "value": inputValue.value,
          "onInput": handleInput,
          "onClear": handleClear
        }, null)]));
      }
      return overlayRender ? overlayRender(children) : createVNode("div", null, [children]);
    };
  }
});
var Input$1 = defineComponent({
  setup() {
    const {
      props,
      mergedPrefixCls,
      isDisabled,
      inputRef,
      inputValue,
      inputWidth,
      mirrorRef,
      handleCompositionStart,
      handleCompositionEnd,
      handleInput
    } = inject(selectToken);
    const style = computed(() => ({
      width: inputWidth.value
    }));
    const innerStyle = computed(() => {
      const {
        allowInput,
        searchable
      } = props;
      const isOpacity = allowInput || searchable === true;
      return {
        opacity: isOpacity ? void 0 : 0
      };
    });
    return () => {
      const {
        autofocus,
        multiple,
        readonly
      } = props;
      const prefixCls = `${mergedPrefixCls.value}-selector-input`;
      return createVNode("div", {
        "class": prefixCls,
        "style": style.value
      }, [createVNode("input", {
        "ref": inputRef,
        "class": `${prefixCls}-inner`,
        "style": innerStyle.value,
        "autocomplete": "off",
        "autofocus": autofocus,
        "disabled": isDisabled.value,
        "readonly": readonly,
        "value": inputValue.value,
        "onCompositionstart": handleCompositionStart,
        "onCompositionend": handleCompositionEnd,
        "onInput": handleInput
      }, null), multiple && createVNode("span", {
        "ref": mirrorRef,
        "class": `${prefixCls}-mirror`,
        "aria-hidden": true
      }, null)]);
    };
  }
});
const Item$2 = (props, {
  slots
}) => {
  const {
    disabled,
    prefixCls,
    removable,
    value,
    handleItemRemove
  } = props;
  const classes = prefixCls + (disabled ? ` ${prefixCls}-disabled` : "");
  const handleClick = (evt) => {
    evt.stopPropagation();
    handleItemRemove(value);
  };
  return createVNode("div", {
    "class": classes
  }, [createVNode("span", {
    "class": `${prefixCls}-label`
  }, [slots.default()]), removable && createVNode("span", {
    "class": `${prefixCls}-remove`,
    "onClick": handleClick
  }, [createVNode(IxIcon, {
    "name": "close"
  }, null)])]);
};
var Selector$1 = defineComponent({
  props: selectorProps,
  setup(props) {
    const {
      props: selectProps2,
      slots,
      mergedPrefixCls,
      isDisabled,
      selectedValue,
      selectedOptions,
      handleItemRemove,
      handleClear,
      inputValue,
      isComposing
    } = inject(selectToken);
    const selectedItems = computed(() => {
      const {
        maxLabelCount
      } = selectProps2;
      const options = selectedOptions.value;
      const items = options.slice(0, maxLabelCount);
      if (options.length > maxLabelCount) {
        const key = "IDUX_SELECT_MAX_ITEM";
        const label = `+ ${options.length - maxLabelCount} ...`;
        const value = options.slice(maxLabelCount).map((option) => option.rawOption);
        items.push({
          isMax: true,
          key,
          label,
          value
        });
      }
      return items;
    });
    const showItems = computed(() => {
      return selectProps2.multiple || selectedValue.value.length > 0 && !isComposing.value && (!inputValue.value || selectProps2.searchable === "overlay");
    });
    const showPlaceholder = computed(() => {
      return selectedValue.value.length === 0 && !isComposing.value && (!inputValue.value || selectProps2.searchable === "overlay");
    });
    return () => {
      var _a, _b, _c, _d;
      const {
        clearable,
        suffix
      } = props;
      const {
        multiple,
        readonly
      } = selectProps2;
      const disabled = isDisabled.value;
      const prefixCls = `${mergedPrefixCls.value}-selector`;
      const itemPrefixCls = `${prefixCls}-item`;
      const itemNodes = selectedItems.value.map((item) => {
        var _a2, _b2, _c2;
        const {
          key,
          isMax,
          label,
          value,
          rawOption
        } = item;
        const _disabled = disabled || item.disabled;
        const removable = multiple && !_disabled && !readonly && !isMax;
        const itemProps = {
          key,
          disabled: _disabled,
          prefixCls: itemPrefixCls,
          removable,
          value,
          handleItemRemove,
          title: label
        };
        let labelNode;
        if (isMax) {
          if (process.env.NODE_ENV !== "production" && slots.maxLabel) {
            Logger.warn("components/select", "slot `maxLabel` was deprecated, please use slot `overflowedLabel` instead");
          }
          const overflowedLabelSlot = (_a2 = slots.overflowedLabel) != null ? _a2 : slots.maxLabel;
          labelNode = (_b2 = overflowedLabelSlot == null ? void 0 : overflowedLabelSlot(item.value)) != null ? _b2 : label;
        } else {
          if (process.env.NODE_ENV !== "production" && slots.label) {
            Logger.warn("components/select", "slots `label` was deprecated, please use slots `selectedLabel` instead");
          }
          const selectedLabelSlot = (_c2 = slots.label) != null ? _c2 : slots.selectedLabel;
          labelNode = selectedLabelSlot ? selectedLabelSlot(rawOption) : renderOptionLabel(slots, rawOption, label);
        }
        return createVNode(Item$2, itemProps, {
          default: () => [labelNode]
        });
      });
      return createVNode("div", {
        "class": prefixCls
      }, [showItems.value && itemNodes, createVNode(Input$1, null, null), showPlaceholder.value && createVNode("div", {
        "class": `${prefixCls}-placeholder`
      }, [createTextVNode(" "), (_b = (_a = slots.placeholder) == null ? void 0 : _a.call(slots)) != null ? _b : selectProps2.placeholder]), (slots.suffix || suffix) && createVNode("div", {
        "class": `${prefixCls}-suffix`
      }, [(_d = (_c = slots.suffix) == null ? void 0 : _c.call(slots)) != null ? _d : createVNode(IxIcon, {
        "name": suffix
      }, null)]), clearable && createVNode("div", {
        "class": `${prefixCls}-clear`,
        "onClick": handleClear
      }, [createVNode(IxIcon, {
        "name": "close-circle"
      }, null)])]);
    };
  }
});
const hiddenBoxStyle$1 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0
};
var Trigger$2 = defineComponent({
  setup() {
    const {
      props,
      slots,
      config,
      mergedPrefixCls,
      focusMonitor,
      triggerRef,
      isDisabled,
      selectedValue,
      isFocused,
      handleFocus,
      handleBlur,
      overlayOpened,
      setOverlayOpened,
      activeIndex,
      activeOption,
      changeActive,
      changeSelected
    } = inject(selectToken);
    const formContext = inject(FORM_TOKEN, null);
    const clearable = computed(() => {
      return !isDisabled.value && !props.readonly && props.clearable && selectedValue.value.length > 0;
    });
    const searchable = computed(() => {
      return !isDisabled.value && !props.readonly && props.searchable;
    });
    const suffix = computed(() => {
      const {
        suffix: suffix2
      } = props;
      if (suffix2) {
        return suffix2;
      }
      return props.searchable === true && isFocused.value ? "search" : config.suffix;
    });
    const classes = computed(() => {
      var _a;
      const {
        borderless = config.borderless,
        readonly,
        multiple,
        size = (_a = formContext == null ? void 0 : formContext.size.value) != null ? _a : config.size
      } = props;
      const disabled = isDisabled.value;
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-borderless`]: borderless,
        [`${prefixCls}-clearable`]: clearable.value,
        [`${prefixCls}-readonly`]: readonly,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-opened`]: overlayOpened.value,
        [`${prefixCls}-multiple`]: multiple,
        [`${prefixCls}-single`]: !multiple,
        [`${prefixCls}-searchable`]: searchable.value,
        [`${prefixCls}-with-suffix`]: slots.suffix || suffix.value,
        [`${prefixCls}-${size}`]: true
      };
    });
    const handleClick = () => {
      const currOpened = overlayOpened.value;
      const notAllowedClick = isDisabled.value || props.readonly;
      if (notAllowedClick || currOpened && searchable.value) {
        return;
      }
      setOverlayOpened(!currOpened);
    };
    const handleKeyDown = (evt) => {
      var _a;
      switch (evt.code) {
        case "ArrowUp":
          evt.preventDefault();
          changeActive(activeIndex.value - 1, -1);
          break;
        case "ArrowDown":
          evt.preventDefault();
          changeActive(activeIndex.value + 1, 1);
          break;
        case "Enter":
          evt.preventDefault();
          changeSelected((_a = activeOption.value) == null ? void 0 : _a.value);
          break;
        case "Escape":
          evt.preventDefault();
          setOverlayOpened(false);
          break;
      }
    };
    onMounted(() => {
      watch(focusMonitor.monitor(triggerRef.value, true), (evt) => {
        const {
          origin,
          event
        } = evt;
        if (event) {
          if (origin) {
            handleFocus(event);
          } else {
            handleBlur(event);
          }
        }
      });
    });
    onBeforeUnmount(() => focusMonitor.stopMonitoring(triggerRef.value));
    return () => {
      return createVNode("div", {
        "ref": triggerRef,
        "class": classes.value,
        "onClick": handleClick,
        "onKeydown": handleKeyDown
      }, [isFocused.value && !overlayOpened.value && createVNode("span", {
        "style": hiddenBoxStyle$1,
        "aria-live": "polite"
      }, [selectedValue.value.join(", ")]), createVNode(Selector$1, {
        "clearable": clearable.value,
        "suffix": suffix.value
      }, null)]);
    };
  }
});
var __defProp$e = Object.defineProperty;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
const defaultOffset$2 = [0, 8];
var Select = defineComponent({
  name: "IxSelect",
  inheritAttrs: false,
  props: selectProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-select`);
    const config = useGlobalConfig$1("select");
    const focusMonitor = useSharedFocusMonitor();
    const {
      elementRef: inputRef,
      focus,
      blur
    } = useFormElement();
    const virtualScrollRef = ref();
    const scrollTo = (options) => {
      var _a;
      (_a = virtualScrollRef.value) == null ? void 0 : _a.scrollTo(options);
    };
    expose({
      focus,
      blur,
      scrollTo
    });
    const triggerRef = ref();
    const {
      overlayRef,
      overlayStyle,
      overlayOpened,
      setOverlayOpened
    } = useOverlayProps$1(props, triggerRef);
    const accessor = useFormAccessor();
    const isDisabled = computed(() => accessor.disabled.value);
    const mergedOptions = useMergedOptions(props, slots, config);
    const inputStateContext = useInputState$1(props, inputRef, accessor);
    const {
      inputValue,
      clearInput
    } = inputStateContext;
    const flattedOptions = useFlattedOptions(props, mergedOptions, inputValue);
    const selectedStateContext = useSelectedState$1(props, accessor, mergedOptions);
    const {
      selectedValue,
      changeSelected
    } = selectedStateContext;
    const activeStateContext = useActiveState(props, flattedOptions, selectedValue, inputValue, scrollTo);
    const handleOptionClick = (value) => {
      changeSelected(value);
      if (props.multiple) {
        focus();
        clearInput();
      } else {
        setOverlayOpened(false);
      }
    };
    provide(selectToken, __spreadValues$e(__spreadValues$e(__spreadValues$e({
      props,
      slots,
      config,
      mergedPrefixCls,
      focusMonitor,
      triggerRef,
      inputRef,
      virtualScrollRef,
      overlayOpened,
      setOverlayOpened,
      accessor,
      isDisabled,
      mergedOptions,
      flattedOptions,
      handleOptionClick
    }, selectedStateContext), inputStateContext), activeStateContext));
    watch(overlayOpened, (opened) => {
      if (!opened && props.allowInput && inputValue.value) {
        changeSelected(inputValue.value);
      }
      opened ? focus() : blur();
      clearInput();
    });
    const classes = computed(() => {
      const {
        overlayClassName
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-overlay`]: true,
        [overlayClassName || ""]: !!overlayClassName
      });
    });
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-overlay-container`;
    });
    return () => {
      const renderTrigger = () => createVNode(Trigger$2, attrs, null);
      const renderContent = () => createVNode(Content$2, null, null);
      const overlayProps = {
        "onUpdate:visible": setOverlayOpened
      };
      return createVNode(\u0275Overlay, mergeProps({
        "ref": overlayRef
      }, overlayProps, {
        "visible": overlayOpened.value,
        "class": classes.value,
        "style": overlayStyle.value,
        "clickOutside": true,
        "disabled": isDisabled.value || props.readonly,
        "offset": defaultOffset$2,
        "placement": "bottom",
        "target": target.value,
        "trigger": "manual"
      }), {
        default: renderTrigger,
        content: renderContent
      });
    };
  }
});
const IxSelect = Select;
const IxSelectOption = SelectOption;
const IxSelectOptionGroup = SelectOptionGroup;

function useItems(activeIndex, lastIndex) {
  return computed(() => {
    const currActiveIndex = activeIndex.value;
    const currLastIndex = lastIndex.value;
    let items;
    if (currLastIndex <= 9) {
      items = generatePage(1, currLastIndex);
    } else {
      items = generateRangeItem(currActiveIndex, currLastIndex);
    }
    const prevItem = { type: "prev", disabled: currActiveIndex === 1 };
    const nextItem = { type: "next", disabled: currActiveIndex === currLastIndex };
    return [prevItem, ...items, nextItem];
  });
}
const generatePage = (start, end) => {
  const list = [];
  for (let index = start; index <= end; index++) {
    list.push({ index, type: "page" });
  }
  return list;
};
const generateRangeItem = (pageIndex, lastIndex) => {
  let listOfRange = [];
  const prevFiveItem = { type: "prev5" };
  const nextFiveItem = { type: "next5" };
  if (pageIndex < 5) {
    listOfRange = [...generatePage(2, 5), nextFiveItem];
  } else if (pageIndex < lastIndex - 3) {
    listOfRange = [prevFiveItem, ...generatePage(pageIndex - 2, pageIndex + 2), nextFiveItem];
  } else {
    listOfRange = [prevFiveItem, ...generatePage(lastIndex - 4, lastIndex - 1)];
  }
  const firstPageItem = generatePage(1, 1);
  const lastPageItem = generatePage(lastIndex, lastIndex);
  return [...firstPageItem, ...listOfRange, ...lastPageItem];
};
function useJumpToIndex(activeIndex, changePageIndex, simple) {
  const jumpToIndex = (evt) => {
    const target = evt.target;
    const index = Math.floor(convertNumber(target.value, activeIndex.value));
    changePageIndex(index);
    if (!simple.value) {
      target.value = "";
    }
  };
  return withKeys(jumpToIndex, ["enter"]);
}
function usePages(props, config) {
  var _a;
  const [activeIndex, setActiveIndex] = useControlledProp(props, "pageIndex", 1);
  const [activeSize, setActiveSize] = useControlledProp(props, "pageSize", (_a = props.pageSize) != null ? _a : config.pageSize);
  const lastIndex = computed(() => Math.ceil(props.total / activeSize.value));
  const changePageIndex = (index) => {
    const validIndex = validatePageIndex(index, lastIndex.value);
    if (validIndex !== activeIndex.value) {
      setActiveIndex(validIndex);
      callEmit(props.onChange, validIndex, activeSize.value);
    }
  };
  const changePageSize = (size) => {
    setActiveSize(size);
    callEmit(props.onChange, activeIndex.value, size);
  };
  watch([activeIndex, lastIndex], ([currPageIndex, currLastIndex]) => {
    if (currPageIndex > currLastIndex) {
      changePageIndex(currLastIndex);
    }
  }, { immediate: true });
  return { activeIndex, activeSize, lastIndex, changePageIndex, changePageSize };
}
const validatePageIndex = (index, lastIndex) => {
  if (index > lastIndex) {
    return lastIndex;
  } else if (index < 1) {
    return 1;
  } else {
    return index;
  }
};
const paginationToken = Symbol("paginationToken");
const paginationProps = {
  pageIndex: IxPropTypes.number,
  pageSize: IxPropTypes.number,
  disabled: IxPropTypes.bool.def(false),
  pageSizes: IxPropTypes.arrayOf(Number),
  showQuickJumper: IxPropTypes.bool,
  showSizeChanger: IxPropTypes.bool,
  showTitle: IxPropTypes.bool,
  showTotal: IxPropTypes.bool,
  simple: IxPropTypes.bool,
  size: IxPropTypes.oneOf(["sm", "md"]),
  total: IxPropTypes.number.def(0),
  "onUpdate:pageIndex": IxPropTypes.emit(),
  "onUpdate:pageSize": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
};
const paginationItemProps = {
  disabled: IxPropTypes.bool,
  index: IxPropTypes.number,
  type: IxPropTypes.oneOf(["page", "prev", "next", "prev5", "next5"]).isRequired
};
const iconMap = {
  prev: "left",
  next: "right",
  prev5: "double-left",
  next5: "double-right",
  page: ""
};
const indexDiffMap = {
  next: 1,
  prev: -1,
  prev5: -5,
  next5: 5
};
var Item$1 = defineComponent({
  props: paginationItemProps,
  setup(props) {
    const {
      props: paginationProps2,
      slots,
      config,
      locale,
      mergedPrefixCls,
      activeIndex,
      changePageIndex
    } = inject(paginationToken);
    const isActive = computed(() => activeIndex.value === props.index);
    const isDisabled = computed(() => props.disabled || paginationProps2.disabled);
    const showTitle = computed(() => {
      var _a;
      return (_a = paginationProps2.showTitle) != null ? _a : config.showTitle;
    });
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-item`;
      return {
        [prefixCls]: true,
        [`${prefixCls}-active`]: isActive.value
      };
    });
    const title = computed(() => {
      if (!showTitle.value) {
        return void 0;
      }
      const {
        type,
        index
      } = props;
      if (type === "page") {
        return index.toString();
      }
      return locale.value[type];
    });
    const onClick = () => {
      if (isDisabled.value) {
        return;
      }
      const {
        type,
        index
      } = props;
      let newIndex;
      if (type === "page") {
        newIndex = index;
      } else {
        newIndex = activeIndex.value + indexDiffMap[type];
      }
      changePageIndex(newIndex);
    };
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-item`;
      const {
        index,
        type
      } = props;
      const disabled = isDisabled.value;
      const active = isActive.value;
      let original;
      const icon = iconMap[type];
      const commonButtonProps = {
        mode: "text",
        size: "sm",
        shape: "circle"
      };
      if (props.type === "prev5" || type === "next5") {
        original = createVNode("span", {
          "class": `${prefixCls}-jumper`
        }, [createVNode(IxButton, mergeProps(commonButtonProps, {
          "icon": icon,
          "disabled": disabled
        }), null), createVNode(IxButton, mergeProps(commonButtonProps, {
          "class": `${prefixCls}-ellipsis`,
          "icon": "ellipsis",
          "disabled": disabled
        }), null)]);
      } else if (!isNil(index)) {
        original = createVNode(IxButton, mergeProps(commonButtonProps, {
          "icon": icon,
          "disabled": disabled
        }), {
          default: () => [index]
        });
      } else {
        original = createVNode(IxButton, mergeProps(commonButtonProps, {
          "icon": icon,
          "disabled": disabled
        }), null);
      }
      const children = slots.item ? slots.item({
        index,
        type,
        active,
        disabled,
        original
      }) : original;
      return createVNode("li", {
        "class": classes.value,
        "title": title.value,
        "onClick": onClick
      }, [children]);
    };
  }
});
var Jumper = defineComponent({
  setup() {
    const {
      props,
      locale,
      mergedPrefixCls,
      size,
      jumpToIndex
    } = inject(paginationToken);
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-jumper`;
      const {
        disabled
      } = props;
      const {
        jumpTo,
        page
      } = locale.value;
      return createVNode("li", {
        "class": prefixCls
      }, [jumpTo, createVNode(\u0275Input, {
        "disabled": disabled,
        "size": size.value,
        "onKeydown": jumpToIndex
      }, null), page]);
    };
  }
});
var Sizes = defineComponent({
  setup() {
    const {
      props,
      config,
      locale,
      mergedPrefixCls,
      size,
      activeSize,
      changePageSize
    } = inject(paginationToken);
    const sizeOptions = computed(() => {
      const {
        pageSizes = config.pageSizes
      } = props;
      const {
        itemsPerPage
      } = locale.value;
      return pageSizes.map((size2) => {
        return {
          value: size2,
          label: `${size2} ${itemsPerPage}`
        };
      });
    });
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-sizes`;
      return createVNode("li", {
        "class": prefixCls
      }, [createVNode(IxSelect, {
        "disabled": props.disabled,
        "options": sizeOptions.value,
        "size": size.value,
        "value": activeSize.value,
        "onChange": changePageSize
      }, null)]);
    };
  }
});
var Total = defineComponent({
  setup() {
    const {
      props,
      slots,
      locale,
      activeIndex,
      activeSize,
      mergedPrefixCls
    } = inject(paginationToken);
    const range = computed(() => {
      const currIndex = activeIndex.value;
      const currSize = activeSize.value;
      const firstIndex = (currIndex - 1) * currSize + 1;
      const lastIndex = Math.min(currIndex * currSize, props.total);
      return [firstIndex, lastIndex];
    });
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-total`;
      const {
        total
      } = props;
      const {
        totalPrefix,
        totalSuffix
      } = locale.value;
      const children = slots.total ? slots.total({
        total,
        range: range.value,
        prefix: totalPrefix,
        suffix: totalSuffix
      }) : `${totalPrefix} ${total} ${totalSuffix}`;
      return createVNode("li", {
        "class": prefixCls
      }, [children]);
    };
  }
});
var Pagination = defineComponent({
  name: "IxPagination",
  props: paginationProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-pagination`);
    const config = useGlobalConfig$1("pagination");
    const locale = getLocale("pagination");
    const showTotal = computed(() => {
      var _a;
      return (_a = props.showTotal) != null ? _a : config.showTotal;
    });
    const simple = computed(() => {
      var _a;
      return (_a = props.simple) != null ? _a : config.simple;
    });
    const size = computed(() => {
      var _a;
      return (_a = props.size) != null ? _a : config.size;
    });
    const showQuickJumper = computed(() => {
      var _a;
      return (_a = props.showQuickJumper) != null ? _a : config.showQuickJumper;
    });
    const showSizeChanger = computed(() => {
      var _a;
      return (_a = props.showSizeChanger) != null ? _a : config.showSizeChanger;
    });
    const {
      activeIndex,
      activeSize,
      lastIndex,
      changePageIndex,
      changePageSize
    } = usePages(props, config);
    const items = useItems(activeIndex, lastIndex);
    const jumpToIndex = useJumpToIndex(activeIndex, changePageIndex, simple);
    provide(paginationToken, {
      props,
      slots,
      config,
      locale,
      mergedPrefixCls,
      size,
      activeIndex,
      activeSize,
      lastIndex,
      changePageIndex,
      changePageSize,
      jumpToIndex
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-simple`]: simple.value,
        [`${prefixCls}-${size.value}`]: true
      });
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const children = showTotal.value ? [createVNode(Total, null, null)] : [];
      if (simple.value) {
        children.push(createVNode(Item$1, {
          "disabled": activeIndex.value === 1,
          "type": "prev"
        }, null));
        children.push(createVNode("li", {
          "class": `${prefixCls}-item`
        }, [createVNode(\u0275Input, {
          "disabled": props.disabled,
          "size": size.value,
          "value": activeIndex.value.toString(),
          "onKeydown": jumpToIndex
        }, null), createVNode("span", {
          "class": `${prefixCls}-item-slash`
        }, [createTextVNode("/")]), createVNode("span", null, [lastIndex.value])]));
        children.push(createVNode(Item$1, {
          "disabled": activeIndex.value === lastIndex.value,
          "type": "next"
        }, null));
      } else {
        items.value.forEach((item) => children.push(createVNode(Item$1, mergeProps({
          "key": item.type + "-" + item.index
        }, item), null)));
        showSizeChanger.value && children.push(createVNode(Sizes, null, null));
        showQuickJumper.value && children.push(createVNode(Jumper, null, null));
      }
      return createVNode("ul", {
        "class": classes.value
      }, [children]);
    };
  }
});
const IxPagination = Pagination;

const popconfirmToken = Symbol("popconfirmToken");
var __defProp$1$4 = Object.defineProperty;
var __getOwnPropSymbols$1$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$4 = (obj, key, value) => key in obj ? __defProp$1$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$6.call(b, prop))
      __defNormalProp$1$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$6)
    for (var prop of __getOwnPropSymbols$1$6(b)) {
      if (__propIsEnum$1$6.call(b, prop))
        __defNormalProp$1$4(a, prop, b[prop]);
    }
  return a;
};
var PopconfirmContent = defineComponent({
  setup() {
    const {
      props,
      slots,
      mergedPrefixCls,
      cancelLoading,
      okLoading,
      cancel,
      ok
    } = inject(popconfirmToken);
    const locale = getLocale("popconfirm");
    const cancelText = computed(() => {
      var _a;
      return (_a = props.cancelText) != null ? _a : locale.value.cancelText;
    });
    const okText = computed(() => {
      var _a;
      return (_a = props.okText) != null ? _a : locale.value.okText;
    });
    const cancelButton = computed(() => {
      return __spreadValues$1$4({
        size: "sm"
      }, props.cancelButton);
    });
    const okButton = computed(() => {
      return __spreadValues$1$4({
        size: "sm"
      }, props.okButton);
    });
    return () => {
      var _a, _b, _c, _d;
      const prefixCls = mergedPrefixCls.value;
      if (slots.title || props.title)
        ;
      return createVNode("div", {
        "class": `${prefixCls}-wrapper`
      }, [createVNode("div", {
        "class": `${prefixCls}-title`
      }, [(_b = (_a = slots.icon) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(IxIcon, {
        "name": props.icon
      }, null), createVNode("span", null, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title])]), createVNode(\u0275Footer, {
        "class": `${prefixCls}-footer`,
        "cancel": cancel,
        "cancelButton": cancelButton.value,
        "cancelLoading": cancelLoading.value,
        "cancelText": cancelText.value,
        "footer": props.footer,
        "ok": ok,
        "okButton": okButton.value,
        "okLoading": okLoading.value,
        "okText": okText.value
      }, slots)]);
    };
  }
});
var __defProp$d = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
const popconfirmProps = __spreadProps$a(__spreadValues$d({}, tooltipProps), {
  cancelButton: IxPropTypes.object(),
  cancelText: IxPropTypes.string,
  okButton: IxPropTypes.object(),
  okText: IxPropTypes.string,
  icon: IxPropTypes.string.def("exclamation-circle-filled"),
  footer: IxPropTypes.oneOfType([Boolean, IxPropTypes.array(), IxPropTypes.vNode]).def(true),
  "onUpdate:visible": IxPropTypes.emit(),
  onCancel: IxPropTypes.emit(),
  onOk: IxPropTypes.emit()
});
var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Popconfirm = defineComponent({
  name: "IxPopconfirm",
  props: popconfirmProps,
  setup(props, {
    slots,
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-popconfirm`);
    const config = useGlobalConfig$1("popconfirm");
    const {
      overlayRef,
      updatePopper,
      visible,
      setVisible,
      overlayProps
    } = useTooltipOverlay(props, config, mergedPrefixCls);
    const {
      cancelLoading,
      okLoading,
      cancel,
      ok
    } = useTrigger(props, setVisible);
    provide(popconfirmToken, {
      props,
      slots,
      mergedPrefixCls,
      visible,
      cancelLoading,
      okLoading,
      cancel,
      ok
    });
    expose({
      updatePopper,
      cancel,
      ok
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(\u0275Overlay, mergeProps({
        "ref": overlayRef,
        "class": prefixCls,
        "transitionName": `${common.prefixCls}-fade`
      }, overlayProps.value), {
        default: slots.default,
        content: () => createVNode(PopconfirmContent, null, null)
      });
    };
  }
});
function useTrigger(props, setVisible) {
  const cancelLoading = ref(false);
  const cancel = (evt) => __async$5(this, null, function* () {
    let result = callEmit(props.onCancel, evt);
    if (isPromise(result)) {
      cancelLoading.value = true;
      result = yield result;
      cancelLoading.value = false;
    }
    if (result === false) {
      return;
    }
    setVisible(false);
  });
  const okLoading = ref(false);
  const ok = (evt) => __async$5(this, null, function* () {
    let result = callEmit(props.onOk, evt);
    if (isPromise(result)) {
      okLoading.value = true;
      result = yield result;
      okLoading.value = false;
    }
    if (result === false) {
      return;
    }
    setVisible(false);
  });
  return {
    cancelLoading,
    okLoading,
    cancel,
    ok
  };
}
const IxPopconfirm = Popconfirm;

var __defProp$c = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
const popoverProps = __spreadProps$9(__spreadValues$c({}, tooltipProps), {
  closable: IxPropTypes.bool.def(false),
  closeIcon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  content: IxPropTypes.string
});
var Popover = defineComponent({
  name: "IxPopover",
  props: popoverProps,
  setup(props, {
    slots,
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-popover`);
    const config = useGlobalConfig$1("popover");
    const {
      overlayRef,
      updatePopper,
      overlayProps,
      visible,
      setVisible
    } = useTooltipOverlay(props, config, mergedPrefixCls);
    expose({
      updatePopper
    });
    const closeIcon = computed(() => {
      var _a;
      return (_a = props.closeIcon) != null ? _a : config.closeIcon;
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(\u0275Overlay, mergeProps({
        "ref": overlayRef,
        "class": prefixCls
      }, overlayProps.value, {
        "visible": visible.value,
        "transitionName": `${common.prefixCls}-fade`
      }), {
        default: slots.default,
        content: () => renderContent(props, slots, closeIcon, setVisible, prefixCls)
      });
    };
  }
});
const renderContent = (props, slots, closeIcon, setVisibility, prefixCls) => {
  var _a, _b, _c;
  if (!(slots.header || props.header || slots.content || props.content)) {
    return null;
  }
  const children = [];
  if (slots.header || props.header) {
    children.push(createVNode(\u0275Header, {
      "closable": props.closable,
      "closeIcon": closeIcon.value,
      "header": (_a = props.header) != null ? _a : props.title,
      "onClose": () => setVisibility(false)
    }, {
      header: slots.header
    }));
  }
  if (slots.content || props.content) {
    children.push(createVNode("div", {
      "class": `${prefixCls}-content`
    }, [(_c = (_b = slots.content) == null ? void 0 : _b.call(slots)) != null ? _c : props.content]));
  }
  return createVNode("div", {
    "class": `${prefixCls}-wrapper`
  }, [children]);
};
const IxPopover = Popover;

const defaultIcons = {
  success: "check",
  exception: "close"
};
function useIcons(props, config) {
  return computed(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
      success: (_d = (_c = (_a = props.icons) == null ? void 0 : _a.success) != null ? _c : (_b = config.icon) == null ? void 0 : _b.success) != null ? _d : defaultIcons.success,
      exception: (_h = (_g = (_e = props.icons) == null ? void 0 : _e.exception) != null ? _g : (_f = config.icon) == null ? void 0 : _f.exception) != null ? _h : defaultIcons.exception
    };
  });
}
var __getOwnPropSymbols$2$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$3 = Object.prototype.propertyIsEnumerable;
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2$3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2$3)
    for (var prop of __getOwnPropSymbols$2$3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2$3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const fullPercent = 100;
function convertPercent(percent) {
  if (!percent || percent < 0) {
    return 0;
  }
  if (percent > fullPercent) {
    return fullPercent;
  }
  return parseInt(percent, 10);
}
const sortGradient = (gradients) => {
  const tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const formattedKey = parseFloat(key.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  return tempArr.sort((a, b) => a.key - b.key);
};
const handleGradient = (strokeColor) => {
  const _a = strokeColor, {
    from = "#3366ff",
    to = "#3366ff",
    direction = "to right"
  } = _a, rest = __objRest$4(_a, [
    "from",
    "to",
    "direction"
  ]);
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest).map(({ key, value }) => `${value} ${key}%`).join(", ");
    return `linear-gradient(${direction}, ${sortedGradients})`;
  }
  return `linear-gradient(${direction}, ${from}, ${to})`;
};
const handleCircleGradient = (strokeColor) => {
  return sortGradient(strokeColor).map(({ key, value }) => ({ offset: `${key}%`, color: value }));
};
const useInfo = (props, config, progressStatus2, percent, success) => {
  var _a;
  const formatFn = (_a = props.format) != null ? _a : config.format;
  const formattedText = computed(() => formatFn(percent.value, success.value.percent));
  const showSuccessIcon = computed(() => progressStatus2.value === "success" || progressStatus2.value === "normal" && percent.value === fullPercent);
  const showExceptionIcon = computed(() => progressStatus2.value === "exception");
  const showFormat = computed(() => isFunction(props.format) || !(showSuccessIcon.value || showExceptionIcon.value));
  return {
    formattedText,
    showFormat,
    showSuccessIcon,
    showExceptionIcon
  };
};
const progressContext = Symbol("progressContext");
var ProgressInfo = defineComponent({
  setup() {
    const {
      props,
      config,
      slots,
      mergedPrefixCls,
      status,
      percent,
      formattedSuccess
    } = inject(progressContext);
    const {
      formattedText,
      showSuccessIcon,
      showExceptionIcon,
      showFormat
    } = useInfo(props, config, status, percent, formattedSuccess);
    const icons = useIcons(props, config);
    const renderInfo = () => {
      if (showFormat.value) {
        return formattedText.value;
      }
      const prefixCls = mergedPrefixCls.value;
      if (showSuccessIcon.value) {
        return renderIcon$3(icons.value.success, `${prefixCls}-success-icon`);
      }
      if (showExceptionIcon.value) {
        return renderIcon$3(icons.value.exception, `${prefixCls}-exception-icon`);
      }
      return null;
    };
    return () => {
      var _a;
      if (props.hideInfo) {
        return null;
      }
      const slot = (_a = slots.format) != null ? _a : slots.default;
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-info`
      }, [slot ? slot({
        percent: percent.value,
        successPercent: formattedSuccess.value.percent
      }) : renderInfo()]);
    };
  }
});
function renderIcon$3(icon, cls) {
  if (isString(icon)) {
    return createVNode(IxIcon, {
      "class": cls,
      "name": icon
    }, null);
  }
  return icon;
}
var __defProp$1$3 = Object.defineProperty;
var __defProps$1$2 = Object.defineProperties;
var __getOwnPropDescs$1$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$3 = (obj, key, value) => key in obj ? __defProp$1$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$5.call(b, prop))
      __defNormalProp$1$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$5)
    for (var prop of __getOwnPropSymbols$1$5(b)) {
      if (__propIsEnum$1$5.call(b, prop))
        __defNormalProp$1$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$2 = (a, b) => __defProps$1$2(a, __getOwnPropDescs$1$2(b));
function useProps(props, config) {
  return computed(() => {
    var _a, _b, _c;
    return __spreadProps$1$2(__spreadValues$1$3({}, props), {
      size: (_a = props.size) != null ? _a : config.size,
      strokeWidth: (_b = props.strokeWidth) != null ? _b : config.strokeWidth,
      strokeLinecap: (_c = props.strokeLinecap) != null ? _c : config.strokeLinecap
    });
  });
}
const defaultStrokeWidth = 6;
var Circle = defineComponent({
  name: "IxProgressCircle",
  setup() {
    const {
      props,
      config,
      mergedPrefixCls,
      percent,
      formattedSuccess
    } = inject(progressContext);
    const circleMergedPrefixCls = computed(() => `${mergedPrefixCls.value}-circle`);
    const computedProps = useProps(props, config);
    const strokeWidth = computed(() => {
      var _a;
      return convertNumber((_a = computedProps.value.strokeWidth) != null ? _a : config.defaultCircleStrokeWidth, defaultStrokeWidth);
    });
    const isGradient = computed(() => isObject(computedProps.value.strokeColor));
    const linearGradientId = ref(`ix-progress-gradient-${uniqueId()}`);
    const calcSharedProperties = computed(() => {
      var _a, _b;
      const isCircle = computedProps.value.type === "circle";
      const radius = 50 - strokeWidth.value / 2;
      return {
        isGradient: isGradient.value,
        percent: percent.value,
        linearGradientId: linearGradientId.value,
        radius,
        gapPosition: (_a = computedProps.value.gapPosition) != null ? _a : isCircle ? "top" : "bottom",
        len: Math.PI * 2 * radius,
        gapDegree: convertNumber((_b = computedProps.value.gapDegree) != null ? _b : isCircle ? 0 : 75)
      };
    });
    const circleGradient = computed(() => {
      return isGradient.value ? handleCircleGradient(computedProps.value.strokeColor) : [];
    });
    const pathString = usePathString(calcSharedProperties);
    const trailPathStyle = useTrailPathStyle(calcSharedProperties);
    const strokePath = useCirclePath(calcSharedProperties, computedProps.value, percent, formattedSuccess);
    const trailPathAttr = computed(() => ({
      stroke: "#f5f5f5",
      "fill-opacity": "0",
      "stroke-linecap": computedProps.value.strokeLinecap,
      "stroke-width": strokeWidth.value,
      d: pathString.value
    }));
    const strokePathAttr = computed(() => ({
      "fill-opacity": "0",
      "stroke-linecap": computedProps.value.strokeLinecap,
      "stroke-width": computedProps.value.percent ? strokeWidth.value : 0,
      d: pathString.value
    }));
    const circleClasses = computed(() => {
      const prefixCls = circleMergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-gradient`]: isGradient.value
      };
    });
    const circleStyle = computed(() => ({
      width: computedProps.value.width && `${computedProps.value.width}px`,
      height: computedProps.value.width && `${computedProps.value.width}px`,
      fontSize: computedProps.value.width && `${convertNumber(computedProps.value.width) * 0.15 + 6}px`
    }));
    const renderDefs = () => {
      if (!isGradient.value) {
        return null;
      }
      return createVNode("defs", null, [createVNode("linearGradient", {
        "id": linearGradientId.value,
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [circleGradient.value.map((gradient) => createVNode("stop", {
        "offset": gradient.offset,
        "stop-color": gradient.color
      }, null))])]);
    };
    const renderStrokePath = () => strokePath.value.map((p) => createVNode("path", mergeProps({
      "class": [`${circleMergedPrefixCls.value}-path`, ...p.strokeClasses],
      "style": p.strokePathStyle,
      "stroke": p.stroke
    }, strokePathAttr.value), null));
    return () => createVNode("div", {
      "class": circleClasses.value,
      "style": circleStyle.value
    }, [createVNode("svg", {
      "viewBox": "0 0 100 100"
    }, [renderDefs(), createVNode("path", mergeProps({
      "class": `${circleMergedPrefixCls.value}-trail`,
      "style": trailPathStyle.value
    }, trailPathAttr.value), null), renderStrokePath()]), createVNode(ProgressInfo, null, null)]);
  }
});
function usePathString(calcSharedProperties) {
  return computed(() => {
    const {
      radius,
      gapPosition
    } = calcSharedProperties.value;
    let beginPositionX = 0;
    let beginPositionY = -radius;
    let endPositionX = 0;
    let endPositionY = radius * -2;
    switch (gapPosition) {
      case "left":
        beginPositionX = -radius;
        beginPositionY = 0;
        endPositionX = radius * 2;
        endPositionY = 0;
        break;
      case "right":
        beginPositionX = radius;
        beginPositionY = 0;
        endPositionX = radius * -2;
        endPositionY = 0;
        break;
      case "bottom":
        beginPositionY = radius;
        endPositionY = radius * 2;
        break;
    }
    return `M 50,50 m ${beginPositionX},${beginPositionY}
       a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
       a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
  });
}
function useTrailPathStyle(calcSharedProperties) {
  return computed(() => {
    const {
      len,
      gapDegree
    } = calcSharedProperties.value;
    return {
      strokeDasharray: `${len - gapDegree}px ${len}px`,
      strokeDashoffset: `-${gapDegree / 2}px`,
      transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s"
    };
  });
}
function useCirclePath(calcSharedProperties, props, percent, success) {
  return computed(() => {
    var _a;
    const successPercent = success.value.percent;
    const {
      gapDegree,
      len,
      isGradient,
      linearGradientId
    } = calcSharedProperties.value;
    const strokeProgress = successPercent > 0 ? [successPercent, percent.value] : [percent.value];
    const successColor = (_a = props.success) == null ? void 0 : _a.strokeColor;
    return strokeProgress.map((value, index) => {
      const hasSuccessPercent = strokeProgress.length > 1 && index === 0;
      return {
        stroke: isGradient && !hasSuccessPercent ? `url(#${linearGradientId})` : void 0,
        strokeClasses: [!isGradient && hasSuccessPercent ? "ix-progress-circle-success" : "", isGradient ? "" : "ix-progress-circle-bg"],
        strokePathStyle: {
          stroke: !isGradient ? hasSuccessPercent ? successColor : props.strokeColor : void 0,
          transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s",
          strokeDasharray: `${value / 100 * (len - gapDegree)}px ${len}px`,
          strokeDashoffset: `-${gapDegree / 2}px`
        }
      };
    }).reverse();
  });
}
var Line = defineComponent({
  name: "IxProgressLine",
  setup() {
    const {
      props,
      config,
      mergedPrefixCls,
      percent,
      formattedSuccess
    } = inject(progressContext);
    const computedProps = useProps(props, config);
    const lineMergedPrefixCls = computed(() => `${mergedPrefixCls.value}-line`);
    const lineClasses = computed(() => {
      const prefixCls = lineMergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-${computedProps.value.size}`]: true,
        [`${prefixCls}-round`]: computedProps.value.strokeLinecap === "round"
      };
    });
    const successStyle = computed(() => {
      var _a, _b;
      return {
        height: computedProps.value.strokeWidth && `${computedProps.value.strokeWidth}px`,
        width: `${(_a = formattedSuccess.value.percent) != null ? _a : 0}%`,
        background: (_b = formattedSuccess.value.strokeColor) != null ? _b : ""
      };
    });
    const bgStyle = computed(() => {
      var _a;
      return {
        height: computedProps.value.strokeWidth && `${computedProps.value.strokeWidth}px`,
        width: `${percent.value}%`,
        background: isObject(computedProps.value.strokeColor) ? handleGradient(computedProps.value.strokeColor) : (_a = computedProps.value.strokeColor) != null ? _a : ""
      };
    });
    return () => {
      var _a;
      const prefixCls = lineMergedPrefixCls.value;
      return createVNode("div", {
        "class": lineClasses.value
      }, [createVNode("div", {
        "class": `${prefixCls}-outer`
      }, [createVNode("div", {
        "class": `${prefixCls}-inner`
      }, [((_a = computedProps.value.success) == null ? void 0 : _a.percent) && createVNode("div", {
        "class": `${prefixCls}-success-bg`,
        "style": successStyle.value
      }, null), createVNode("div", {
        "class": `${prefixCls}-bg`,
        "style": bgStyle.value
      }, null)])]), createVNode(ProgressInfo, null, null)]);
    };
  }
});
const progressStatus = ["normal", "success", "exception", "active"];
const progressProps = {
  type: IxPropTypes.oneOf(["line", "circle", "dashboard"]).def("line"),
  format: IxPropTypes.func(),
  percent: IxPropTypes.oneOfType([String, Number]).def(0),
  status: IxPropTypes.oneOf(["normal", "success", "exception", "active"]),
  hideInfo: IxPropTypes.bool.def(false),
  success: IxPropTypes.object(),
  trailColor: IxPropTypes.string,
  strokeColor: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  strokeLinecap: IxPropTypes.oneOf(["round", "square"]),
  strokeWidth: IxPropTypes.oneOfType([String, Number]),
  gapDegree: IxPropTypes.oneOfType([String, Number]),
  gapPosition: IxPropTypes.oneOf(["top", "bottom", "left", "right"]),
  width: IxPropTypes.oneOfType([String, Number]).def(132),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  icons: IxPropTypes.object()
};
function useStatus(props, percent, success) {
  return computed(() => {
    var _a;
    if (!progressStatus.includes(props.status) && (percent.value >= fullPercent || success.value.percent >= fullPercent)) {
      return "success";
    }
    return (_a = props.status) != null ? _a : "normal";
  });
}
var __defProp$b = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
var Progress = defineComponent({
  name: "IxProgress",
  props: progressProps,
  setup(props, {
    slots
  }) {
    const config = useGlobalConfig$1("progress");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-progress`);
    const percent = computed(() => convertPercent(props.percent));
    const formattedSuccess = computed(() => {
      var _a;
      return __spreadProps$8(__spreadValues$b({}, props.success), {
        percent: convertPercent((_a = props.success) == null ? void 0 : _a.percent)
      });
    });
    const status = useStatus(props, percent, formattedSuccess);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-${status.value}`]: !!status.value
      };
    });
    provide(progressContext, {
      props,
      config,
      slots,
      mergedPrefixCls,
      percent,
      formattedSuccess,
      status
    });
    return () => {
      const ProgressComponent = props.type === "line" ? Line : Circle;
      return createVNode(ProgressComponent, {
        "class": classes.value
      }, null);
    };
  }
});
const IxProgress = Progress;

const radioGroupToken = Symbol("radioGroupToken");
const radioProps = {
  checked: IxPropTypes.bool,
  autofocus: IxPropTypes.bool.def(false),
  buttoned: IxPropTypes.bool,
  control: controlPropDef,
  disabled: IxPropTypes.bool,
  label: IxPropTypes.string,
  mode: IxPropTypes.oneOf(["default", "primary"]),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  value: IxPropTypes.any,
  "onUpdate:checked": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit()
};
const radioGroupProps = {
  value: IxPropTypes.any,
  control: controlPropDef,
  buttoned: IxPropTypes.bool.def(false),
  disabled: IxPropTypes.bool.def(false),
  gap: IxPropTypes.oneOfType([Number, String]),
  name: IxPropTypes.string,
  mode: IxPropTypes.oneOf(["default", "primary"]),
  options: IxPropTypes.array(),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]).def("md"),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
};
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$b.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$b.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Radio = defineComponent({
  name: "IxRadio",
  inheritAttrs: false,
  props: radioProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-radio`);
    const config = useGlobalConfig$1("radio");
    const {
      elementRef,
      focus,
      blur
    } = useFormElement();
    expose({
      focus,
      blur
    });
    const formContext = inject(FORM_TOKEN, null);
    const radioGroup = inject(radioGroupToken, null);
    const mergedName = computed(() => {
      var _a;
      return (_a = attrs.name) != null ? _a : radioGroup == null ? void 0 : radioGroup.props.name;
    });
    const isButtoned = computed(() => {
      var _a;
      return (_a = props.buttoned) != null ? _a : radioGroup == null ? void 0 : radioGroup.props.buttoned;
    });
    const size = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = props.size) != null ? _a : radioGroup == null ? void 0 : radioGroup.props.size) != null ? _b : formContext == null ? void 0 : formContext.size.value) != null ? _c : config.size;
    });
    const mode = computed(() => {
      var _a, _b;
      return (_b = (_a = props.mode) != null ? _a : radioGroup == null ? void 0 : radioGroup.props.mode) != null ? _b : "default";
    });
    const {
      isChecked,
      isDisabled,
      isFocused,
      handleChange,
      handleBlur,
      handleFocus
    } = useRadio(props, radioGroup, elementRef);
    const classes = computed(() => {
      const buttoned = isButtoned.value;
      const prefixCls = mergedPrefixCls.value;
      const classes2 = {
        [prefixCls]: true,
        [`${prefixCls}-button`]: buttoned,
        [`${prefixCls}-checked`]: isChecked.value,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-${mode.value}`]: buttoned,
        [`${prefixCls}-${size.value}`]: buttoned
      };
      return normalizeClass([classes2, attrs.class]);
    });
    return () => {
      var _a, _b;
      const prefixCls = mergedPrefixCls.value;
      const {
        autofocus,
        value,
        label
      } = props;
      const labelNode = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : label;
      const labelWrapper = labelNode && createVNode("span", {
        "class": `${prefixCls}-label`
      }, [labelNode]);
      const _c = attrs, {
        class: className,
        style,
        type,
        tabindex
      } = _c, restAttrs = __objRest$3(_c, [
        "class",
        "style",
        "type",
        "tabindex"
      ]);
      return createVNode("label", {
        "class": classes.value,
        "style": style,
        "role": "radio",
        "aria-checked": isChecked.value,
        "aria-disabled": isDisabled.value
      }, [createVNode("span", {
        "class": `${prefixCls}-input`
      }, [createVNode("input", mergeProps({
        "ref": elementRef,
        "type": "radio",
        "class": `${prefixCls}-input-inner`,
        "aria-hidden": true
      }, restAttrs, {
        "autofocus": autofocus,
        "checked": isChecked.value,
        "disabled": isDisabled.value,
        "name": mergedName.value,
        "value": value,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), null), isButtoned.value ? null : createVNode("span", {
        "class": `${prefixCls}-input-box`,
        "tabindex": tabindex
      }, null)]), labelWrapper]);
    };
  }
});
const useRadio = (props, radioGroup, elementRef) => {
  let isChecked;
  let isDisabled;
  const isFocused = ref(false);
  let handleChange;
  let handleBlur;
  const handleFocus = (evt) => {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  };
  if (radioGroup) {
    const {
      accessor,
      props: groupProps
    } = radioGroup;
    isChecked = computed(() => accessor.valueRef.value === props.value);
    isDisabled = computed(() => {
      var _a;
      return (_a = props.disabled) != null ? _a : accessor.disabled.value;
    });
    handleBlur = (evt) => {
      isFocused.value = false;
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    handleChange = (evt) => {
      if (elementRef.value) {
        const checked = evt.target.checked;
        const value = props.value;
        accessor.setValue(value);
        elementRef.value.checked = false;
        callEmit(props.onChange, checked);
        callEmit(groupProps.onChange, value);
      }
    };
  } else {
    const accessor = useFormAccessor("checked");
    isChecked = computed(() => !!accessor.valueRef.value);
    isDisabled = computed(() => accessor.disabled.value);
    handleBlur = (evt) => {
      isFocused.value = false;
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    handleChange = (evt) => {
      if (elementRef.value) {
        const checked = evt.target.checked;
        accessor.setValue(checked);
        elementRef.value.checked = false;
        callEmit(props.onChange, checked);
      }
    };
  }
  return {
    isChecked,
    isDisabled,
    isFocused,
    handleChange,
    handleBlur,
    handleFocus
  };
};
var RadioGroup = defineComponent({
  name: "IxRadioGroup",
  props: radioGroupProps,
  setup(props, {
    slots
  }) {
    const accessor = useFormAccessor();
    provide(radioGroupToken, {
      props,
      accessor
    });
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-radio-group`);
    const classes = computed(() => {
      const {
        gap
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-with-gap`]: !isNil(gap)
      };
    });
    const style = computed(() => {
      const {
        gap
      } = props;
      return gap !== 0 ? `gap: ${convertCssPixel(gap)};` : void 0;
    });
    return () => {
      var _a;
      const {
        options
      } = props;
      const children = options ? options.map((option) => createVNode(Radio, option, null)) : (_a = slots.default) == null ? void 0 : _a.call(slots);
      return createVNode("div", {
        "class": classes.value,
        "style": style.value
      }, [children]);
    };
  }
});
const IxRadio = Radio;
const IxRadioGroup = RadioGroup;

const rateProps = {
  value: IxPropTypes.oneOfType([Number, String]),
  allowHalf: IxPropTypes.bool,
  clearable: IxPropTypes.bool,
  count: IxPropTypes.oneOfType([Number, String]),
  disabled: IxPropTypes.bool.def(false),
  icon: IxPropTypes.string,
  tooltips: IxPropTypes.arrayOf(String).def(() => []),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onKeyDown: IxPropTypes.emit()
};
const rateItemProps = {
  count: IxPropTypes.number.isRequired,
  disabled: IxPropTypes.bool.isRequired,
  focused: IxPropTypes.bool.isRequired,
  index: IxPropTypes.number.isRequired,
  prefixCls: IxPropTypes.string.isRequired,
  tooltip: IxPropTypes.string,
  value: IxPropTypes.number.isRequired,
  onClick: IxPropTypes.func().isRequired,
  onMouseMove: IxPropTypes.func().isRequired
};
var RateItem = defineComponent({
  props: rateItemProps,
  setup(props, {
    slots
  }) {
    const liRef = ref();
    const handleClick = (evt) => props.onClick(evt, liRef.value, props.index);
    const handleKeyDown = (evt) => {
      if (evt.code === "Enter") {
        handleClick(evt);
      }
    };
    const handleMouseMove = (evt) => props.onMouseMove(evt, liRef.value, props.index);
    const classes = computed(() => {
      const {
        focused,
        index,
        prefixCls,
        value
      } = props;
      const itemValue = index + 1;
      const isHalf = value + 0.5 >= itemValue && value < itemValue;
      const isFull = !isHalf && itemValue <= value;
      const isZero = !isFull && !isHalf;
      return {
        [prefixCls]: true,
        [`${prefixCls}-focused`]: focused && (isHalf || value === itemValue || index === 0 && value === 0),
        [`${prefixCls}-full`]: isFull,
        [`${prefixCls}-half`]: isHalf,
        [`${prefixCls}-zero`]: isZero
      };
    });
    return () => {
      const {
        count,
        disabled,
        index,
        prefixCls,
        tooltip,
        value
      } = props;
      const iconNode = slots.default();
      const itemNode = createVNode("li", {
        "ref": liRef,
        "class": classes.value
      }, [createVNode("span", {
        "aria-checked": value > index,
        "aria-posinset": index + 1,
        "aria-setsize": count,
        "role": "radio",
        "tabindex": disabled ? -1 : 0,
        "onClick": disabled ? void 0 : handleClick,
        "onKeydown": disabled ? void 0 : handleKeyDown,
        "onMousemove": disabled ? void 0 : handleMouseMove
      }, [createVNode("span", {
        "class": `${prefixCls}-first`
      }, [iconNode]), createVNode("span", {
        "class": `${prefixCls}-second`
      }, [iconNode])])]);
      return tooltip ? createVNode(IxTooltip, {
        "title": tooltip
      }, {
        default: () => [itemNode]
      }) : itemNode;
    };
  }
});
var Rate = defineComponent({
  name: "IxRate",
  props: rateProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-rate`);
    const config = useGlobalConfig$1("rate");
    const formContext = inject(FORM_TOKEN, null);
    const {
      elementRef,
      focus,
      blur
    } = useFormElement();
    expose({
      focus,
      blur
    });
    const accessor = useFormAccessor();
    const countRef = computed(() => {
      var _a;
      return convertNumber((_a = props.count) != null ? _a : config.count);
    });
    const iconRef = computed(() => {
      var _a;
      return (_a = props.icon) != null ? _a : config.icon;
    });
    const allowHalfRef = computed(() => {
      var _a;
      return (_a = props.allowHalf) != null ? _a : config.allowHalf;
    });
    const clearableRef = computed(() => {
      var _a;
      return (_a = props.clearable) != null ? _a : config.clearable;
    });
    const isDisabled = computed(() => accessor.disabled.value);
    const isFocused = ref(false);
    const hoverValue = ref();
    const changeValue = (value) => {
      callEmit(props.onChange, value);
      accessor.setValue(value);
    };
    const calcValue = (evt, element, index) => {
      let value = index + 1;
      if (allowHalfRef.value) {
        if (evt.offsetX < element.clientWidth / 2) {
          value -= 0.5;
        }
      }
      return value;
    };
    const handleItemClick = (evt, element, index) => {
      const currValue = accessor.valueRef.value;
      const newValue = calcValue(evt, element, index);
      const isClear = clearableRef.value && currValue === newValue;
      changeValue(isClear ? 0 : newValue);
    };
    const handleItemMouseMove = (evt, element, index) => {
      const newValue = calcValue(evt, element, index);
      hoverValue.value = newValue;
    };
    const handleFocus = (evt) => {
      isFocused.value = true;
      callEmit(props.onFocus, evt);
    };
    const handleBlur = (evt) => {
      isFocused.value = false;
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    const handleKeyDown = (evt) => {
      const currValue = accessor.valueRef.value;
      const currCount = countRef.value;
      const currAllowHalf = allowHalfRef.value;
      const eventCode = evt.code;
      switch (eventCode) {
        case "ArrowRight":
        case "ArrowUp":
          {
            if (currValue < currCount) {
              changeValue(currValue + (currAllowHalf ? 0.5 : 1));
              evt.preventDefault();
            }
          }
          break;
        case "ArrowLeft":
        case "ArrowDown":
          if (currValue > 0) {
            changeValue(currValue - (currAllowHalf ? 0.5 : 1));
            evt.preventDefault();
          }
          break;
      }
    };
    const handleMouseLeave = () => {
      hoverValue.value = void 0;
    };
    const size = computed(() => {
      var _a, _b;
      return (_b = (_a = props.size) != null ? _a : formContext == null ? void 0 : formContext.size.value) != null ? _b : config.size;
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-${size.value}`]: true
      };
    });
    return () => {
      var _a;
      const count = countRef.value;
      const disabled = isDisabled.value;
      const focused = isFocused.value;
      const itemValue = convertNumber((_a = hoverValue.value) != null ? _a : accessor.valueRef.value);
      const itemPrefixCls = `${mergedPrefixCls.value}-item`;
      const {
        tooltips
      } = props;
      const children = [];
      for (let index = 0; index < count; index++) {
        children.push(createVNode(RateItem, {
          "key": index,
          "count": count,
          "disabled": disabled,
          "focused": focused,
          "index": index,
          "prefixCls": itemPrefixCls,
          "tooltip": tooltips[index],
          "value": itemValue,
          "onClick": handleItemClick,
          "onMouseMove": handleItemMouseMove
        }, {
          default: () => {
            var _a2, _b;
            return [(_b = (_a2 = slots.icon) == null ? void 0 : _a2.call(slots, {
              disabled,
              focused,
              index
            })) != null ? _b : createVNode(IxIcon, {
              "name": iconRef.value
            }, null)];
          }
        }));
      }
      return createVNode("ul", {
        "ref": elementRef,
        "class": classes.value,
        "tabindex": disabled ? -1 : attrs.tabindex,
        "onFocus": disabled ? void 0 : handleFocus,
        "onBlur": disabled ? void 0 : handleBlur,
        "onKeydown": disabled ? void 0 : handleKeyDown,
        "onMouseleave": disabled ? void 0 : handleMouseLeave,
        "role": "radiogroup"
      }, [children]);
    };
  }
});
const IxRate = Rate;

const resultProps = {
  icon: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  status: IxPropTypes.oneOf(["success", "error", "info", "warning"]),
  subtitle: IxPropTypes.string,
  title: IxPropTypes.string
};
const defaultIconMap = {
  success: "check-circle-filled",
  error: "close-circle-filled",
  info: "info-circle-filled",
  warning: "exclamation-circle-filled"
};
var Result = defineComponent({
  name: "IxResult",
  components: {
    IxIcon
  },
  props: resultProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-result`);
    const resultConfig = useGlobalConfig$1("result");
    const className = useClassName(props, mergedPrefixCls, resultConfig);
    const currentIcon = useIcon$1(props, resultConfig);
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const {
        title,
        subtitle
      } = props;
      return createVNode("div", {
        "class": className.value
      }, [renderIcon$2(prefixCls, slots.icon, currentIcon.value), renderSlottedNode(`${prefixCls}-title`, slots.title, title), renderSlottedNode(`${prefixCls}-subtitle`, slots.subtitle, subtitle), renderSlottedNode(`${prefixCls}-extra`, slots.extra), renderSlottedNode(`${prefixCls}-content`, slots.default)]);
    };
  }
});
function renderSlottedNode(cls, slot, defaultContent) {
  if (!slot && !defaultContent) {
    return null;
  }
  const content = slot ? slot() : defaultContent;
  return content ? createVNode("div", {
    "class": cls
  }, [content]) : null;
}
function renderIcon$2(prefixCls, iconSlot, icon) {
  const content = isString(icon) ? createVNode(IxIcon, {
    "name": icon
  }, null) : icon;
  return renderSlottedNode(`${prefixCls}-icon`, iconSlot, content);
}
function useClassName(props, mergedPrefixCls, config) {
  return computed(() => {
    var _a;
    const prefixCls = mergedPrefixCls.value;
    const status = (_a = props.status) != null ? _a : config.status;
    return {
      [prefixCls]: true,
      [`${prefixCls}-${status}`]: !!status
    };
  });
}
function useIcon$1(props, config) {
  return computed(() => {
    var _a, _b, _c, _d;
    const status = (_a = props.status) != null ? _a : config.status;
    return (_d = (_c = props.icon) != null ? _c : (_b = config.icon) == null ? void 0 : _b[status]) != null ? _d : defaultIconMap[status];
  });
}
const IxResult = Result;

const skeletonProps = {
  animated: IxPropTypes.bool,
  loading: IxPropTypes.bool.def(true),
  type: IxPropTypes.oneOf(["round", "circle", "text", "rect"]).def("text"),
  width: IxPropTypes.oneOfType([String, Number]),
  height: IxPropTypes.oneOfType([String, Number]),
  repeat: IxPropTypes.number.def(1)
};
var Skeleton = defineComponent({
  name: "IxSkeleton",
  inheritAttrs: false,
  props: skeletonProps,
  setup(props, {
    slots,
    attrs
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-skeleton`);
    const config = useGlobalConfig$1("skeleton");
    const loaderClass = computed(() => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-loader`]: true,
        [`${prefixCls}-${props.type}`]: true,
        [`${prefixCls}-animated`]: (_a = props.animated) != null ? _a : config.animated
      });
    });
    const loaderStyle = computed(() => {
      const {
        width,
        height,
        type
      } = props;
      if (type === "circle") {
        const size = convertCssPixel(width || height);
        return {
          width: size,
          height: size
        };
      }
      return {
        width: convertCssPixel(width),
        height: convertCssPixel(height)
      };
    });
    return () => {
      var _a;
      if (!props.loading) {
        return (_a = slots.default) == null ? void 0 : _a.call(slots);
      }
      const prefixCls = mergedPrefixCls.value;
      const loader = createVNode("div", {
        "class": loaderClass.value,
        "style": loaderStyle.value
      }, null);
      const loaderList = Array.from({
        length: props.repeat
      }).map(() => loader);
      return createVNode("div", mergeProps({
        "class": prefixCls
      }, attrs), [loaderList]);
    };
  }
});
const IxSkeleton = Skeleton;

const sliderStartDirection = {
  ltr: "left",
  rtl: "right",
  btt: "bottom",
  ttb: "top"
};
const sliderToken = Symbol("sliderToken");
const sliderProps = {
  value: IxPropTypes.oneOfType([IxPropTypes.number, IxPropTypes.arrayOf(IxPropTypes.number)]).def(0),
  disabled: IxPropTypes.bool.def(false),
  dots: IxPropTypes.bool.def(false),
  keyboard: IxPropTypes.bool.def(true),
  marks: IxPropTypes.object(),
  max: IxPropTypes.number.def(100),
  min: IxPropTypes.number.def(0),
  range: IxPropTypes.bool.def(false),
  reverse: IxPropTypes.bool.def(false),
  step: IxPropTypes.oneOfType([IxPropTypes.number]).def(1),
  tooltipFormatter: IxPropTypes.func(),
  tooltipPlacement: overlayPlacementDef,
  tooltipVisible: IxPropTypes.bool,
  vertical: IxPropTypes.bool.def(false),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onInput: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
};
const sliderThumbProps = {
  value: IxPropTypes.number,
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
};
const sliderMarksProps = {
  onClickMark: IxPropTypes.emit()
};
var IxSliderMarks = defineComponent({
  name: "IxSliderMarks",
  props: sliderMarksProps,
  setup(props) {
    const {
      values,
      marks,
      max,
      min,
      prefixCls,
      range,
      reverse,
      vertical
    } = inject(sliderToken);
    const mergedPrefixCls = computed(() => `${prefixCls.value}-mark`);
    return () => {
      return createVNode("div", {
        "class": mergedPrefixCls.value
      }, [renderMarks(props, values.value, marks.value, max.value, min.value, mergedPrefixCls.value, range.value, reverse.value, vertical.value)]);
    };
  }
});
function renderMarks(props, values, marks, max, min, prefixCls, range, reverse, vertical) {
  if (isUndefined(marks)) {
    return;
  }
  const width = max - min;
  return Object.keys(marks).map(parseFloat).sort((a, b) => a - b).map((offset) => {
    const markValue = marks[offset];
    const isObj = isPlainObject(markValue);
    let markLabel = void 0;
    if (isString(markValue) || isVNode(markValue)) {
      markLabel = markValue;
    } else if (isFunction(markValue)) {
      markLabel = markValue();
    } else if (isObj) {
      markLabel = markValue.label;
    }
    if (isUndefined(markLabel)) {
      return null;
    }
    const isActived = range ? !(offset < values[0] || offset > values[1]) : offset <= values[0];
    const classes = {
      [`${prefixCls}-label`]: true,
      [`${prefixCls}-label-active`]: isActived
    };
    const style = vertical ? {
      marginBottom: "-50%",
      [reverse ? sliderStartDirection.ttb : sliderStartDirection.btt]: `${(offset - min) / width * 100}%`
    } : {
      transform: `translateX(${reverse ? `50%` : `-50%`})`,
      [reverse ? sliderStartDirection.rtl : sliderStartDirection.ltr]: `${(offset - min) / width * 100}%`
    };
    const markStyle = isObj ? normalizeStyle([style, markValue == null ? void 0 : markValue.style]) : style;
    const handleMarkClick = (evt) => callEmit(props.onClickMark, evt, offset);
    return createVNode("span", {
      "key": offset,
      "class": classes,
      "style": markStyle,
      "onMousedown": handleMarkClick,
      "onTouchstart": handleMarkClick
    }, [markLabel]);
  });
}
var IxSliderSteps = defineComponent({
  name: "IxSliderSteps",
  setup() {
    const {
      values,
      dots,
      marks,
      max,
      min,
      prefixCls,
      range,
      reverse,
      step,
      vertical
    } = inject(sliderToken);
    return () => {
      return createVNode("div", {
        "class": `${prefixCls.value}-step`
      }, [renderDots(values.value, dots.value, marks.value, max.value, min.value, prefixCls.value, range.value, reverse.value, step.value, vertical.value)]);
    };
  }
});
function renderDots(values, dots, marks, max, min, prefixCls, range, reverse, step, vertical) {
  const width = max - min;
  return getOffsets(dots, marks, max, min, step).map((offset) => {
    const pos = `${Math.abs(offset - min) / width * 100}%`;
    const isActived = range ? !(offset < values[0] || offset > values[1]) : offset <= values[0];
    const style = vertical ? {
      [reverse ? sliderStartDirection.ttb : sliderStartDirection.btt]: pos
    } : {
      [reverse ? sliderStartDirection.rtl : sliderStartDirection.ltr]: pos
    };
    const classes = {
      [`${prefixCls}-dot`]: true,
      [`${prefixCls}-dot-active`]: isActived,
      [`${prefixCls}-dot-reverse`]: reverse
    };
    return createVNode("span", {
      "key": offset,
      "class": classes,
      "style": style
    }, null);
  });
}
function getOffsets(dots, marks, max, min, step) {
  const points = Object.keys(marks != null ? marks : {}).map(parseFloat).sort((a, b) => a - b);
  if (dots && step) {
    for (let i = min; i <= max; i += step) {
      if (points.indexOf(i) === -1) {
        points.push(i);
      }
    }
  }
  return points;
}
var IxSliderThumb = defineComponent({
  name: "IxSliderThumb",
  inheritAttrs: false,
  props: sliderThumbProps,
  setup(props, {
    attrs,
    expose
  }) {
    var _a;
    const {
      disabled,
      dragging,
      prefixCls,
      tooltipVisible,
      tooltipPlacement,
      tooltipFormatter
    } = inject(sliderToken);
    const mergedTooltipVisible = ref((_a = tooltipVisible.value) != null ? _a : false);
    const isHovering = ref(false);
    const tooltipRef = ref(null);
    const thumbRef = ref(null);
    const mergedPrefixCls = computed(() => `${prefixCls.value}-thumb`);
    const showTooltip = () => tooltipVisible.value !== false && (mergedTooltipVisible.value = true);
    const hideTooltip = () => tooltipVisible.value !== true && (mergedTooltipVisible.value = false);
    onUpdated(() => {
      var _a2;
      return mergedTooltipVisible.value && ((_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper());
    });
    function handleMouseEnter() {
      isHovering.value = true;
      showTooltip();
    }
    function handleMouseLeave() {
      isHovering.value = false;
      if (!dragging.value) {
        hideTooltip();
      }
    }
    function handleFocus(evt) {
      showTooltip();
      if (!dragging.value) {
        callEmit(props.onFocus, evt);
      }
    }
    function handleBlur(evt) {
      hideTooltip();
      if (!dragging.value) {
        callEmit(props.onBlur, evt);
      }
    }
    expose({
      tooltipRef,
      thumbRef,
      isHovering,
      showTooltip,
      hideTooltip
    });
    return () => {
      return createVNode(IxTooltip, {
        "ref": tooltipRef,
        "visible": mergedTooltipVisible.value,
        "placement": tooltipPlacement.value,
        "trigger": "manual"
      }, {
        default: () => [createVNode("div", mergeProps(attrs, {
          "ref": thumbRef,
          "class": mergedPrefixCls.value,
          "onMouseenter": handleMouseEnter,
          "onMouseleave": handleMouseLeave,
          "onFocus": disabled.value ? NoopFunction : handleFocus,
          "onBlur": disabled.value ? NoopFunction : handleBlur
        }), null)],
        title: () => isFunction(tooltipFormatter.value) ? tooltipFormatter.value(props.value) : createVNode("span", null, [props.value])
      });
    };
  }
});
function useSlider(props) {
  const { elementRef, focus, blur } = useFormElement();
  const accessor = useFormAccessor();
  const valuesRef = ref([props.min, props.min]);
  const thumbListRef = ref([]);
  const activeIndex = ref(-1);
  const railRef = ref(null);
  const isDragging = ref(false);
  const isDisabled = computed(() => accessor == null ? void 0 : accessor.disabled.value);
  const precision = computed(() => {
    const precisions = [props.min, props.max, props.step].map((num) => {
      const decimal = `${num}`.split(".")[1];
      return decimal ? decimal.length : 0;
    });
    return Math.max(...precisions);
  });
  const stepPrecision = computed(() => {
    const decimal = `${props.step}`.split(".")[1];
    return decimal ? decimal.length : 0;
  });
  const direction = computed(() => {
    if (props.vertical) {
      return props.reverse ? sliderStartDirection.ttb : sliderStartDirection.btt;
    }
    return props.reverse ? sliderStartDirection.rtl : sliderStartDirection.ltr;
  });
  function setThumbRefs(index) {
    return (el) => {
      if (index === 0) {
        elementRef.value = el == null ? void 0 : el.thumbRef;
      }
      thumbListRef.value[index] = el;
    };
  }
  function handleMouseDown(evt) {
    var _a, _b;
    const index = thumbListRef.value.findIndex((v) => (v == null ? void 0 : v.thumbRef) === evt.target);
    if (index !== -1) {
      evt.preventDefault();
      activeIndex.value = index;
      (_b = (_a = thumbListRef.value[index]) == null ? void 0 : _a.thumbRef) == null ? void 0 : _b.focus();
      startDragging();
    } else {
      const newValue = calcValueByMouseEvent(evt);
      setActiveIndex(newValue);
      updateModelValue(newValue);
    }
  }
  function handleKeyDown(evt) {
    if (props.keyboard) {
      const index = thumbListRef.value.findIndex((v) => (v == null ? void 0 : v.thumbRef) === evt.target);
      if (index !== -1) {
        let value = null;
        if (evt.code === "ArrowUp" || evt.code === "ArrowRight") {
          activeIndex.value = index;
          value = incValueByActiveIndex(1);
        } else if (evt.code === "ArrowDown" || evt.code === "ArrowLeft") {
          activeIndex.value = index;
          value = incValueByActiveIndex(-1);
        }
        if (value !== null) {
          evt.preventDefault();
          updateModelValue(value);
          checkAcross(value);
        }
      }
    }
  }
  function handleMarkClick(evt, newValue) {
    evt.stopPropagation();
    setActiveIndex(newValue);
    updateModelValue(newValue);
  }
  function startDragging() {
    if (!isDragging.value) {
      isDragging.value = true;
      on(window, "mousemove", handleMouseMove);
      on(window, "touchmove", handleMouseMove);
      on(window, "mouseup", handleMouseUpOnDocument);
      on(window, "touchend", handleMouseUpOnDocument);
      on(window, "contextmenu", handleMouseUpOnDocument);
    }
  }
  function stopDragging() {
    if (isDragging.value) {
      const activeThumbRef = thumbListRef.value[activeIndex.value];
      isDragging.value = false;
      activeIndex.value = -1;
      if (!(activeThumbRef == null ? void 0 : activeThumbRef.isHovering)) {
        nextTick(() => activeThumbRef == null ? void 0 : activeThumbRef.hideTooltip());
      }
      off(window, "mousemove", handleMouseMove);
      off(window, "touchmove", handleMouseMove);
      off(window, "mouseup", handleMouseUpOnDocument);
      off(window, "touchend", handleMouseUpOnDocument);
      off(window, "contextmenu", handleMouseUpOnDocument);
    }
  }
  function handleMouseMove(evt) {
    if (!isDragging.value) {
      stopDragging();
      return;
    }
    const newValue = calcValueByMouseEvent(evt);
    updateModelValue(newValue);
    checkAcross(newValue);
  }
  function handleMouseUpOnDocument() {
    stopDragging();
    callEmit(props.onChange, toRaw(valuesRef.value));
  }
  function handleMouseUp() {
    var _a, _b;
    const { value: index } = activeIndex;
    if (index !== -1) {
      (_b = (_a = thumbListRef.value[index]) == null ? void 0 : _a.thumbRef) == null ? void 0 : _b.focus();
    }
  }
  function updateModelValue(newValue) {
    const { value: index } = activeIndex;
    if (valuesRef.value[index] !== newValue) {
      const newValues = valuesRef.value.slice();
      newValues[index] = newValue;
      const modelValue = props.range ? newValues : newValues[0];
      accessor.setValue(modelValue);
      isDragging.value ? callEmit(props.onInput, modelValue) : callEmit(props.onChange, modelValue);
      nextTick(() => setValues());
    }
  }
  function setActiveIndex(newValue) {
    const { value: oldValues } = valuesRef;
    activeIndex.value = props.range ? Math.abs(oldValues[0] - newValue) < Math.abs(oldValues[1] - newValue) ? 0 : 1 : 0;
  }
  function checkAcross(value) {
    var _a, _b;
    if (props.range) {
      const { value: thumbValues } = valuesRef;
      let newIndex = activeIndex.value;
      if (value > thumbValues[1]) {
        newIndex = 1;
      } else if (value < thumbValues[0]) {
        newIndex = 0;
      }
      if (newIndex !== activeIndex.value) {
        activeIndex.value = newIndex;
        (_b = (_a = thumbListRef.value[activeIndex.value]) == null ? void 0 : _a.thumbRef) == null ? void 0 : _b.focus();
      }
    }
  }
  function calcValueByMouseEvent(evt) {
    const client = getMouseClientXY(evt);
    const railRect = railRef.value.getBoundingClientRect();
    let percentage;
    if (props.vertical) {
      percentage = (railRect.bottom - client.clientY) / railRect.height;
    } else {
      percentage = (client.clientX - railRect.left) / railRect.width;
    }
    if (props.reverse) {
      percentage = 1 - percentage;
    }
    return calcValueByStep(percentage * (props.max - props.min));
  }
  function calcValueByStep(value) {
    var _a, _b;
    value = Math.max(props.min, Math.min(props.max, value));
    const marks = (_a = props.marks) != null ? _a : {};
    const points = Object.keys(marks).map(parseFloat);
    if (props.step !== null) {
      const convertNum = Math.pow(10, precision.value);
      const totalSteps = Math.floor((props.max * convertNum - props.min * convertNum) / (props.step * convertNum));
      const steps = Math.min((value - props.min) / props.step, totalSteps);
      const closestStepValue = Math.round(steps) * props.step + props.min;
      points.push(parseFloat(closestStepValue.toFixed(precision.value)));
    }
    const diffs = points.map((point) => Math.abs(value - point));
    const index = diffs.indexOf(Math.min(...diffs));
    return (_b = points[index]) != null ? _b : props.min;
  }
  function incValueByActiveIndex(flag) {
    if (props.step !== null) {
      const step = flag < 0 ? -props.step : +props.step;
      const currValue = valuesRef.value[activeIndex.value];
      return Math.max(props.min, Math.min(props.max, parseFloat((currValue + step).toFixed(stepPrecision.value))));
    }
    return props.min;
  }
  watch(accessor.valueRef, (val, oldVal) => {
    if (isDragging.value || Array.isArray(val) && Array.isArray(oldVal) && val.every((v, i) => v === oldVal[i])) {
      return;
    }
    setValues();
  }, { immediate: true });
  watch(() => [props.max, props.min, props.range, props.step], () => {
    setValues();
  });
  function setValues() {
    var _a, _b;
    if (props.min > props.max) {
      if (process.env.NODE_ENV !== "production") {
        Logger.error("components/slider", "min should not be greater than max.");
      }
      return;
    }
    if (process.env.NODE_ENV !== "production" && props.step !== null && props.step <= 0) {
      Logger.error("components/slider", `step(${props.step}) should be greater than 0.`);
    }
    const { value: modelValue } = accessor.valueRef;
    let val;
    if (props.range) {
      if (!Array.isArray(modelValue)) {
        if (process.env.NODE_ENV !== "production") {
          Logger.error("components/slider", "value should be [number, number] in range mode.");
        }
        return;
      }
      val = [(_a = modelValue[0]) != null ? _a : props.min, (_b = modelValue[1]) != null ? _b : props.min];
    } else {
      if (!isNumeric(modelValue)) {
        if (process.env.NODE_ENV !== "production") {
          Logger.error("components/slider", "value should be a number.");
        }
        return;
      }
      val = [modelValue];
    }
    valuesRef.value = val.map((num) => {
      if (!isNumeric(num)) {
        return props.min;
      }
      return calcValueByStep(num);
    }).sort((a, b) => a - b);
  }
  return {
    valuesRef,
    thumbListRef,
    railRef,
    direction,
    isDisabled,
    isDragging,
    focus,
    blur,
    setThumbRefs,
    handleMouseDown,
    handleMouseUp,
    handleKeyDown,
    handleMarkClick
  };
}
var __defProp$a = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
var Slider = defineComponent({
  name: "IxSlider",
  props: sliderProps,
  setup(props, {
    expose
  }) {
    const common = useGlobalConfig$1("common");
    const {
      direction,
      isDisabled,
      isDragging,
      valuesRef,
      railRef,
      setThumbRefs,
      handleMouseDown,
      handleMouseUp,
      handleKeyDown,
      handleMarkClick,
      focus,
      blur
    } = useSlider(props);
    const {
      trackStyle
    } = useTrack(props, valuesRef, direction);
    const mergedPrefixCls = computed(() => `${common.prefixCls}-slider`);
    const thumbs = computed(() => valuesRef.value.slice(0, props.range ? 2 : 1));
    const thumbTransformOfStyle = computed(() => {
      if (props.vertical) {
        return props.reverse ? `translateY(-50%)` : `translateY(50%)`;
      }
      return props.reverse ? `translateX(50%)` : `translateX(-50%)`;
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-vertical`]: props.vertical,
        [`${prefixCls}-with-marks`]: !isUndefined(props.marks)
      };
    });
    provide(sliderToken, __spreadProps$7(__spreadValues$a({}, toRefs(props)), {
      direction,
      dragging: isDragging,
      values: valuesRef,
      disabled: isDisabled,
      prefixCls: mergedPrefixCls
    }));
    expose({
      focus,
      blur
    });
    return () => {
      return createVNode("div", {
        "class": classes.value,
        "onMousedown": isDisabled.value ? NoopFunction : handleMouseDown,
        "onTouchstart": isDisabled.value ? NoopFunction : handleMouseDown,
        "onMouseup": isDisabled.value ? NoopFunction : handleMouseUp,
        "onKeydown": isDisabled.value ? NoopFunction : handleKeyDown
      }, [createVNode("div", {
        "ref": railRef,
        "class": `${mergedPrefixCls.value}-rail`
      }, null), createVNode("div", {
        "class": `${mergedPrefixCls.value}-track`,
        "style": trackStyle.value
      }, null), createVNode(IxSliderSteps, null, null), thumbs.value.map((val, index) => {
        const position = (val - props.min) / (props.max - props.min) * 100;
        return createVNode(IxSliderThumb, {
          "ref": setThumbRefs(index),
          "value": val,
          "role": "slider",
          "tabindex": isDisabled.value ? -1 : 0,
          "aria-label": "Slider",
          "aria-valuemin": props.min,
          "aria-valuemax": props.max,
          "aria-valuenow": val,
          "aria-readonly": isDisabled.value,
          "aria-orientation": props.vertical ? "vertical" : "horizontal",
          "onFocus": props.onFocus,
          "onBlur": props.onBlur,
          "style": {
            transform: thumbTransformOfStyle.value,
            [direction.value]: `${position}%`
          }
        }, null);
      }), createVNode(IxSliderMarks, {
        "onClickMark": isDisabled.value ? NoopFunction : handleMarkClick
      }, null)]);
    };
  }
});
function useTrack(props, values, direction) {
  const maxValue = computed(() => Math.max(...values.value));
  const minValue = computed(() => Math.min(...values.value));
  const trackStyle = computed(() => {
    return {
      [direction.value]: props.range ? `${(minValue.value - props.min) / (props.max - props.min) * 100}%` : "0%",
      [props.vertical ? "height" : "width"]: props.range ? `${(maxValue.value - minValue.value) / (props.max - props.min) * 100}%` : `${(+values.value[0] - props.min) / (props.max - props.min) * 100}%`
    };
  });
  return {
    trackStyle
  };
}
const IxSlider = Slider;

const statisticProps = {
  formatter: IxPropTypes.func(),
  precision: IxPropTypes.number,
  prefix: IxPropTypes.string,
  suffix: IxPropTypes.string,
  title: IxPropTypes.string,
  value: IxPropTypes.oneOfType([String, Number]).def("")
};
var Statistic = defineComponent({
  name: "IxStatistic",
  props: statisticProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-statistic`);
    const statisticConfig = useGlobalConfig$1("statistic");
    const formatedValue = useFomat(props, statisticConfig);
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const prefixCls = mergedPrefixCls.value;
      const {
        title,
        prefix,
        suffix
      } = props;
      const titleNode = (title != null ? title : slots.title) && createVNode("div", {
        "class": `${prefixCls}-title`
      }, [(_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : title]);
      const prefixNode = (prefix != null ? prefix : slots.prefix) && createVNode("span", {
        "class": `${prefixCls}-content-prefix`
      }, [(_d = (_c = slots.prefix) == null ? void 0 : _c.call(slots)) != null ? _d : prefix]);
      const suffixNode = (suffix != null ? suffix : slots.suffix) && createVNode("span", {
        "class": `${prefixCls}-content-suffix`
      }, [(_f = (_e = slots.suffix) == null ? void 0 : _e.call(slots)) != null ? _f : suffix]);
      return createVNode("div", {
        "class": prefixCls
      }, [titleNode, createVNode("div", {
        "class": `${prefixCls}-content`
      }, [prefixNode, createVNode("span", {
        "class": `${prefixCls}-content-value`
      }, [(_h = (_g = slots.default) == null ? void 0 : _g.call(slots)) != null ? _h : createVNode(Fragment, null, [createVNode("span", {
        "class": `${prefixCls}-content-value-int`
      }, [formatedValue.value.int || formatedValue.value.value]), formatedValue.value.decimal && createVNode("span", {
        "class": `${prefixCls}-content-value-decimal`
      }, [createTextVNode(" "), formatedValue.value.decimal, createTextVNode(" ")])])]), suffixNode])]);
    };
  }
});
const useFomat = (props, config) => {
  return computed(() => {
    const precision = props.precision || config.precision;
    const formatter = props.formatter || config.formatter;
    return formatter(props.value, precision);
  });
};
const IxStatistic = Statistic;

const stepperToken = Symbol("stepperToken");
const stepperItemKey = Symbol("IDUX_STEPPER_ITEM_KEY");
const stepperProps = {
  activeKey: IxPropTypes.oneOfType([String, Number, Symbol]),
  clickable: IxPropTypes.bool,
  labelPlacement: IxPropTypes.oneOf(["end", "bottom"]),
  percent: IxPropTypes.range(0, 100),
  size: IxPropTypes.oneOf(["md", "sm"]),
  status: IxPropTypes.oneOf(["process", "finish", "wait", "error"]).def("process"),
  vertical: IxPropTypes.bool.def(false),
  "onUpdate:activeKey": IxPropTypes.emit()
};
const stepperItemProps = {
  description: IxPropTypes.string,
  disabled: IxPropTypes.bool.def(false),
  icon: IxPropTypes.string,
  title: IxPropTypes.string,
  status: IxPropTypes.oneOf(["process", "finish", "wait", "error"])
};
var Stepper = defineComponent({
  name: "IxStepper",
  props: stepperProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-stepper`);
    const config = useGlobalConfig$1("stepper");
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const {
        size = config.size,
        labelPlacement = config.labelPlacement,
        percent,
        vertical
      } = props;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-label-${labelPlacement}`]: true,
        [`${prefixCls}-${size}`]: true,
        [`${prefixCls}-vertical`]: vertical,
        [`${prefixCls}-with-percent`]: percent != null
      });
    });
    const [activeKey, setActiveKey] = useControlledProp(props, "activeKey");
    provide(stepperToken, {
      props,
      slots,
      activeKey,
      setActiveKey
    });
    return () => {
      var _a;
      const children = flattenNode((_a = slots.default) == null ? void 0 : _a.call(slots), {
        key: stepperItemKey
      }).map((item, index) => {
        if (item.key == null) {
          item.key = index + 1;
        }
        return item;
      });
      return createVNode("div", {
        "class": classes.value
      }, [children]);
    };
  }
});
var StepperItem = defineComponent({
  name: "IxStepperItem",
  props: stepperItemProps,
  [stepperItemKey]: true,
  setup(props, {
    slots
  }) {
    const key = useKey();
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-stepper-item`);
    const {
      props: parentProps,
      activeKey,
      setActiveKey
    } = inject(stepperToken);
    const isActive = computed(() => activeKey.value === key);
    const status = computed(() => {
      if (props.status) {
        return props.status;
      }
      if (isActive.value) {
        return parentProps.status;
      }
      const currActiveKey = activeKey.value;
      if (!currActiveKey || isSymbol(currActiveKey) || isSymbol(key)) {
        return "wait";
      }
      return currActiveKey > key ? "finish" : "wait";
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const {
        disabled,
        icon
      } = props;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${status.value}`]: true,
        [`${prefixCls}-active`]: isActive.value,
        [`${prefixCls}-clickable`]: parentProps.clickable && !disabled,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-with-icon`]: icon || !!slots.icon
      });
    });
    const onClick = () => {
      if (isActive.value) {
        return;
      }
      setActiveKey(key);
    };
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const clickable = parentProps.clickable && !props.disabled;
      const iconNode = renderIcon$1(props, slots, parentProps, status, key);
      const titleNode = covertStringVNode(slots, props, "title");
      const descriptionNode = covertStringVNode(slots, props, "description");
      return createVNode("div", {
        "class": classes.value,
        "role": clickable ? "button" : void 0,
        "tabindex": clickable ? 0 : void 0,
        "onClick": clickable ? onClick : void 0
      }, [createVNode("div", {
        "class": `${prefixCls}-tail`
      }, null), createVNode("div", {
        "class": `${prefixCls}-icon`
      }, [iconNode]), createVNode("div", {
        "class": `${prefixCls}-content`
      }, [createVNode("div", {
        "class": `${prefixCls}-title`
      }, [titleNode]), descriptionNode && createVNode("div", {
        "class": `${prefixCls}-description`
      }, [descriptionNode])])]);
    };
  }
});
const statusIcons = {
  finish: "check",
  error: "close"
};
function renderIcon$1(props, slots, parentProps, status, key) {
  const currStatus = status.value;
  let node;
  if (slots.icon) {
    node = slots.icon({
      key,
      status: currStatus
    });
  } else {
    const {
      icon = statusIcons[currStatus]
    } = props;
    if (icon) {
      node = createVNode(IxIcon, {
        "name": icon
      }, null);
    } else {
      node = createVNode("span", null, [key]);
    }
  }
  if (currStatus === "process" && parentProps.percent != null) {
    const width = parentProps.size === "sm" ? 32 : 40;
    return [createVNode(IxProgress, {
      "type": "circle",
      "percent": parentProps.percent,
      "width": width,
      "strokeWidth": 4,
      "format": NoopFunction
    }, null), node];
  }
  return node;
}
const IxStepper = Stepper;
const IxStepperItem = StepperItem;

const switchProps = {
  checked: IxPropTypes.bool,
  control: controlPropDef,
  autofocus: IxPropTypes.bool.def(false),
  disabled: IxPropTypes.bool.def(false),
  labels: IxPropTypes.arrayOf(String).def(() => []),
  loading: IxPropTypes.bool.def(false),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]).def("md"),
  "onUpdate:checked": IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit()
};
var Switch = defineComponent({
  name: "IxSwitch",
  props: switchProps,
  setup(props, {
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-switch`);
    const {
      elementRef,
      focus,
      blur
    } = useFormElement();
    const formContext = inject(FORM_TOKEN, null);
    expose({
      focus,
      blur
    });
    const accessor = useFormAccessor("checked");
    const isChecked = computed(() => accessor.valueRef.value);
    const isDisabled = computed(() => {
      var _a;
      return (_a = props.disabled) != null ? _a : accessor.disabled.value;
    });
    const handleClick = () => {
      if (isDisabled.value || props.loading) {
        return;
      }
      callEmit(props.onChange, !isChecked.value);
      accessor.setValue(!isChecked.value);
    };
    const handleFocus = (evt) => {
      callEmit(props.onFocus, evt);
    };
    const handleBlur = (evt) => {
      callEmit(props.onBlur, evt);
      accessor.markAsBlurred();
    };
    const size = computed(() => {
      var _a;
      return (_a = props.size) != null ? _a : formContext == null ? void 0 : formContext.size.value;
    });
    const classes = computed(() => {
      const {
        loading
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-checked`]: isChecked.value,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-${size.value}`]: true
      };
    });
    onMounted(() => props.autofocus && focus());
    return () => {
      var _a, _b;
      const checked = isChecked.value;
      const label = (_b = (_a = slots.label) == null ? void 0 : _a.call(slots, {
        checked
      })) != null ? _b : props.labels[checked ? 0 : 1];
      const prefixCls = mergedPrefixCls.value;
      return createVNode("button", {
        "ref": elementRef,
        "type": "button",
        "class": classes.value,
        "onClick": handleClick,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, [props.loading && createVNode("span", {
        "class": `${prefixCls}-loading-icon`
      }, [createVNode(IxIcon, {
        "name": "loading"
      }, null)]), createVNode("span", {
        "class": `${prefixCls}-label`
      }, [label])]);
    };
  }
});
const IxSwitch = Switch;

const tableColumnKey = "__IDUX_TABLE_COLUMN";
const TableColumn = () => {
};
TableColumn.displayName = "IxTableColumn";
TableColumn[tableColumnKey] = true;
var __defProp$5$1 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$5$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$5$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5$1 = (obj, key, value) => key in obj ? __defProp$5$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5$1.call(b, prop))
      __defNormalProp$5$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$5$1)
    for (var prop of __getOwnPropSymbols$5$1(b)) {
      if (__propIsEnum$5$1.call(b, prop))
        __defNormalProp$5$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5$1)
    for (var prop of __getOwnPropSymbols$5$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useColumns(props, slots, config, scrollBarSizeOnFixedHolder) {
  const breakpoints = useSharedBreakpoints();
  const mergedColumns = computed(() => {
    var _a;
    const { columns } = props;
    if (columns && columns.length > 0) {
      return mergeColumns(props.columns, breakpoints, config.columnBase, config.columnExpandable);
    } else {
      return mergeColumns(convertColumns((_a = slots.default) == null ? void 0 : _a.call(slots)), breakpoints, config.columnBase, config.columnExpandable);
    }
  });
  const { flattedColumns, scrollBarColumn, flattedColumnsWithScrollBar } = useFlattedColumns(mergedColumns, scrollBarSizeOnFixedHolder);
  const fixedColumnKeys = useFixedColumnKeys(flattedColumnsWithScrollBar);
  const hasEllipsis = computed(() => flattedColumns.value.some((column) => column.ellipsis));
  const hasFixed = computed(() => flattedColumns.value.some((column) => column.fixed));
  const { columnWidths, columnWidthsWithScrollBar, changeColumnWidth } = useColumnWidths(flattedColumns, scrollBarColumn);
  const { columnOffsets, columnOffsetsWithScrollBar } = useColumnOffsets(columnWidths, columnWidthsWithScrollBar);
  const mergedRows = computed(() => mergeRows(mergedColumns.value, scrollBarColumn.value));
  return {
    flattedColumns,
    scrollBarColumn,
    flattedColumnsWithScrollBar,
    fixedColumnKeys,
    hasEllipsis,
    hasFixed,
    columnWidths,
    columnWidthsWithScrollBar,
    changeColumnWidth,
    columnOffsets,
    columnOffsetsWithScrollBar,
    mergedRows
  };
}
function mergeColumns(columns, breakpoints, baseConfig, expandableConfig) {
  return columns.filter((column) => !column.responsive || column.responsive.some((key) => breakpoints[key])).map((column, index) => covertColumn(column, breakpoints, baseConfig, expandableConfig, index));
}
function convertColumns(nodes) {
  const columns = [];
  flattenNode(nodes, { key: tableColumnKey }).forEach((node, index) => {
    const { props, children } = node;
    const _a = props || {}, { key = index, editable, ellipsis } = _a, newColumn = __objRest$2(_a, ["key", "editable", "ellipsis"]);
    newColumn.key = key;
    newColumn.editable = editable || editable === "";
    newColumn.editable = ellipsis || ellipsis === "";
    const { default: defaultSlot, cell, title, expand, icon } = children || {};
    if (defaultSlot) {
      newColumn.children = convertColumns(defaultSlot());
    }
    if (cell) {
      newColumn.customCell = cell;
    }
    if (title) {
      newColumn.customTitle = title;
    }
    if (expand) {
      newColumn.customExpand = expand;
    }
    if (icon) {
      newColumn.customIcon = icon;
    }
    columns.push(newColumn);
  });
  return columns;
}
function covertColumn(column, breakpoints, baseConfig, expandableConfig, index) {
  var _a;
  const { align = baseConfig.align } = column;
  if ("type" in column) {
    const key = `IDUX_TABLE_KEY_${column.type}`;
    if (column.type === "expandable") {
      const { icon = expandableConfig.icon } = column;
      return __spreadProps$5(__spreadValues$5$1({}, column), { key, align, icon });
    } else {
      const multiple = (_a = column.multiple) != null ? _a : true;
      return __spreadProps$5(__spreadValues$5$1({}, column), { key, align, multiple });
    }
  } else {
    const { key, dataKey, sortable, filterable, children } = column;
    const _key = key != null ? key : convertArray(dataKey).join("-") || `'IDUX_TABLE_KEY_${index}`;
    const newColumn = __spreadProps$5(__spreadValues$5$1({}, column), { key: _key, align });
    if (sortable) {
      newColumn.sortable = __spreadValues$5$1(__spreadValues$5$1({}, baseConfig.sortable), sortable);
    }
    if (filterable) {
      newColumn.filterable = __spreadValues$5$1(__spreadValues$5$1({}, baseConfig.filterable), filterable);
    }
    if (children == null ? void 0 : children.length) {
      newColumn.children = mergeColumns(children, breakpoints, baseConfig, expandableConfig);
    }
    return newColumn;
  }
}
function useFlattedColumns(mergedColumns, scrollBarSizeOnFixedHolder) {
  const flattedColumns = computed(() => flatColumns(mergedColumns.value));
  const scrollBarColumn = computed(() => {
    const scrollBarSize = scrollBarSizeOnFixedHolder.value;
    if (scrollBarSize === 0) {
      return void 0;
    }
    const columns = flattedColumns.value;
    const lastColumn = columns[columns.length - 1];
    return {
      key: "IDUX_TABLE_KEY_scroll-bar",
      type: "scroll-bar",
      fixed: lastColumn && lastColumn.fixed,
      width: scrollBarSize
    };
  });
  const flattedColumnsWithScrollBar = computed(() => {
    const columns = flattedColumns.value;
    if (columns.length === 0) {
      return columns;
    }
    const scrollBar = scrollBarColumn.value;
    return scrollBar ? [...columns, scrollBar] : columns;
  });
  return { flattedColumns, scrollBarColumn, flattedColumnsWithScrollBar };
}
function flatColumns(columns) {
  const result = [];
  columns.forEach((column) => {
    const { fixed, children: subColumns } = column;
    if (subColumns == null ? void 0 : subColumns.length) {
      let subFlattedColumns = flatColumns(subColumns);
      if (fixed) {
        subFlattedColumns = subFlattedColumns.map((item) => __spreadValues$5$1({ fixed }, item));
      }
      result.push(...subFlattedColumns);
    } else {
      result.push(column);
    }
  });
  return result;
}
function useFixedColumnKeys(flattedColumnsWithScrollBar) {
  return computed(() => {
    let lastStartKey;
    let firstEndKey;
    flattedColumnsWithScrollBar.value.forEach((column) => {
      const { fixed, key } = column;
      if (fixed === "start") {
        lastStartKey = key;
      } else if (fixed === "end") {
        if (!firstEndKey) {
          firstEndKey = key;
        }
      }
    });
    return { lastStartKey, firstEndKey };
  });
}
function useColumnWidths(flattedColumns, scrollBarColumn) {
  const widthMap = reactive({});
  const widthString = ref();
  watchEffect(() => {
    const keys = Object.keys(widthMap);
    const columns = flattedColumns.value;
    if (keys.length !== columns.length) {
      widthString.value = void 0;
      return;
    }
    widthString.value = columns.map((column) => widthMap[column.key]).join("-");
  });
  const columnWidths = computed(() => {
    const _widthString = widthString.value;
    return _widthString ? _widthString.split("-").map(Number) : [];
  });
  const columnWidthsWithScrollBar = computed(() => {
    const widths = columnWidths.value;
    if (widths.length === 0) {
      return widths;
    }
    const scrollBar = scrollBarColumn.value;
    return scrollBar ? [...widths, scrollBar.width] : widths;
  });
  const changeColumnWidth = (key, width) => {
    if (width === false) {
      delete widthMap[key];
    } else {
      widthMap[key] = width;
    }
  };
  return { columnWidths, columnWidthsWithScrollBar, changeColumnWidth };
}
function useColumnOffsets(columnWidths, columnWidthsWithScrollBar) {
  const columnOffsets = computed(() => calculateOffsets(columnWidths.value));
  const columnOffsetsWithScrollBar = computed(() => calculateOffsets(columnWidthsWithScrollBar.value));
  return { columnOffsets, columnOffsetsWithScrollBar };
}
function calculateOffsets(widths) {
  const count = widths.length;
  const startOffsets = [];
  const endOffsets = [];
  let startOffset = 0;
  let endOffset = 0;
  for (let start = 0; start < count; start++) {
    startOffsets[start] = startOffset;
    startOffset += widths[start] || 0;
    const end = count - start - 1;
    endOffsets[end] = endOffset;
    endOffset += widths[end] || 0;
  }
  return {
    starts: startOffsets,
    ends: endOffsets
  };
}
function mergeRows(mergedColumns, scrollBarColumn) {
  const rows = [];
  function calculateColSpans(columns, colIndex, rowIndex) {
    var _a;
    (_a = rows[rowIndex]) != null ? _a : rows[rowIndex] = [];
    let colStart = colIndex;
    const titleColSpans = columns.map((column) => {
      var _a2;
      let titleColSpan = (_a2 = column.titleColSpan) != null ? _a2 : 1;
      let hasChildren = false;
      const subColumns = column.children;
      if (subColumns == null ? void 0 : subColumns.length) {
        hasChildren = true;
        const subColumnSpans = calculateColSpans(subColumns, colStart, rowIndex + 1);
        if (isNil(column.titleColSpan)) {
          titleColSpan = subColumnSpans.reduce((total, count) => total + count);
        }
      }
      const colEnd = colStart + titleColSpan - 1;
      rows[rowIndex].push(__spreadProps$5(__spreadValues$5$1({}, column), { titleColSpan, colStart, colEnd, hasChildren }));
      colStart += titleColSpan;
      return titleColSpan;
    });
    return titleColSpans;
  }
  const rootColumns = scrollBarColumn ? [...mergedColumns, scrollBarColumn] : mergedColumns;
  calculateColSpans(rootColumns, 0, 0);
  const rowCount = rows.length;
  rows.forEach((columns, rowIndex) => {
    columns.forEach((col) => {
      if (!col.hasChildren) {
        col.titleRowSpan = rowCount - rowIndex;
      }
    });
  });
  return rows;
}
var __defProp$4$1 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$4$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$4$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4$1 = (obj, key, value) => key in obj ? __defProp$4$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4$1.call(b, prop))
      __defNormalProp$4$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$4$1)
    for (var prop of __getOwnPropSymbols$4$1(b)) {
      if (__propIsEnum$4$1.call(b, prop))
        __defNormalProp$4$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
function useDataSource(props, getRowKey, activeSortable, activeFilters, expandedRowKeys, mergedPagination) {
  const mergedData = computed(() => {
    const { dataSource, childrenKey } = props;
    const getKey = getRowKey.value;
    return dataSource.map((record) => covertMergeData(record, getKey, childrenKey));
  });
  const mergedMap = computed(() => {
    const map = /* @__PURE__ */ new Map();
    covertDataMap(mergedData.value, map);
    return map;
  });
  const filteredData = computed(() => filterData(mergedData.value, activeFilters.value, expandedRowKeys.value));
  const sortedData = computed(() => sortData(filteredData.value, activeSortable, expandedRowKeys.value));
  const paginatedData = computed(() => {
    const pagination = mergedPagination.value;
    const data = sortedData.value;
    if (pagination === null || !pagination.pageSize) {
      return data;
    } else {
      const { total } = pagination;
      if (total && data.length < total) {
        return data;
      }
      const pageSize = pagination.pageSize;
      const startIndex = (pagination.pageIndex - 1) * pageSize;
      return data.slice(startIndex, startIndex + pageSize);
    }
  });
  const paginatedMap = computed(() => {
    const map = /* @__PURE__ */ new Map();
    covertDataMap(paginatedData.value, map);
    return map;
  });
  const flattedData = computed(() => {
    const expandedKeys = expandedRowKeys.value;
    if (expandedKeys.length > 0) {
      return flatData(paginatedData.value, expandedKeys, 0);
    }
    return paginatedData.value;
  });
  return { filteredData, flattedData, mergedMap, paginatedMap };
}
function covertMergeData(record, getRowKey, childrenKey, parentKey) {
  const rowKey = getRowKey(record);
  const result = { record, rowKey, parentKey };
  const subData = record[childrenKey];
  if (subData) {
    result.children = subData.map((subRecord) => covertMergeData(subRecord, getRowKey, childrenKey, rowKey));
  }
  return result;
}
function covertDataMap(mergedData, map) {
  mergedData.forEach((item) => {
    const { rowKey, children } = item;
    map.set(rowKey, item);
    if (children) {
      covertDataMap(children, map);
    }
  });
}
function sortData(mergedData, activeSortable, expandedRowKeys) {
  const { sorter, orderBy } = activeSortable;
  if (!sorter || !orderBy) {
    return mergedData;
  }
  const tempData = mergedData.slice();
  const orderFlag = orderBy === "ascend" ? 1 : -1;
  tempData.forEach((item) => {
    if (expandedRowKeys.includes(item.rowKey) && item.children && item.children.length > 0) {
      item.children = sortData(item.children, activeSortable, expandedRowKeys);
    }
  });
  return tempData.sort((curr, next) => orderFlag * sorter(curr.record, next.record));
}
function filterData(mergedData, activeFilters, expandedRowKeys) {
  if (activeFilters.length === 0) {
    return mergedData;
  }
  return mergedData.map((item) => {
    const valid = activeFilters.every(({ filter, filterBy }) => filter(filterBy, item.record));
    const { rowKey, children } = item;
    const isExpanded = expandedRowKeys.includes(rowKey);
    let newItem = item;
    if (isExpanded && children && children.length) {
      const newChildren = filterData(children, activeFilters, expandedRowKeys);
      if (newChildren.length !== children.length) {
        newItem = __spreadProps$4(__spreadValues$4$1({}, item), { children: newChildren });
      }
    }
    return valid || isExpanded && newItem.children ? newItem : null;
  }).filter((item) => item !== null);
}
function flatData(mergedData, expandedRowKeys, level) {
  return mergedData.reduce((result, item) => {
    const { children, parentKey, record, rowKey } = item;
    const expanded = expandedRowKeys.includes(rowKey);
    result.push({ children, parentKey, record, rowKey, level, expanded });
    if (expanded && item.children) {
      const childrenFlatData = flatData(item.children, expandedRowKeys, level + 1);
      result.push(...childrenFlatData);
    }
    return result;
  }, []);
}
function useExpandable$1(props, flattedColumns) {
  const expandable = computed(() => flattedColumns.value.find((column) => "type" in column && column.type === "expandable"));
  const [expandedRowKeys, setExpandedRowKeys] = useControlledProp(props, "expandedRowKeys", () => []);
  const handleExpandChange = (key, record) => {
    const { onChange, onExpand } = expandable.value || {};
    const tempKeys = [...expandedRowKeys.value];
    const index = tempKeys.indexOf(key);
    const expanded = index >= 0;
    if (expanded) {
      tempKeys.splice(index, 1);
    } else {
      tempKeys.push(key);
    }
    callEmit(onExpand, !expanded, record);
    setExpandedRowKeys(tempKeys);
    callEmit(onChange, tempKeys);
  };
  const checkExpandDisabled = (data) => {
    if (!expandable.value) {
      return true;
    }
    const { disabled, customExpand } = expandable.value;
    const { record } = data;
    if (disabled == null ? void 0 : disabled(record)) {
      return true;
    }
    return !(customExpand || data.children && data.children.length > 0);
  };
  return { expandable, expandedRowKeys, setExpandedRowKeys, checkExpandDisabled, handleExpandChange };
}
function useFilterable(flattedColumns) {
  const filterByMap = reactive({});
  const setFilterBy = (key, filterBy) => {
    filterByMap[key] = filterBy;
  };
  const filterableColumns = computed(() => flattedColumns.value.filter((column) => !!column.filterable));
  watch(filterableColumns, (columns) => {
    columns.forEach((column) => {
      var _a;
      if (filterByMap[column.key] === void 0) {
        filterByMap[column.key] = ((_a = column.filterable) == null ? void 0 : _a.filterBy) || [];
      }
    });
  }, { immediate: true });
  const activeFilters = computed(() => filterableColumns.value.map((column) => {
    const filterable = column.filterable;
    const filter = filterable.filter;
    const filterBy = filterable.filterBy || filterByMap[column.key];
    return { filter, filterBy };
  }).filter((item) => item.filter && item.filterBy.length > 0));
  return {
    activeFilters,
    filterByMap,
    setFilterBy
  };
}
function useGetRowKey(props, config) {
  return computed(() => {
    var _a;
    const rowKey = (_a = props.rowKey) != null ? _a : config.rowKey;
    if (isString(rowKey)) {
      return (record) => {
        const key = record[rowKey];
        if (process.env.NODE_ENV !== "production" && key === void 0) {
          Logger.warn("components/table", "Each record in table should have a unique `key` prop.");
        }
        return key;
      };
    }
    return rowKey;
  });
}
var __defProp$3$1 = Object.defineProperty;
var __defProps$3$1 = Object.defineProperties;
var __getOwnPropDescs$3$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$3$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$3$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3$1 = (obj, key, value) => key in obj ? __defProp$3$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3$1.call(b, prop))
      __defNormalProp$3$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$3$1)
    for (var prop of __getOwnPropSymbols$3$1(b)) {
      if (__propIsEnum$3$1.call(b, prop))
        __defNormalProp$3$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3$1 = (a, b) => __defProps$3$1(a, __getOwnPropDescs$3$1(b));
function usePagination(props, config) {
  const paginationConfig = useGlobalConfig$1("pagination");
  const pageIndex = ref();
  const pageSize = ref();
  const tempPagination = computed(() => {
    const { pagination } = props;
    if (pagination === false) {
      return null;
    }
    return pagination === true ? {} : pagination;
  });
  watchEffect(() => {
    var _a, _b, _c;
    const pagination = tempPagination.value;
    pageIndex.value = (_a = pagination == null ? void 0 : pagination.pageIndex) != null ? _a : 1;
    pageSize.value = (_c = (_b = pagination == null ? void 0 : pagination.pageSize) != null ? _b : config.pagination.pageSize) != null ? _c : paginationConfig.pageSize;
  });
  const handlePageIndexChange = (index) => {
    var _a;
    pageIndex.value = index;
    callEmit((_a = tempPagination.value) == null ? void 0 : _a["onUpdate:pageIndex"], index);
  };
  const handlePageSizeChange = (size) => {
    var _a;
    pageSize.value = size;
    callEmit((_a = tempPagination.value) == null ? void 0 : _a["onUpdate:pageSize"], size);
  };
  const mergedPagination = computed(() => {
    const pagination = tempPagination.value;
    if (pagination === null) {
      return null;
    }
    return __spreadProps$3$1(__spreadValues$3$1(__spreadValues$3$1({}, config.pagination), pagination), {
      pageIndex: pageIndex.value,
      pageSize: pageSize.value,
      "onUpdate:pageIndex": handlePageIndexChange,
      "onUpdate:pageSize": handlePageSizeChange
    });
  });
  return { mergedPagination };
}
function useScroll(props, { isSticky, stickyScrollLeft }) {
  var _a, _b;
  const { scrollHeadRef, scrollBodyRef, scrollFootRef, handleScroll, pingedStart, pingedEnd } = useScrollRef(stickyScrollLeft);
  process.env.NODE_ENV !== "production" && ((_a = props.scroll) == null ? void 0 : _a.x) && Logger.warn("components/table", "`scroll.x` was deprecated, please use `scroll.width` instead");
  process.env.NODE_ENV !== "production" && ((_b = props.scroll) == null ? void 0 : _b.y) && Logger.warn("components/table", "`scroll.y` was deprecated, please use `scroll.height` instead");
  const scrollWidth = computed(() => {
    var _a2, _b2;
    return convertCssPixel(((_a2 = props.scroll) == null ? void 0 : _a2.width) || ((_b2 = props.scroll) == null ? void 0 : _b2.x));
  });
  const scrollHeight = computed(() => {
    var _a2, _b2;
    return convertCssPixel(((_a2 = props.scroll) == null ? void 0 : _a2.height) || ((_b2 = props.scroll) == null ? void 0 : _b2.y));
  });
  const scrollBarSize = computed(() => props.virtual ? 0 : getScrollBarSize(convertElement(scrollBodyRef)));
  const scrollBarSizeOnFixedHolder = computed(() => isSticky.value ? 0 : scrollHeight.value ? scrollBarSize.value : 0);
  const scrollTo = (options) => {
    var _a2;
    if (props.virtual) {
      return (_a2 = scrollBodyRef.value) == null ? void 0 : _a2.scrollTo(options);
    }
  };
  return {
    scrollHeadRef,
    scrollBodyRef,
    scrollFootRef,
    handleScroll,
    scrollTo,
    pingedStart,
    pingedEnd,
    scrollWidth,
    scrollHeight,
    scrollBarSize,
    scrollBarSizeOnFixedHolder
  };
}
function useScrollRef(stickyScrollLeft) {
  const scrollHeadRef = ref();
  const scrollBodyRef = ref();
  const scrollFootRef = ref();
  const changeStickyScrollLeft = (scrollLeft) => {
    const scrollBodyElement = convertElement(scrollBodyRef);
    if (!scrollBodyElement) {
      return;
    }
    const { clientWidth, scrollWidth } = scrollBodyElement;
    stickyScrollLeft.value = scrollLeft / scrollWidth * clientWidth || 0;
  };
  const pingedStart = ref(false);
  const pingedEnd = ref(false);
  const lockedScrollTargetRef = ref();
  let timeout;
  const clearTimer = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  const lockScrollTarget = (target) => {
    lockedScrollTargetRef.value = target;
    clearTimer();
    timeout = setTimeout(() => {
      lockedScrollTargetRef.value = void 0;
      timeout = void 0;
    }, 100);
  };
  onBeforeUnmount(() => clearTimer());
  const forceScroll = (scrollLeft, target) => {
    if (!target) {
      return;
    }
    if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
    }
  };
  const handleScroll = (evt, scrollLeft) => {
    const currentTarget = evt == null ? void 0 : evt.currentTarget;
    const mergedScrollLeft = scrollLeft != null ? scrollLeft : currentTarget.scrollLeft;
    const lockedTarget = lockedScrollTargetRef.value;
    if (!lockedTarget || lockedTarget === currentTarget) {
      lockScrollTarget(currentTarget);
      forceScroll(mergedScrollLeft, scrollHeadRef.value);
      forceScroll(mergedScrollLeft, convertElement(scrollBodyRef));
      forceScroll(mergedScrollLeft, scrollFootRef.value);
      changeStickyScrollLeft(mergedScrollLeft);
    }
    if (currentTarget) {
      const { scrollWidth, clientWidth } = currentTarget;
      pingedStart.value = mergedScrollLeft > 0;
      pingedEnd.value = mergedScrollLeft < scrollWidth - clientWidth;
    }
  };
  return {
    scrollHeadRef,
    scrollBodyRef,
    scrollFootRef,
    handleScroll,
    pingedStart,
    pingedEnd
  };
}
function useSelectable$1(props, locale, flattedColumns, { mergedMap, paginatedMap }) {
  const selectable = computed(() => flattedColumns.value.find((column) => "type" in column && column.type === "selectable"));
  const [selectedRowKeys, setSelectedRowKeys] = useControlledProp(props, "selectedRowKeys", () => []);
  const currentPageRowKeys = computed(() => {
    const { disabled } = selectable.value || {};
    const enabledRowKeys = [];
    const disabledRowKeys = [];
    paginatedMap.value.forEach((currData, key) => {
      if (disabled == null ? void 0 : disabled(currData.record)) {
        disabledRowKeys.push(key);
      } else {
        enabledRowKeys.push(key);
      }
    });
    return { enabledRowKeys, disabledRowKeys };
  });
  const indeterminateRowKeys = computed(() => {
    const indeterminateKeySet = /* @__PURE__ */ new Set();
    const selectedKeys = selectedRowKeys.value;
    const { disabledRowKeys } = currentPageRowKeys.value;
    const dataMap = mergedMap.value;
    selectedKeys.forEach((key) => {
      const { parentKey } = dataMap.get(key) || {};
      if (!isNil(parentKey)) {
        let parent = dataMap.get(parentKey);
        if (parent && !selectedKeys.includes(parent.rowKey)) {
          while (parent && !isNil(parent == null ? void 0 : parent.rowKey)) {
            if (!disabledRowKeys.includes(parent.rowKey)) {
              indeterminateKeySet.add(parent.rowKey);
            }
            parent = !isNil(parent.parentKey) ? dataMap.get(parent.parentKey) : void 0;
          }
        }
      }
    });
    return [...indeterminateKeySet];
  });
  const countCurrentPageSelected = computed(() => {
    const selectedKeys = selectedRowKeys.value;
    const { disabledRowKeys } = currentPageRowKeys.value;
    let total = 0;
    paginatedMap.value.forEach((_, key) => {
      if (!disabledRowKeys.includes(key) && selectedKeys.includes(key)) {
        total++;
      }
    }, 0);
    return total;
  });
  const currentPageAllSelected = computed(() => {
    const dataCount = paginatedMap.value.size;
    const disabledCount = currentPageRowKeys.value.disabledRowKeys.length;
    if (dataCount === 0 || dataCount === disabledCount) {
      return false;
    }
    return dataCount === disabledCount + countCurrentPageSelected.value;
  });
  const currentPageSomeSelected = computed(() => !currentPageAllSelected.value && countCurrentPageSelected.value > 0);
  const emitChange = (tempRowKeys) => {
    setSelectedRowKeys(tempRowKeys);
    const dataMap = mergedMap.value;
    const { onChange } = selectable.value || {};
    if (onChange) {
      const selectedRecords = [];
      tempRowKeys.forEach((key) => {
        const currData = dataMap.get(key);
        currData && selectedRecords.push(currData.record);
      });
      callEmit(onChange, tempRowKeys, selectedRecords);
    }
  };
  const handleSelectChange = (key, record) => {
    const dataMap = mergedMap.value;
    const { disabledRowKeys } = currentPageRowKeys.value;
    const { multiple, onSelect } = selectable.value || {};
    let tempRowKeys = [...selectedRowKeys.value];
    const index = tempRowKeys.indexOf(key);
    const selected = index >= 0;
    if (multiple) {
      const currData = dataMap.get(key);
      const childrenKeys = getChildrenKeys$1(currData, disabledRowKeys);
      if (selected) {
        tempRowKeys.splice(index, 1);
        const parentKeys = getParentKeys$1(dataMap, currData, disabledRowKeys);
        tempRowKeys = tempRowKeys.filter((key2) => !parentKeys.includes(key2) && !childrenKeys.includes(key2));
      } else {
        tempRowKeys.push(key);
        tempRowKeys.push(...childrenKeys);
      }
      setParentSelected(dataMap, currData, tempRowKeys, disabledRowKeys);
    } else {
      tempRowKeys = selected ? [] : [key];
    }
    callEmit(onSelect, !selected, record);
    emitChange(tempRowKeys);
  };
  const handleHeadSelectChange = () => {
    const { enabledRowKeys } = currentPageRowKeys.value;
    const tempRowKeySet = new Set(selectedRowKeys.value);
    if (currentPageAllSelected.value) {
      enabledRowKeys.forEach((key) => tempRowKeySet.delete(key));
    } else {
      enabledRowKeys.forEach((key) => tempRowKeySet.add(key));
    }
    emitChange([...tempRowKeySet]);
  };
  const mergedSelectableMenus = useMergedMenus(selectable, locale);
  const handleSelectableMenuClick = useMenuClickHandle(selectable, mergedMap, paginatedMap, selectedRowKeys, emitChange);
  return {
    selectable,
    selectedRowKeys,
    indeterminateRowKeys,
    currentPageRowKeys,
    currentPageAllSelected,
    currentPageSomeSelected,
    handleSelectChange,
    handleHeadSelectChange,
    mergedSelectableMenus,
    handleSelectableMenuClick
  };
}
function getChildrenKeys$1(currData, disabledRowKeys) {
  const keys = [];
  const { children } = currData || {};
  children && children.forEach((item) => {
    const { rowKey } = item;
    if (!disabledRowKeys.includes(rowKey)) {
      keys.push(item.rowKey);
    }
    keys.push(...getChildrenKeys$1(item, disabledRowKeys));
  });
  return keys;
}
function getParentKeys$1(dataMap, currData, disabledRowKeys) {
  const keys = [];
  while (currData == null ? void 0 : currData.parentKey) {
    const { parentKey } = currData;
    if (!disabledRowKeys.includes(currData.parentKey)) {
      keys.push(parentKey);
    }
    currData = dataMap.get(parentKey);
  }
  return keys;
}
function setParentSelected(dataMap, currData, tempRowKeys, disabledRowKeys) {
  let parentSelected = true;
  while (parentSelected && currData && !isNil(currData.parentKey)) {
    const parent = dataMap.get(currData.parentKey);
    if (parent && !disabledRowKeys.includes(currData.parentKey)) {
      parentSelected = parent.children.every((item) => disabledRowKeys.includes(item.rowKey) || tempRowKeys.includes(item.rowKey));
      const parentKeyIdx = tempRowKeys.findIndex((key) => key === currData.parentKey);
      if (parentSelected) {
        parentKeyIdx < 0 && tempRowKeys.push(currData.parentKey);
      } else {
        parentKeyIdx > -1 && tempRowKeys.splice(parentKeyIdx, 1);
      }
    }
    currData = parent;
  }
}
const allMenuItemKey = Symbol("IDUX_TABLE_KEY_selectable-all");
const invertMenuItemKey = Symbol("IDUX_TABLE_KEY_selectable-invert");
const noneMenuItemKey = Symbol("IDUX_TABLE_KEY_selectable-none");
const pageInvertMenuItemKey = Symbol("IDUX_TABLE_KEY_selectable-pageInvert");
function useMergedMenus(selectable, locale) {
  return computed(() => {
    const { menus } = selectable.value || {};
    if (!menus || menus.length === 0) {
      return [];
    }
    const { selectAll, selectInvert, selectNone, selectPageInvert } = locale.value;
    return menus.map((item) => {
      if (isString(item)) {
        if (item === "all") {
          return { type: "item", key: allMenuItemKey, label: selectAll };
        }
        if (item === "invert") {
          return { type: "item", key: invertMenuItemKey, label: selectInvert };
        }
        if (item === "none") {
          return { type: "item", key: noneMenuItemKey, label: selectNone };
        }
        if (item === "pageInvert") {
          return { type: "item", key: pageInvertMenuItemKey, label: selectPageInvert };
        }
        return { type: "item", key: item, label: item };
      }
      return item;
    });
  });
}
function useMenuClickHandle(selectable, mergedMap, paginatedMap, selectedRowKeys, emitChange) {
  const handleSelectAll = () => {
    const { disabled, onSelectAll } = selectable.value || {};
    const tempRowKeys = [];
    mergedMap.value.forEach((currData, key) => {
      if (!(disabled == null ? void 0 : disabled(currData.record))) {
        tempRowKeys.push(key);
      }
    });
    callEmit(onSelectAll, tempRowKeys);
    emitChange(tempRowKeys);
  };
  const handleSelectInvert = () => {
    const { disabled, onSelectInvert } = selectable.value || {};
    const tempRowKeys = [...selectedRowKeys.value];
    mergedMap.value.forEach((currData, key) => {
      if (disabled == null ? void 0 : disabled(currData.record)) {
        return;
      }
      const index = tempRowKeys.indexOf(key);
      if (index >= 0) {
        tempRowKeys.splice(index, 1);
      } else {
        tempRowKeys.push(key);
      }
    });
    emitChange(tempRowKeys);
    callEmit(onSelectInvert, tempRowKeys);
  };
  const handleSelectNone = () => {
    const { onSelectNone } = selectable.value || {};
    callEmit(onSelectNone);
    emitChange([]);
  };
  const handleSelectPageInvert = () => {
    const { disabled, onSelectPageInvert } = selectable.value || {};
    const tempRowKeys = [];
    const currSelectedRowKeys = selectedRowKeys.value;
    paginatedMap.value.forEach((currData, key) => {
      if ((disabled == null ? void 0 : disabled(currData.record)) || currSelectedRowKeys.includes(key)) {
        return;
      }
      tempRowKeys.push(key);
    });
    callEmit(onSelectPageInvert, tempRowKeys);
    emitChange(tempRowKeys);
  };
  const menuClickHandles = /* @__PURE__ */ new Map([
    [allMenuItemKey, handleSelectAll],
    [invertMenuItemKey, handleSelectInvert],
    [noneMenuItemKey, handleSelectNone],
    [pageInvertMenuItemKey, handleSelectPageInvert]
  ]);
  return (options) => {
    const key = options.key;
    if (isSymbol(key) && menuClickHandles.has(key)) {
      const handle = menuClickHandles.get(key);
      handle();
      return;
    }
    const { disabled, onMenuClick } = selectable.value || {};
    if (!onMenuClick) {
      return;
    }
    const tempRowKeys = [];
    paginatedMap.value.forEach((currData, key2) => {
      if (disabled == null ? void 0 : disabled(currData.record)) {
        return;
      }
      tempRowKeys.push(key2);
    });
    callEmit(onMenuClick, options, tempRowKeys);
  };
}
function useSortable(flattedColumns) {
  var _a, _b;
  const activeSortColumn = computed(() => flattedColumns.value.find((column) => {
    var _a2;
    return (_a2 = column.sortable) == null ? void 0 : _a2.orderBy;
  }));
  const orderByRef = ref((_b = (_a = activeSortColumn.value) == null ? void 0 : _a.sortable) == null ? void 0 : _b.orderBy);
  const tempOrderByRef = ref();
  const activeSortable = reactive({
    orderBy: orderByRef.value
  });
  watch(activeSortColumn, () => {
    const sortColumn = activeSortColumn.value;
    if (sortColumn) {
      activeSortable.key = sortColumn.key;
      orderByRef.value = sortColumn.sortable.orderBy;
      activeSortable.sorter = sortColumn.sortable.sorter;
    } else {
      activeSortable.key = void 0;
      orderByRef.value = void 0;
      tempOrderByRef.value = void 0;
      activeSortable.sorter = void 0;
    }
  });
  watch([orderByRef, tempOrderByRef], () => {
    var _a2;
    activeSortable.orderBy = (_a2 = orderByRef.value) != null ? _a2 : tempOrderByRef.value;
  });
  const handleSort = (key, sortable) => {
    const { orders, sorter, onChange } = sortable;
    const isSameKey = key === activeSortable.key;
    const orderBy = isSameKey ? getCurrOrderBy(orders, activeSortable.orderBy) : getCurrOrderBy(orders);
    if (!isSameKey) {
      activeSortable.key = key;
      activeSortable.sorter = sorter;
    }
    tempOrderByRef.value = orderBy;
    callEmit(onChange, orderBy);
  };
  return { activeSortable, handleSort };
}
function getCurrOrderBy(orders, currOrderBy) {
  if (!currOrderBy) {
    return orders[0];
  }
  return orders[orders.indexOf(currOrderBy) + 1];
}
function useSticky(props) {
  const isSticky = computed(() => !!props.sticky);
  const mergedSticky = computed(() => {
    const { sticky } = props;
    const {
      offsetHead = 0,
      offsetFoot = 0,
      offsetScroll = 0,
      container = window
    } = isPlainObject(sticky) ? sticky : {};
    return {
      offsetHead,
      offsetFoot,
      offsetScroll,
      container
    };
  });
  const stickyScrollLeft = ref(0);
  return { isSticky, mergedSticky, stickyScrollLeft };
}
function useTableLayout(props, { hasEllipsis, hasFixed }, { scrollWidth, scrollHeight }, isSticky) {
  return computed(() => {
    if (props.tableLayout) {
      return props.tableLayout;
    }
    if (scrollHeight.value && hasFixed.value) {
      return scrollWidth.value === "max-content" ? "auto" : "fixed";
    }
    if (scrollWidth.value || isSticky.value || hasEllipsis.value || props.virtual) {
      return "fixed";
    }
    return "auto";
  });
}
function useTags(props) {
  return {
    tableTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.table) != null ? _b : "table";
    }),
    headTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.head) != null ? _b : "thead";
    }),
    headRowTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.headRow) != null ? _b : "tr";
    }),
    headColTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.headCol) != null ? _b : "th";
    }),
    bodyTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.body) != null ? _b : "tbody";
    }),
    bodyRowTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.bodyRow) != null ? _b : "tr";
    }),
    bodyColTag: computed(() => {
      var _a, _b;
      return (_b = (_a = props.tags) == null ? void 0 : _a.bodyCol) != null ? _b : "td";
    })
  };
}
const TABLE_TOKEN = Symbol("TABLE_TOKEN");
const tableBodyToken = Symbol("tableBodyToken");
var ColGroup = defineComponent({
  props: {
    ixFixedHolder: Boolean
  },
  setup(props) {
    const {
      flattedColumns,
      flattedColumnsWithScrollBar,
      columnWidths,
      columnWidthsWithScrollBar,
      mergedSelectableMenus,
      mergedPrefixCls
    } = inject(TABLE_TOKEN);
    const isRender = computed(() => flattedColumns.value.some((column) => !!column.width || "type" in column));
    return () => {
      const {
        ixFixedHolder
      } = props;
      let children;
      if (ixFixedHolder) {
        const widths = columnWidthsWithScrollBar.value;
        children = flattedColumnsWithScrollBar.value.map((column, colIndex) => renderCol(mergedPrefixCls, mergedSelectableMenus, column, widths[colIndex]));
      } else if (isRender.value) {
        const widths = columnWidths.value;
        children = flattedColumns.value.map((column, colIndex) => renderCol(mergedPrefixCls, mergedSelectableMenus, column, widths[colIndex]));
      }
      return createVNode("colgroup", null, [children]);
    };
  }
});
function renderCol(mergedPrefixCls, mergedSelectableMenus, column, width) {
  const prefixCls = mergedPrefixCls.value;
  const type = "type" in column && column.type;
  const className = normalizeClass({
    [`${prefixCls}-col-${type}`]: !!type,
    [`${prefixCls}-selectable-with-dropdown`]: type === "selectable" && mergedSelectableMenus.value.length > 0
  });
  const mergedWidth = width != null ? width : column.width;
  const style = mergedWidth ? {
    width: convertCssPixel(mergedWidth)
  } : void 0;
  return createVNode("col", {
    "key": column.key,
    "class": className,
    "style": style
  }, null);
}
var FixedHolder = defineComponent({
  setup(_, {
    slots
  }) {
    const {
      mergedPrefixCls,
      scrollHeadRef,
      handleScroll,
      scrollWidth,
      flattedData,
      isSticky,
      mergedSticky,
      columnWidths
    } = inject(TABLE_TOKEN);
    useScrollEvents(scrollHeadRef, handleScroll);
    const isMaxContent = computed(() => scrollWidth.value === "max-content");
    const hasData = computed(() => flattedData.value.length > 0);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [`${prefixCls}-fixed-holder`]: true,
        [`${prefixCls}-sticky-holder`]: isSticky.value
      };
    });
    const style = computed(() => {
      const sticky = isSticky.value;
      const {
        offsetHead,
        offsetFoot
      } = mergedSticky.value;
      return {
        overflow: "hidden",
        top: sticky ? offsetHead : void 0,
        bottom: sticky ? offsetFoot : void 0
      };
    });
    const tableStyle = computed(() => {
      const visibility = hasData.value && !columnWidths.value.length ? "hidden" : void 0;
      return {
        tableLayout: "fixed",
        visibility
      };
    });
    return () => {
      var _a;
      const children = hasData.value && !isMaxContent.value ? createVNode(ColGroup, {
        "ixFixedHolder": true
      }, null) : null;
      return createVNode("div", {
        "class": classes.value,
        "style": style.value,
        "ref": scrollHeadRef
      }, [createVNode("table", {
        "style": tableStyle.value
      }, [children, (_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
function useScrollEvents(scrollHeadRef, handleScroll) {
  const onWheel = (evt) => {
    const deltaX = evt.deltaX;
    const currentTarget = evt.currentTarget;
    if (deltaX) {
      const scrollLeft = currentTarget.scrollLeft + deltaX;
      handleScroll(evt, scrollLeft);
      evt.preventDefault();
    }
  };
  onMounted(() => on(scrollHeadRef.value, "wheel", onWheel, {
    passive: true
  }));
  onBeforeUnmount(() => off(scrollHeadRef.value, "wheel", onWheel));
}
var StickyScroll = defineComponent({
  setup() {
    const {
      mergedPrefixCls,
      scrollBodyRef,
      handleScroll,
      mergedSticky,
      stickyScrollLeft
    } = inject(TABLE_TOKEN);
    const isShow = ref(false);
    const isActive = ref(false);
    const delta = ref(0);
    const bodyClientWidth = ref(0);
    const bodyScrollWidth = ref(0);
    const scrollBarWidth = computed(() => {
      const clientWidth = bodyClientWidth.value;
      const scrollWidth = bodyScrollWidth.value;
      return scrollWidth && clientWidth * (clientWidth / scrollWidth);
    });
    watchEffect(() => {
      const scrollBodyElement = convertElement(scrollBodyRef);
      if (!scrollBodyElement) {
        return;
      }
      if (isShow.value) {
        const {
          clientWidth,
          scrollWidth,
          scrollLeft
        } = scrollBodyElement;
        stickyScrollLeft.value = scrollLeft / scrollWidth * clientWidth;
        bodyClientWidth.value = clientWidth;
        bodyScrollWidth.value = scrollWidth;
      }
    });
    const style = computed(() => {
      return {
        height: getScrollBarSize(),
        width: bodyClientWidth.value,
        bottom: mergedSticky.value.offsetScroll
      };
    });
    const scrollBarClasses = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return {
        [`${prefixCls}-sticky-scroll-bar`]: true,
        [`${prefixCls}-sticky-scroll-bar-active`]: isActive.value
      };
    });
    const scrollBarStyle = computed(() => {
      return {
        width: `${scrollBarWidth.value}px`,
        transform: `translate3d(${stickyScrollLeft.value}px, 0, 0)`
      };
    });
    const handleMouseUp = () => isActive.value = false;
    const handleMouseDown = (evt) => {
      delta.value = evt.pageX - stickyScrollLeft.value;
      isActive.value = true;
      evt.preventDefault();
    };
    const handleMouseMove = (evt) => {
      if (!isActive.value) {
        return;
      }
      const {
        buttons
      } = evt || window.event;
      if (buttons === 0) {
        isActive.value = false;
        return;
      }
      let left = evt.pageX - delta.value;
      if (left <= 0) {
        left = 0;
      }
      const clientWidth = bodyClientWidth.value;
      const scrollWidth = bodyScrollWidth.value;
      const barWidth = scrollBarWidth.value;
      if (left + barWidth >= clientWidth) {
        left = clientWidth - barWidth;
      }
      const scrollLeft = left / clientWidth * (scrollWidth + 2);
      handleScroll(evt, scrollLeft);
    };
    const handleContainerScroll = () => {
      const scrollBodyElement = convertElement(scrollBodyRef);
      const offsetTop = getOffset(scrollBodyElement).top;
      const offsetBottom = offsetTop + scrollBodyElement.offsetHeight;
      const {
        container,
        offsetScroll
      } = mergedSticky.value;
      const offsetClient = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
      if (offsetBottom - getScrollBarSize() <= offsetClient || offsetTop >= offsetClient - offsetScroll) {
        isShow.value = false;
      } else {
        isShow.value = true;
      }
    };
    onMounted(() => {
      on(document.body, "mouseup", handleMouseUp);
      on(document.body, "mousemove", handleMouseMove);
      on(window, "resize", handleContainerScroll);
      watch(() => mergedSticky.value.container, (currContainer, oldContainer) => {
        off(oldContainer, "scroll", handleContainerScroll);
        on(currContainer, "scroll", handleContainerScroll);
      }, {
        immediate: true
      });
      handleContainerScroll();
    });
    onBeforeUnmount(() => {
      off(document.body, "mouseup", handleMouseUp);
      off(document.body, "mousemove", handleMouseMove);
      off(window, "resize", handleContainerScroll);
      off(mergedSticky.value.container, "scroll", handleContainerScroll);
    });
    return () => {
      if (!scrollBodyRef.value || !isShow.value || bodyScrollWidth.value <= bodyClientWidth.value || !scrollBarWidth.value) {
        return null;
      }
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-sticky-scroll`,
        "style": style.value
      }, [createVNode("div", {
        "class": scrollBarClasses.value,
        "style": scrollBarStyle.value,
        "onMousedown": handleMouseDown
      }, null)]);
    };
  }
});
const tableProps = {
  expandedRowKeys: IxPropTypes.array(),
  selectedRowKeys: IxPropTypes.array(),
  borderless: IxPropTypes.bool,
  childrenKey: IxPropTypes.string.def("children"),
  columns: IxPropTypes.array().def(() => []),
  dataSource: IxPropTypes.array().def(() => []),
  empty: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  header: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  headless: IxPropTypes.bool,
  pagination: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]),
  rowClassName: IxPropTypes.func(),
  rowKey: IxPropTypes.oneOfType([String, IxPropTypes.func()]),
  scroll: IxPropTypes.object(),
  size: IxPropTypes.oneOf(["lg", "md", "sm"]),
  spin: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]),
  sticky: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]),
  tableLayout: IxPropTypes.oneOf(["auto", "fixed"]),
  tags: IxPropTypes.object(),
  virtual: IxPropTypes.bool.def(false),
  "onUpdate:expandedRowKeys": IxPropTypes.emit(),
  "onUpdate:selectedRowKeys": IxPropTypes.emit(),
  onScroll: IxPropTypes.emit(),
  onScrolledChange: IxPropTypes.emit(),
  onScrolledBottom: IxPropTypes.emit()
};
const tableHeadRowProps = {
  columns: IxPropTypes.array().isRequired
};
const tableHeadCellProps = {
  column: IxPropTypes.object().isRequired
};
const tableBodyRowProps = {
  expanded: IxPropTypes.bool,
  rowIndex: IxPropTypes.number.isRequired,
  level: IxPropTypes.number,
  record: IxPropTypes.any.isRequired,
  rowData: IxPropTypes.object().isRequired,
  rowKey: IxPropTypes.oneOfType([String, Number, Symbol]).isRequired
};
const tableBodyCellProps = {
  column: IxPropTypes.object().isRequired,
  colIndex: IxPropTypes.number.isRequired,
  level: IxPropTypes.number,
  record: IxPropTypes.any.isRequired,
  rowIndex: IxPropTypes.number.isRequired,
  disabled: IxPropTypes.bool,
  expanded: IxPropTypes.bool,
  handleExpend: IxPropTypes.func(),
  selected: IxPropTypes.bool,
  indeterminate: IxPropTypes.bool,
  handleSelect: IxPropTypes.func()
};
const tableMeasureCellProps = {
  cellKey: IxPropTypes.oneOfType([String, Number, Symbol]).isRequired,
  changeColumnWidth: IxPropTypes.func().isRequired
};
const tableFilterableTriggerProps = {
  activeFilterBy: IxPropTypes.array().isRequired,
  filterable: IxPropTypes.object().isRequired,
  onUpdateFilterBy: IxPropTypes.func().isRequired
};
({
  activeFilterBy: IxPropTypes.array().isRequired,
  filterable: IxPropTypes.object().isRequired,
  onUpdateFilterBy: IxPropTypes.func().isRequired
});
function getColTitle(ellipsis, children, title) {
  if (!ellipsis) {
    return void 0;
  }
  let _title = title;
  if (isString(children)) {
    _title = children;
  } else {
    const node = getFirstValidNode(children);
    if (node && isString(node.children)) {
      _title = node.children;
    }
  }
  return _title;
}
var __defProp$2$2 = Object.defineProperty;
var __defProps$2$1 = Object.defineProperties;
var __getOwnPropDescs$2$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$2 = (obj, key, value) => key in obj ? __defProp$2$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2$2.call(b, prop))
      __defNormalProp$2$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2$2)
    for (var prop of __getOwnPropSymbols$2$2(b)) {
      if (__propIsEnum$2$2.call(b, prop))
        __defNormalProp$2$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2$1 = (a, b) => __defProps$2$1(a, __getOwnPropDescs$2$1(b));
var BodyCell = defineComponent({
  props: tableBodyCellProps,
  setup(props) {
    const {
      mergedPrefixCls,
      slots,
      activeSortable,
      fixedColumnKeys,
      columnOffsets,
      isSticky,
      expandable,
      selectable,
      bodyColTag
    } = inject(TABLE_TOKEN);
    const dataValue = useDataValue(props);
    const classes = computed(() => {
      const {
        key,
        fixed,
        align,
        ellipsis
      } = props.column;
      const prefixCls = mergedPrefixCls.value;
      let classes2 = {
        [`${prefixCls}-sorted`]: activeSortable.key === key && !!activeSortable.orderBy,
        [`${prefixCls}-align-${align}`]: !!align,
        [`${prefixCls}-ellipsis`]: !!ellipsis
      };
      if (fixed) {
        const {
          lastStartKey,
          firstEndKey
        } = fixedColumnKeys.value;
        classes2 = __spreadProps$2$1(__spreadValues$2$2({}, classes2), {
          [`${prefixCls}-fix-start`]: fixed === "start",
          [`${prefixCls}-fix-start-last`]: lastStartKey === key,
          [`${prefixCls}-fix-end`]: fixed === "end",
          [`${prefixCls}-fix-end-first`]: firstEndKey === key,
          [`${prefixCls}-fix-sticky`]: isSticky.value
        });
      }
      return normalizeClass(classes2);
    });
    const style = computed(() => {
      const {
        fixed
      } = props.column;
      if (!fixed) {
        return;
      }
      const {
        starts,
        ends
      } = columnOffsets.value;
      const offsets = fixed === "start" ? starts : ends;
      const fixedOffset = convertCssPixel(offsets[props.colIndex]);
      return {
        position: "sticky",
        left: fixed === "start" ? fixedOffset : void 0,
        right: fixed === "end" ? fixedOffset : void 0
      };
    });
    const handleClick = (evt) => {
      evt.stopPropagation();
    };
    return () => {
      const {
        type,
        additional
      } = props.column;
      let children;
      let title;
      if (type === "selectable") {
        children = renderSelectableChildren(props, selectable, handleClick);
      } else {
        const {
          ellipsis
        } = props.column;
        const text = dataValue.value;
        children = renderChildren$2(props, slots, dataValue.value);
        title = getColTitle(ellipsis, children, text);
      }
      const BodyColTag = bodyColTag.value;
      return createVNode(BodyColTag, mergeProps({
        "class": classes.value,
        "style": style.value,
        "title": title
      }, additional), {
        default: () => [type === "expandable" && renderExpandableChildren(props, slots, expandable, mergedPrefixCls.value), children]
      });
    };
  }
});
function useDataValue(props) {
  return computed(() => {
    const {
      column,
      record
    } = props;
    const dataKeys = convertArray(column.dataKey);
    if (dataKeys.length <= 0) {
      return void 0;
    }
    let value = record;
    for (let index = 0; index < dataKeys.length; index++) {
      if (!value) {
        break;
      }
      const key = dataKeys[index];
      value = value[key];
    }
    return value;
  });
}
function renderChildren$2(props, slots, value) {
  const {
    record,
    rowIndex,
    column
  } = props;
  const {
    customRender,
    customCell
  } = column;
  if (process.env.NODE_ENV !== "production" && customRender) {
    Logger.warn("components/table", "`customRender` was deprecated, please use `customCell` instead");
  }
  const cellRender = customRender != null ? customRender : customCell;
  if (isFunction(cellRender)) {
    return cellRender({
      value,
      record,
      rowIndex
    });
  } else if (isString(cellRender) && slots[cellRender]) {
    return slots[cellRender]({
      value,
      record,
      rowIndex
    });
  }
  return value;
}
function renderExpandableChildren(props, slots, expandable, prefixCls) {
  const {
    icon,
    customIcon,
    indent
  } = expandable.value;
  const {
    record,
    expanded,
    level = 0,
    disabled
  } = props;
  const onExpand = props.handleExpend;
  const style = {
    marginLeft: indent ? convertCssPixel(level * indent) : void 0
  };
  let iconNode;
  if (disabled) {
    iconNode = null;
  } else if (isFunction(customIcon)) {
    iconNode = customIcon({
      expanded: !!expanded,
      record
    });
  } else if (isString(customIcon) && slots[customIcon]) {
    iconNode = slots[customIcon]({
      expanded,
      record
    });
  } else {
    iconNode = createVNode(IxIcon, {
      "name": icon,
      "rotate": expanded ? 90 : 0
    }, null);
  }
  return createVNode("button", {
    "class": `${prefixCls}-expandable-trigger`,
    "style": style,
    "onClick": onExpand
  }, [iconNode]);
}
function renderSelectableChildren(props, selectable, onClick) {
  const {
    selected: checked,
    indeterminate,
    disabled,
    handleSelect: onChange
  } = props;
  const {
    multiple
  } = selectable.value;
  if (multiple) {
    const checkboxProps = {
      checked,
      disabled,
      indeterminate,
      onChange,
      onClick
    };
    return createVNode(IxCheckbox, checkboxProps, null);
  } else {
    const radioProps = {
      checked,
      disabled,
      onChange,
      onClick
    };
    return createVNode(IxRadio, radioProps, null);
  }
}
var BodyRowSingle = defineComponent({
  setup(_, {
    slots
  }) {
    const {
      flattedColumns,
      bodyRowTag,
      bodyColTag
    } = inject(TABLE_TOKEN);
    const columnCount = computed(() => flattedColumns.value.length);
    return () => {
      const BodyRowTag = bodyRowTag.value;
      const BodyColTag = bodyColTag.value;
      return createVNode(BodyRowTag, null, {
        default: () => [createVNode(BodyColTag, {
          "colSpan": columnCount.value
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        })]
      });
    };
  }
});
var BodyRow = defineComponent({
  props: tableBodyRowProps,
  setup(props) {
    const {
      props: tableProps2,
      mergedPrefixCls,
      slots,
      flattedColumns,
      expandable,
      handleExpandChange,
      checkExpandDisabled,
      selectable,
      selectedRowKeys,
      indeterminateRowKeys,
      handleSelectChange,
      currentPageRowKeys,
      bodyRowTag
    } = inject(TABLE_TOKEN);
    const {
      expandDisabled,
      handleExpend,
      selectDisabled,
      handleSelect,
      clickEvents
    } = useEvents$1(props, expandable, checkExpandDisabled, handleExpandChange, selectable, handleSelectChange, currentPageRowKeys);
    const isSelected = computed(() => selectedRowKeys.value.includes(props.rowKey));
    const isIndeterminate = computed(() => indeterminateRowKeys.value.includes(props.rowKey));
    const classes = useClasses$2(props, tableProps2, isSelected, mergedPrefixCls);
    return () => {
      const children = renderChildren$1(props, flattedColumns, expandDisabled.value, handleExpend, isSelected, isIndeterminate, selectDisabled, handleSelect);
      const BodyRowTag = bodyRowTag.value;
      const nodes = [createVNode(BodyRowTag, mergeProps({
        "class": classes.value
      }, clickEvents.value), {
        default: () => [children]
      })];
      if (props.expanded) {
        const expandedContext = renderExpandedContext(props, slots, expandable.value);
        expandedContext && nodes.push(expandedContext);
      }
      return nodes;
    };
  }
});
function useClasses$2(props, tableProps2, isSelected, mergedPrefixCls) {
  const rowClassName = computed(() => tableProps2.rowClassName ? tableProps2.rowClassName(props.record, props.rowIndex) : void 0);
  return computed(() => {
    const prefixCls = `${mergedPrefixCls.value}-row`;
    const {
      level,
      expanded
    } = props;
    const computeRowClassName = rowClassName.value;
    return normalizeClass({
      [`${prefixCls}-level-${level}`]: !!level,
      [`${prefixCls}-selected`]: isSelected.value,
      [`${prefixCls}-expanded`]: expanded,
      [computeRowClassName]: !!computeRowClassName
    });
  });
}
function useEvents$1(props, expandable, checkExpandDisabled, handleExpandChange, selectable, handleSelectChange, currentPageRowKeys) {
  const expandDisabled = computed(() => checkExpandDisabled(props.rowData));
  const expendTrigger = computed(() => {
    var _a;
    return (_a = expandable.value) == null ? void 0 : _a.trigger;
  });
  const handleExpend = () => {
    const {
      rowKey,
      record
    } = props;
    handleExpandChange(rowKey, record);
  };
  const selectDisabled = computed(() => currentPageRowKeys.value.disabledRowKeys.includes(props.rowKey));
  const selectTrigger = computed(() => {
    var _a;
    return (_a = selectable.value) == null ? void 0 : _a.trigger;
  });
  const handleSelect = () => {
    const {
      rowKey,
      record
    } = props;
    handleSelectChange(rowKey, record);
  };
  const handleClick = () => {
    if (expendTrigger.value === "click" && !expandDisabled.value) {
      handleExpend();
    }
    if (selectTrigger.value === "click" && !selectDisabled.value) {
      handleSelect();
    }
  };
  const handleDblclick = () => {
    if (expendTrigger.value === "dblclick" && !expandDisabled.value) {
      handleExpend();
    }
    if (selectTrigger.value === "dblclick" && !selectDisabled.value) {
      handleSelect();
    }
  };
  const clickEvents = computed(() => {
    const onClick = expendTrigger.value === "click" || selectTrigger.value === "click" ? handleClick : void 0;
    const onDblclick = expendTrigger.value === "dblclick" || selectTrigger.value === "dblclick" ? handleDblclick : void 0;
    return {
      onClick,
      onDblclick
    };
  });
  return {
    expandDisabled,
    handleExpend,
    selectDisabled,
    handleSelect,
    clickEvents
  };
}
function renderChildren$1(props, flattedColumns, expandDisabled, handleExpend, isSelected, isIndeterminate, selectDisabled, handleSelect) {
  const children = [];
  const {
    rowIndex,
    record,
    level
  } = props;
  flattedColumns.value.forEach((column, colIndex) => {
    const {
      type,
      colSpan: getColSpan,
      rowSpan: getRowSpan,
      key
    } = column;
    const colSpan = getColSpan == null ? void 0 : getColSpan(record, rowIndex);
    const rowSpan = getRowSpan == null ? void 0 : getRowSpan(record, rowIndex);
    if (colSpan === 0 || rowSpan === 0) {
      return;
    }
    const colProps = {
      colSpan: colSpan === 1 ? void 0 : colSpan,
      rowSpan: rowSpan === 1 ? void 0 : rowSpan,
      rowIndex,
      colIndex,
      record,
      column,
      level,
      key
    };
    if (type === "expandable") {
      colProps.expanded = props.expanded;
      colProps.disabled = expandDisabled;
      colProps.handleExpend = handleExpend;
    } else if (type === "selectable") {
      colProps.selected = isSelected.value;
      colProps.indeterminate = isIndeterminate.value;
      colProps.disabled = selectDisabled.value;
      colProps.handleSelect = handleSelect;
    }
    children.push(createVNode(BodyCell, colProps, null));
  });
  return children;
}
function renderExpandedContext(props, slots, expandable) {
  const {
    customExpand
  } = expandable || {};
  const {
    record,
    rowIndex
  } = props;
  let expandedContext;
  if (isFunction(customExpand)) {
    expandedContext = customExpand({
      record,
      rowIndex
    });
  } else if (isString(customExpand) && slots[customExpand]) {
    expandedContext = slots[customExpand]({
      record,
      rowIndex
    });
  }
  return expandedContext && createVNode(BodyRowSingle, null, {
    default: () => [expandedContext]
  });
}
var MeasureCell = defineComponent({
  props: tableMeasureCellProps,
  setup(props) {
    const cellRef = ref();
    const handleResize = (evt) => {
      const {
        offsetWidth
      } = evt.target;
      props.changeColumnWidth(props.cellKey, offsetWidth);
    };
    onMounted(() => {
      const element = cellRef.value;
      props.changeColumnWidth(props.cellKey, element.offsetWidth);
      onResize(element, handleResize);
    });
    onBeforeUnmount(() => {
      props.changeColumnWidth(props.cellKey, false);
      offResize(cellRef.value, handleResize);
    });
    return () => createVNode("td", {
      "ref": cellRef,
      "style": {
        padding: 0,
        border: 0,
        height: 0
      }
    }, [createVNode("div", {
      "style": {
        height: 0,
        overflow: "hidden"
      }
    }, [createTextVNode("\xA0")])]);
  }
});
var MeasureRow = defineComponent({
  setup() {
    const {
      mergedPrefixCls,
      flattedColumns
    } = inject(TABLE_TOKEN);
    const {
      changeColumnWidth
    } = inject(tableBodyToken);
    return () => {
      const children = flattedColumns.value.map((column) => {
        const {
          key
        } = column;
        const cellProps = {
          key,
          cellKey: key,
          changeColumnWidth
        };
        return createVNode(MeasureCell, cellProps, null);
      });
      return createVNode("tr", {
        "class": `${mergedPrefixCls.value}-measure-row`,
        "style": {
          fontSize: 0,
          height: 0
        },
        "aria-hidden": true
      }, [children]);
    };
  }
});
var Body = defineComponent({
  setup(_, {
    slots
  }) {
    const {
      props,
      slots: tableSlots,
      flattedData,
      scrollWidth,
      scrollHeight,
      isSticky,
      bodyTag
    } = inject(TABLE_TOKEN);
    const showMeasure = computed(() => scrollWidth.value || scrollHeight.value || isSticky.value);
    return () => {
      const children = [];
      if (tableSlots.alert) {
        children.push(createVNode(BodyRowSingle, null, {
          default: () => [tableSlots.alert()]
        }));
      }
      const data = flattedData.value;
      if (data.length > 0) {
        if (slots.default) {
          children.push(...slots.default());
        } else {
          data.forEach((item, rowIndex) => {
            const {
              expanded,
              level,
              record,
              rowKey
            } = item;
            const rowProps = {
              key: rowKey,
              expanded,
              level,
              record,
              rowData: item,
              rowIndex,
              rowKey
            };
            children.push(createVNode(BodyRow, rowProps, null));
          });
        }
      } else {
        children.push(createVNode(BodyRowSingle, null, {
          default: () => [createVNode(\u0275Empty, {
            "empty": props.empty
          }, tableSlots)]
        }));
      }
      const BodyTag = bodyTag.value;
      return createVNode(BodyTag, null, {
        default: () => [showMeasure.value && createVNode(MeasureRow, null, null), children]
      });
    };
  }
});
var FilterableTrigger = defineComponent({
  props: tableFilterableTriggerProps,
  setup(props) {
    const {
      slots,
      config,
      locale,
      mergedPrefixCls
    } = inject(TABLE_TOKEN);
    const multiple = computed(() => {
      var _a;
      return (_a = props.filterable.multiple) != null ? _a : config.columnBase.filterable.multiple;
    });
    const footer = computed(() => {
      var _a;
      return (_a = props.filterable.footer) != null ? _a : config.columnBase.filterable.footer;
    });
    const initSelectedKeys = props.activeFilterBy;
    const [selectedKeys, setSelectedKeys] = useState$1(() => initSelectedKeys);
    watch(() => props.activeFilterBy, (keys) => setSelectedKeys(keys));
    const [visible, setVisible] = useState$1(false);
    const onUpdateVisible = (value) => {
      setVisible(value);
      if (!value) {
        props.onUpdateFilterBy(selectedKeys.value);
      }
    };
    const handleConfirm = () => {
      setVisible(false);
      props.onUpdateFilterBy(selectedKeys.value);
    };
    const handleReset = () => {
      setSelectedKeys(initSelectedKeys);
    };
    const customLabel = (item) => {
      const prefixCls = `${mergedPrefixCls.value}-filterable-menu-label`;
      const Node = multiple.value ? IxCheckbox : IxRadio;
      return createVNode("span", {
        "class": prefixCls
      }, [createVNode(Node, {
        "checked": item.selected,
        "disabled": item.disabled
      }, null), createVNode("span", {
        "class": `${prefixCls}-content`
      }, [item.label])]);
    };
    const renderOverlay = () => {
      const children = [];
      const {
        customMenu,
        menus
      } = props.filterable;
      if (isFunction(customMenu)) {
        children.push(customMenu());
      } else if (isString(customMenu) && slots[customMenu]) {
        children.push(slots[customMenu]());
      } else {
        children.push(renderMenu(menus, multiple, selectedKeys, setSelectedKeys, customLabel));
      }
      if (footer.value) {
        children.push(renderFooter$1(locale, mergedPrefixCls, handleConfirm, handleReset));
      }
      return children;
    };
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-filterable-trigger`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-active`]: props.activeFilterBy.length > 0
      });
    });
    const renderTrigger2 = () => {
      const {
        customTrigger
      } = props.filterable;
      if (isFunction(customTrigger)) {
        return customTrigger();
      }
      if (isString(customTrigger) && slots[customTrigger]) {
        return slots[customTrigger]();
      }
      return createVNode("span", {
        "class": classes.value,
        "onClick": (evt) => evt.stopPropagation()
      }, [createVNode(IxIcon, {
        "name": "filter-filled"
      }, null)]);
    };
    return () => {
      const dropdownProps = {
        visible: visible.value,
        hideOnClick: !footer.value,
        placement: "bottomEnd",
        trigger: "click",
        "onUpdate:visible": onUpdateVisible
      };
      return createVNode(IxDropdown, dropdownProps, {
        default: renderTrigger2,
        overlay: renderOverlay
      });
    };
  }
});
const renderMenu = (menus, multiple, selectedKeys, setSelectedKeys, customLabel) => {
  const menuProps = {
    dataSource: menus,
    multiple: multiple.value,
    selectable: true,
    selectedKeys: selectedKeys.value,
    "onUpdate:selectedKeys": setSelectedKeys
  };
  const slots = {
    itemLabel: customLabel
  };
  return createVNode(IxMenu, menuProps, slots);
};
const renderFooter$1 = (locale, mergedPrefixCls, handleConfirm, handleReset) => {
  const {
    filterConfirm,
    filterReset
  } = locale.value;
  return createVNode("div", {
    "class": `${mergedPrefixCls.value}-filterable-trigger-footer`
  }, [createVNode(IxButton, {
    "mode": "primary",
    "size": "sm",
    "onClick": handleConfirm
  }, {
    default: () => [filterConfirm]
  }), createVNode(IxButton, {
    "size": "sm",
    "onClick": handleReset
  }, {
    default: () => [filterReset]
  })]);
};
var SelectableTrigger = defineComponent({
  setup() {
    const {
      mergedPrefixCls,
      paginatedMap,
      selectable,
      currentPageRowKeys,
      currentPageAllSelected,
      currentPageSomeSelected,
      handleHeadSelectChange,
      mergedSelectableMenus,
      handleSelectableMenuClick
    } = inject(TABLE_TOKEN);
    const disabled = computed(() => {
      const dataCount = paginatedMap.value.size;
      return dataCount === 0 || dataCount === currentPageRowKeys.value.disabledRowKeys.length;
    });
    const [visible, setVisible] = useState$1(false);
    const dropdownProps = {
      "onUpdate:visible": setVisible,
      trigger: "click"
    };
    const renderOverlay = () => createVNode(IxMenu, {
      "dataSource": mergedSelectableMenus.value,
      "onClick": handleSelectableMenuClick
    }, null);
    const renderTrigger2 = () => createVNode(IxIcon, {
      "class": `${mergedPrefixCls.value}-selectable-trigger`,
      "name": "down",
      "rotate": visible.value ? 180 : 0
    }, null);
    const renderDropDown = () => {
      if (mergedSelectableMenus.value.length === 0) {
        return;
      }
      return createVNode(IxDropdown, dropdownProps, {
        default: renderTrigger2,
        overlay: renderOverlay
      });
    };
    return () => {
      const {
        multiple
      } = selectable.value;
      if (!multiple) {
        return;
      }
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-selectable`
      }, [createVNode(IxCheckbox, {
        "checked": currentPageAllSelected.value,
        "indeterminate": currentPageSomeSelected.value,
        "disabled": disabled.value,
        "onChange": handleHeadSelectChange
      }, null), renderDropDown()]);
    };
  }
});
var SortableTrigger = defineComponent({
  props: ["activeOrderBy", "sortable"],
  setup(props) {
    const {
      locale,
      mergedPrefixCls
    } = inject(TABLE_TOKEN);
    return () => {
      const {
        activeOrderBy,
        sortable
      } = props;
      const {
        orders,
        nextTooltip
      } = sortable;
      const title = nextTooltip && getNextTooltipTitle(locale.value, orders, activeOrderBy);
      const sortableTriggerNode = renderSortTrigger(mergedPrefixCls, orders, activeOrderBy);
      return title ? createVNode(IxTooltip, {
        "title": title
      }, {
        default: () => [sortableTriggerNode]
      }) : sortableTriggerNode;
    };
  }
});
function getNextTooltipTitle(locale, orders, activeOrderBy) {
  const nextOrderBy = activeOrderBy ? orders[orders.indexOf(activeOrderBy) + 1] : orders[0];
  const {
    sortCancel,
    sortAsc,
    sortDesc
  } = locale;
  if (!nextOrderBy) {
    return sortCancel;
  }
  return nextOrderBy === "ascend" ? sortAsc : sortDesc;
}
function renderSortTrigger(mergedPrefixCls, orders, activeOrderBy) {
  const prefixCls = mergedPrefixCls.value;
  const activeClassName = `${prefixCls}-sortable-trigger-active`;
  const upNode = orders.includes("ascend") && createVNode(IxIcon, {
    "name": "caret-up-filled",
    "class": activeOrderBy === "ascend" ? activeClassName : void 0
  }, null);
  const downNode = orders.includes("descend") && createVNode(IxIcon, {
    "name": "caret-down-filled",
    "class": activeOrderBy === "descend" ? activeClassName : void 0
  }, null);
  return createVNode("span", {
    "class": `${prefixCls}-sortable-trigger`
  }, [upNode, downNode]);
}
var __defProp$1$2 = Object.defineProperty;
var __defProps$1$1 = Object.defineProperties;
var __getOwnPropDescs$1$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$2 = (obj, key, value) => key in obj ? __defProp$1$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$4.call(b, prop))
      __defNormalProp$1$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$4)
    for (var prop of __getOwnPropSymbols$1$4(b)) {
      if (__propIsEnum$1$4.call(b, prop))
        __defNormalProp$1$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$1 = (a, b) => __defProps$1$1(a, __getOwnPropDescs$1$1(b));
var HeadCell = defineComponent({
  props: tableHeadCellProps,
  setup(props) {
    const {
      mergedPrefixCls,
      slots,
      fixedColumnKeys,
      columnOffsetsWithScrollBar,
      isSticky,
      handleSort,
      headColTag,
      activeSortable,
      filterByMap,
      setFilterBy
    } = inject(TABLE_TOKEN);
    const classes = computed(() => {
      const {
        type,
        align,
        hasChildren,
        fixed,
        key,
        sortable,
        filterable
      } = props.column;
      const prefixCls = mergedPrefixCls.value;
      let classes2 = {
        [`${prefixCls}-cell-${type}`]: !!type,
        [`${prefixCls}-cell-sortable`]: !!sortable,
        [`${prefixCls}-cell-filterable`]: !!filterable,
        [`${prefixCls}-align-${align}`]: !hasChildren && !!align,
        [`${prefixCls}-align-center`]: hasChildren
      };
      if (fixed) {
        const {
          lastStartKey,
          firstEndKey
        } = fixedColumnKeys.value;
        classes2 = __spreadProps$1$1(__spreadValues$1$2({}, classes2), {
          [`${prefixCls}-fix-start`]: fixed === "start",
          [`${prefixCls}-fix-start-last`]: lastStartKey === key,
          [`${prefixCls}-fix-end`]: fixed === "end",
          [`${prefixCls}-fix-end-first`]: firstEndKey === key,
          [`${prefixCls}-fix-sticky`]: isSticky.value
        });
      }
      return normalizeClass(classes2);
    });
    const style = computed(() => {
      const {
        fixed,
        colStart,
        colEnd
      } = props.column;
      if (!fixed) {
        return;
      }
      const {
        starts,
        ends
      } = columnOffsetsWithScrollBar.value;
      const offsets = fixed === "start" ? starts : ends;
      const offsetIndex = fixed === "start" ? colStart : colEnd;
      const fixedOffset = convertCssPixel(offsets[offsetIndex]);
      return {
        position: "sticky",
        left: fixed === "start" ? fixedOffset : void 0,
        right: fixed === "end" ? fixedOffset : void 0
      };
    });
    const activeSortOrderBy = computed(() => activeSortable.key === props.column.key && !!activeSortable.orderBy ? activeSortable.orderBy : void 0);
    const activeFilterBy = computed(() => filterByMap[props.column.key]);
    const onUpdateFilterBy = (filterBy) => {
      const {
        key,
        filterable
      } = props.column;
      setFilterBy(key, filterBy);
      callEmit(filterable == null ? void 0 : filterable.onChange, filterBy);
    };
    const onClick = () => {
      const {
        key,
        sortable
      } = props.column;
      if (sortable) {
        handleSort(key, sortable);
      }
    };
    return () => {
      const {
        type,
        additional,
        titleColSpan,
        titleRowSpan
      } = props.column;
      const prefixCls = mergedPrefixCls.value;
      let _title;
      let children;
      if (type === "scroll-bar") {
        children = void 0;
      } else if (type === "selectable") {
        children = createVNode(SelectableTrigger, null, null);
      } else {
        const {
          title,
          customTitle,
          ellipsis,
          sortable,
          filterable
        } = props.column;
        children = renderChildren(title, customTitle, slots);
        _title = getColTitle(ellipsis, children, title);
        const iconTriggers = renderTrigger(sortable, activeSortOrderBy, filterable, activeFilterBy, onUpdateFilterBy);
        if (iconTriggers.length > 0) {
          children = createVNode("span", {
            "class": `${prefixCls}-cell-triggers`
          }, [createVNode("span", {
            "class": `${prefixCls}-cell-title`
          }, [children]), iconTriggers]);
        } else if (ellipsis) {
          children = createVNode("span", {
            "class": `${prefixCls}-cell-title`
          }, [children]);
        }
      }
      const HeadColTag = headColTag.value;
      return createVNode(HeadColTag, mergeProps({
        "class": classes.value,
        "style": style.value,
        "colSpan": titleColSpan === 1 ? void 0 : titleColSpan,
        "rowSpan": titleRowSpan === 1 ? void 0 : titleRowSpan,
        "title": _title
      }, additional, {
        "onClick": onClick
      }), {
        default: () => [children]
      });
    };
  }
});
function renderChildren(title, customTitle, slots) {
  let children = title;
  if (isFunction(customTitle)) {
    children = customTitle({
      title
    });
  } else if (isString(customTitle) && slots[customTitle]) {
    children = slots[customTitle]({
      title
    });
  }
  return children;
}
function renderTrigger(sortable, activeSortOrderBy, filterable, activeFilterBy, onUpdateFilterBy) {
  const children = [];
  sortable && children.push(createVNode(SortableTrigger, {
    "activeOrderBy": activeSortOrderBy.value,
    "sortable": sortable
  }, null));
  if (filterable) {
    children.push(createVNode(FilterableTrigger, {
      "activeFilterBy": activeFilterBy.value,
      "filterable": filterable,
      "onUpdateFilterBy": onUpdateFilterBy
    }, null));
  }
  return children;
}
var HeadRow = defineComponent({
  props: tableHeadRowProps,
  setup(props) {
    const {
      headRowTag
    } = inject(TABLE_TOKEN);
    return () => {
      const children = props.columns.filter((column) => column.titleColSpan !== 0).map((column) => createVNode(HeadCell, {
        "key": column.key,
        "column": column
      }, null));
      const HeadRowTag = headRowTag.value;
      return createVNode(HeadRowTag, null, {
        default: () => [children]
      });
    };
  }
});
var Head = defineComponent({
  setup() {
    const {
      mergedRows,
      headTag
    } = inject(TABLE_TOKEN);
    return () => {
      const children = mergedRows.value.map((columns, rowIndex) => createVNode(HeadRow, {
        "key": rowIndex,
        "columns": columns
      }, null));
      const HeadTag = headTag.value;
      return createVNode(HeadTag, null, {
        default: () => [children]
      });
    };
  }
});
defineComponent({
  setup() {
    return () => {
      return createVNode("tfoot", null, null);
    };
  }
});
var MainTable = defineComponent({
  setup() {
    const {
      props,
      mergedPrefixCls,
      changeColumnWidth,
      flattedData,
      isSticky,
      scrollBodyRef,
      handleScroll,
      pingedStart,
      pingedEnd,
      scrollWidth,
      scrollHeight,
      hasFixed,
      tableLayout,
      tableTag
    } = inject(TABLE_TOKEN);
    const mainTableRef = ref();
    const mainTableWidth = ref(0);
    const _changeColumnWidth = (key, width) => {
      if (isVisibleElement(mainTableRef.value)) {
        changeColumnWidth(key, width);
      }
    };
    provide(tableBodyToken, {
      mainTableWidth,
      changeColumnWidth: _changeColumnWidth
    });
    const triggerScroll = () => {
      const currentTarget = convertElement(scrollBodyRef);
      if (currentTarget) {
        handleScroll({
          currentTarget
        });
      }
    };
    const handleWrapperResize = (evt) => {
      const {
        offsetWidth
      } = evt.target;
      if (offsetWidth !== mainTableWidth.value) {
        triggerScroll();
        mainTableWidth.value = offsetWidth;
      }
    };
    onMounted(() => {
      triggerScroll();
      watch([() => props.dataSource, scrollWidth], ([, width]) => {
        if (width) {
          triggerScroll();
        }
      });
      watchEffect(() => {
        const element = mainTableRef.value;
        if (scrollWidth.value) {
          onResize(element, handleWrapperResize);
        } else {
          offResize(element, handleWrapperResize);
        }
      });
    });
    onBeforeUnmount(() => offResize(mainTableRef.value, handleWrapperResize));
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-container`]: true,
        [`${prefixCls}-ping-start`]: pingedStart.value,
        [`${prefixCls}-ping-end`]: pingedEnd.value,
        [`${prefixCls}-fixed-layout`]: tableLayout.value === "fixed",
        [`${prefixCls}-fixed-column`]: hasFixed.value,
        [`${prefixCls}-scroll-horizontal`]: scrollWidth.value,
        [`${prefixCls}-scroll-vertical`]: scrollHeight.value
      });
    });
    const contentStyle = computed(() => {
      var _a;
      const width = scrollWidth.value;
      const height = scrollHeight.value;
      const overflowX = width ? "auto" : void 0;
      const overflowY = props.virtual ? "hidden" : height ? "scroll" : width ? "hidden" : void 0;
      const fullHeight = (_a = props.scroll) == null ? void 0 : _a.fullHeight;
      return {
        overflowX,
        overflowY,
        [fullHeight ? "height" : "maxHeight"]: height
      };
    });
    const tableStyle = computed(() => {
      return {
        tableLayout: tableLayout.value,
        width: scrollWidth.value,
        minWidth: scrollWidth.value ? "100%" : void 0
      };
    });
    const handleScrolledChange = (startIndex, endIndex, visibleData) => {
      callEmit(props.onScrolledChange, startIndex, endIndex, visibleData.map((item) => item.record));
    };
    return () => {
      const TableTag = tableTag.value;
      let children;
      const prefixCls = mergedPrefixCls.value;
      if (scrollHeight.value || isSticky.value) {
        const tableHead = !props.headless && createVNode(FixedHolder, null, {
          default: () => [createVNode(Head, null, null)]
        });
        let tableBody;
        if (props.virtual && props.scroll) {
          const itemRender = ({
            item,
            index
          }) => {
            const {
              expanded,
              level,
              record,
              rowKey
            } = item;
            const rowProps = {
              key: rowKey,
              expanded,
              level,
              record,
              rowData: item,
              rowIndex: index,
              rowKey
            };
            return createVNode(BodyRow, rowProps, null);
          };
          const contentRender = (children2) => {
            return createVNode(TableTag, {
              "style": tableStyle.value
            }, {
              default: () => [createVNode(ColGroup, null, null), createVNode(Body, null, {
                default: () => [children2]
              }), false]
            });
          };
          const {
            scroll,
            onScrolledBottom
          } = props;
          const {
            height,
            y,
            fullHeight
          } = scroll;
          process.env.NODE_ENV !== "production" && !isNumber(height || y) && Logger.warn("components/table", "scroll.y must is a valid number when enable virtual scroll");
          tableBody = createVNode(CdkVirtualScroll, {
            "ref": scrollBodyRef,
            "style": contentStyle.value,
            "dataSource": flattedData.value,
            "fullHeight": fullHeight,
            "height": height || y,
            "itemHeight": 44,
            "itemKey": "rowKey",
            "itemRender": itemRender,
            "contentRender": contentRender,
            "virtual": true,
            "onScroll": handleScroll,
            "onScrolledBottom": onScrolledBottom,
            "onScrolledChange": handleScrolledChange
          }, null);
        } else {
          tableBody = createVNode("div", {
            "ref": scrollBodyRef,
            "class": `${prefixCls}-content`,
            "style": contentStyle.value,
            "onScroll": handleScroll
          }, [createVNode(TableTag, {
            "style": tableStyle.value
          }, {
            default: () => [createVNode(ColGroup, null, null), createVNode(Body, null, null), false]
          })]);
        }
        const sticky = isSticky.value ? createVNode(StickyScroll, null, null) : null;
        children = [tableHead, tableBody, sticky];
      } else {
        children = createVNode("div", {
          "ref": scrollBodyRef,
          "class": `${prefixCls}-content`,
          "style": contentStyle.value,
          "onScroll": handleScroll
        }, [createVNode(TableTag, {
          "style": tableStyle.value
        }, {
          default: () => [createVNode(ColGroup, null, null), !props.headless && createVNode(Head, null, null), createVNode(Body, null, null), false]
        })]);
      }
      return createVNode("div", {
        "ref": mainTableRef,
        "class": classes.value
      }, [children]);
    };
  }
});
function renderFooter(slots, prefixCls) {
  if (!slots.footer) {
    return null;
  }
  return createVNode("div", {
    "class": `${prefixCls}-footer`
  }, [slots.footer()]);
}
function renderPagination(mergedPagination, filteredData, prefixCls) {
  let top = null;
  let bottom = null;
  if (mergedPagination !== null) {
    const {
      position
    } = mergedPagination;
    const [vertical, horizontal] = kebabCase$1(position).split("-");
    const className = `${prefixCls}-pagination ${prefixCls}-pagination-${horizontal}`;
    const node = createVNode(IxPagination, mergeProps({
      "class": className,
      "total": filteredData.length
    }, mergedPagination), null);
    top = vertical === "top" ? node : null;
    bottom = vertical === "bottom" ? node : null;
  }
  return [top, bottom];
}
var __defProp$9 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
var Table = defineComponent({
  name: "IxTable",
  props: tableProps,
  setup(props, {
    expose,
    slots
  }) {
    const config = useGlobalConfig$1("table");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-table`);
    const locale = getLocale("table");
    const tags = useTags(props);
    const getRowKey = useGetRowKey(props, config);
    const stickyContext = useSticky(props);
    const scrollContext = useScroll(props, stickyContext);
    const columnsContext = useColumns(props, slots, config, scrollContext.scrollBarSizeOnFixedHolder);
    const sortableContext = useSortable(columnsContext.flattedColumns);
    const filterableContext = useFilterable(columnsContext.flattedColumns);
    const expandableContext = useExpandable$1(props, columnsContext.flattedColumns);
    const tableLayout = useTableLayout(props, columnsContext, scrollContext, stickyContext.isSticky);
    const {
      mergedPagination
    } = usePagination(props, config);
    const dataContext = useDataSource(props, getRowKey, sortableContext.activeSortable, filterableContext.activeFilters, expandableContext.expandedRowKeys, mergedPagination);
    const selectableContext = useSelectable$1(props, locale, columnsContext.flattedColumns, dataContext);
    const context = __spreadValues$9(__spreadValues$9(__spreadValues$9(__spreadProps$6(__spreadValues$9(__spreadValues$9(__spreadValues$9(__spreadValues$9(__spreadValues$9(__spreadProps$6(__spreadValues$9({
      props,
      mergedPrefixCls,
      slots,
      config,
      locale
    }, tags), {
      getRowKey
    }), columnsContext), scrollContext), sortableContext), filterableContext), stickyContext), {
      tableLayout,
      mergedPagination
    }), expandableContext), dataContext), selectableContext);
    provide(TABLE_TOKEN, context);
    expose({
      scrollTo: scrollContext.scrollTo
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const {
        borderless = config.borderless,
        size = config.size
      } = props;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-borderless`]: borderless,
        [`${prefixCls}-${size}`]: true
      });
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      const header = createVNode(\u0275Header, {
        "header": props.header
      }, slots);
      const footer = renderFooter(slots, prefixCls);
      const [paginationTop, paginationBottom] = renderPagination(mergedPagination.value, dataContext.filteredData.value, prefixCls);
      const children = [header, paginationTop, createVNode(MainTable, null, null), paginationBottom, footer];
      const spinProps = covertSpinProps(props.spin);
      const spinWrapper = spinProps ? createVNode(IxSpin, spinProps, {
        default: () => [children]
      }) : children;
      return createVNode("div", {
        "class": classes.value
      }, [spinWrapper]);
    };
  }
});
function covertSpinProps(spin) {
  return isBoolean(spin) ? {
    spinning: spin
  } : spin;
}
const IxTable = Table;
const IxTableColumn = TableColumn;

const tabsToken = Symbol("tabsToken");
const tabsProps = {
  selectedKey: IxPropTypes.oneOfType([String, Number]),
  type: IxPropTypes.oneOf(["card", "line", "segment"]).def("card"),
  forceRender: IxPropTypes.bool.def(false),
  placement: IxPropTypes.oneOf(["top", "bottom", "start", "end"]).def("top"),
  mode: IxPropTypes.oneOf(["default", "primary"]).def("default"),
  "onUpdate:selectedKey": IxPropTypes.emit(),
  onTabClick: IxPropTypes.emit(),
  onPreClick: IxPropTypes.emit(),
  onNextClick: IxPropTypes.emit()
};
const tabProps = {
  title: IxPropTypes.string,
  forceRender: IxPropTypes.bool,
  disabled: IxPropTypes.bool.def(false)
};
const tabNavProps = {
  title: IxPropTypes.string,
  disabled: IxPropTypes.bool
};
var Tab = defineComponent({
  __IDUX_TAB: true,
  name: "IxTab",
  props: tabProps,
  setup(props, {
    slots
  }) {
    const {
      mergedPrefixCls
    } = inject(tabsToken);
    return () => {
      var _a;
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-pane`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var TabNav = defineComponent({
  name: "IxTabNav",
  props: tabNavProps,
  setup(props, {
    slots
  }) {
    const key = useKey();
    const {
      selectedKey,
      selectedElRef,
      mergedPrefixCls,
      handleTabClick
    } = inject(tabsToken);
    const selfElRef = ref(null);
    const isSelected = computed(() => selectedKey.value === key);
    const prefixCls = computed(() => `${mergedPrefixCls.value}-nav`);
    const classes = computed(() => {
      return normalizeClass({
        [`${prefixCls.value}-tab`]: true,
        [`${prefixCls.value}-tab-selected`]: isSelected.value,
        [`${prefixCls.value}-tab-disabled`]: props.disabled
      });
    });
    watchEffect(() => {
      if (isSelected.value && selfElRef.value) {
        selectedElRef.value = selfElRef.value;
      }
    });
    const onClick = (evt) => {
      if (!props.disabled) {
        handleTabClick(key, evt);
      }
    };
    return () => {
      var _a, _b;
      const tab = createVNode("span", {
        "class": `${prefixCls.value}-tab-label`
      }, [createTextVNode(" "), (_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : props.title]);
      return createVNode("div", {
        "class": classes.value,
        "onClick": onClick,
        "ref": selfElRef
      }, [tab]);
    };
  }
});
function useSelectedElOffset(isHorizontal, selectedElRef) {
  const selectedElOffset = computed(() => {
    var _a, _b, _c, _d;
    if (isHorizontal.value) {
      return (_b = (_a = selectedElRef.value) == null ? void 0 : _a.offsetLeft) != null ? _b : 0;
    } else {
      return (_d = (_c = selectedElRef.value) == null ? void 0 : _c.offsetTop) != null ? _d : 0;
    }
  });
  return {
    selectedElOffset
  };
}
function useNavRelatedElSize(isHorizontal, navWrapperElRef, navElRef, navPreElRef, selectedElRef) {
  const navWrapperWidth = ref(0);
  const navWidth = ref(0);
  const navWrapperHeight = ref(0);
  const navHeight = ref(0);
  const navPreNextWidth = ref(0);
  const navPreNextHeight = ref(0);
  const navSize = computed(() => isHorizontal.value ? navWidth.value : navHeight.value);
  const navWrapperSize = computed(() => isHorizontal.value ? navWrapperWidth.value : navWrapperHeight.value);
  const navPreNextSize = computed(() => isHorizontal.value ? navPreNextWidth.value : navPreNextHeight.value);
  const selectedElSize = computed(() => {
    var _a, _b, _c, _d;
    if (isHorizontal.value) {
      return (_b = (_a = selectedElRef.value) == null ? void 0 : _a.offsetWidth) != null ? _b : 0;
    } else {
      return (_d = (_c = selectedElRef.value) == null ? void 0 : _c.offsetHeight) != null ? _d : 0;
    }
  });
  const syncNavRelatedElSize = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    navPreNextWidth.value = (_b = (_a = navPreElRef.value) == null ? void 0 : _a.$el.offsetWidth) != null ? _b : 0;
    navPreNextHeight.value = (_d = (_c = navPreElRef.value) == null ? void 0 : _c.$el.offsetHeight) != null ? _d : 0;
    navWrapperWidth.value = ((_f = (_e = navWrapperElRef.value) == null ? void 0 : _e.offsetWidth) != null ? _f : 0) - navPreNextSize.value * 2;
    navWidth.value = (_h = (_g = navElRef.value) == null ? void 0 : _g.offsetWidth) != null ? _h : 0;
    navWrapperHeight.value = ((_j = (_i = navWrapperElRef.value) == null ? void 0 : _i.offsetHeight) != null ? _j : 0) - navPreNextSize.value * 2;
    navHeight.value = (_l = (_k = navElRef.value) == null ? void 0 : _k.offsetHeight) != null ? _l : 0;
  };
  return {
    navSize,
    navWrapperSize,
    navPreNextSize,
    selectedElSize,
    syncNavRelatedElSize
  };
}
function useVisibleSize(navWrapperSize, selectedElOffset, navOffset) {
  return computed(() => {
    return navWrapperSize.value - (selectedElOffset.value - navOffset.value);
  });
}
var Tabs = defineComponent({
  name: "IxTabs",
  props: tabsProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-tabs`);
    const navWrapperElRef = ref(null);
    const navElRef = ref(null);
    const navBarElRef = ref(null);
    const navPreElRef = ref(null);
    const selectedElRef = ref(null);
    const [selectedKey, setSelectedKey] = useControlledProp(props, "selectedKey");
    const isLineType = computed(() => props.type === "line");
    const isSegmentType = computed(() => props.type === "segment");
    const horizontalPlacement = ["top", "bottom"];
    const isHorizontal = computed(() => horizontalPlacement.includes(props.placement));
    const {
      navSize,
      navWrapperSize,
      navPreNextSize,
      selectedElSize,
      syncNavRelatedElSize
    } = useNavRelatedElSize(isHorizontal, navWrapperElRef, navElRef, navPreElRef, selectedElRef);
    const navOffset = ref(0);
    const {
      selectedElOffset
    } = useSelectedElOffset(isHorizontal, selectedElRef);
    const visibleSize = useVisibleSize(navWrapperSize, selectedElOffset, navOffset);
    const hasScroll = computed(() => navSize.value > navWrapperSize.value);
    const updateNavOffset = () => {
      if (visibleSize.value < selectedElSize.value) {
        navOffset.value += selectedElSize.value - visibleSize.value;
      } else if (visibleSize.value / navWrapperSize.value > 1) {
        navOffset.value -= visibleSize.value % navWrapperSize.value;
      }
    };
    const preReached = ref(false);
    const nextReached = ref(false);
    const classes = computed(() => {
      const {
        type,
        placement,
        mode
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${type}`]: true,
        [`${prefixCls}-nav-${placement}`]: placement === "top" || type === "line",
        [`${prefixCls}-nav-${mode}`]: type === "segment"
      });
    });
    const curryNavPreNextClasses = curry(useNavPreNextClasses)(props, mergedPrefixCls);
    const navPreClasses = curryNavPreNextClasses("pre", preReached);
    const navNextClasses = curryNavPreNextClasses("next", nextReached);
    const handleTabClick = (key, evt) => {
      callEmit(props.onTabClick, key, evt);
      setSelectedKey(key);
    };
    const updateNavBarStyle = () => {
      var _a;
      if (isLineType.value && navBarElRef.value) {
        const isBarDisabled = (_a = selectedElRef.value) == null ? void 0 : _a.classList.contains(`${mergedPrefixCls.value}-nav-tab-disabled`);
        const barDisabledClassName = `${mergedPrefixCls.value}-nav-bar-disabled`;
        const barOffset = selectedElOffset.value - navOffset.value + navPreNextSize.value + "px";
        const barSize = selectedElSize.value + "px";
        if (isHorizontal.value) {
          navBarElRef.value.style.left = barOffset;
          navBarElRef.value.style.width = barSize;
          navBarElRef.value.style.top = "";
          navBarElRef.value.style.height = "";
        } else {
          navBarElRef.value.style.top = barOffset;
          navBarElRef.value.style.height = barSize;
          navBarElRef.value.style.left = "";
          navBarElRef.value.style.width = "";
        }
        if (isBarDisabled) {
          addClass(navBarElRef.value, barDisabledClassName);
        } else {
          removeClass(navBarElRef.value, barDisabledClassName);
        }
      }
    };
    const handlePreClick = (evt) => {
      if (!preReached.value) {
        callEmit(props.onPreClick, evt);
        const offset = navOffset.value < navWrapperSize.value ? 0 : navOffset.value - navWrapperSize.value;
        navOffset.value = offset;
      }
    };
    const handleNextClick = (evt) => {
      if (!nextReached.value) {
        callEmit(props.onNextClick, evt);
        const _offset = navOffset.value + navWrapperSize.value;
        let offset;
        if (navSize.value - _offset < navWrapperSize.value) {
          offset = navSize.value - navWrapperSize.value;
        } else {
          offset = _offset;
        }
        navOffset.value = offset;
      }
    };
    const judgePreNextStatus = () => {
      preReached.value = navOffset.value === 0;
      nextReached.value = navSize.value - navOffset.value <= navWrapperSize.value;
    };
    watch(navOffset, (val) => {
      if (navElRef.value) {
        navElRef.value.style.transform = `translate${isHorizontal.value ? "X" : "Y"}(-${val}px)`;
        judgePreNextStatus();
        updateNavBarStyle();
      }
    });
    watch(selectedElRef, () => {
      if (hasScroll.value) {
        updateNavOffset();
      }
      updateNavBarStyle();
    });
    const onTabsResize = throttle(() => {
      syncNavRelatedElSize();
      if (hasScroll.value) {
        nextTick(() => {
          syncNavRelatedElSize();
          updateNavOffset();
          updateNavBarStyle();
          judgePreNextStatus();
        });
      } else {
        updateNavBarStyle();
      }
    }, 10);
    onMounted(() => {
      onResize(navWrapperElRef.value, onTabsResize);
    });
    onBeforeUnmount(() => {
      offResize(navWrapperElRef.value, onTabsResize);
    });
    provide(tabsToken, {
      selectedKey,
      selectedElRef,
      mergedPrefixCls,
      handleTabClick
    });
    return () => {
      var _a;
      const tabVNodes = flattenTabVNodes((_a = slots.default) == null ? void 0 : _a.call(slots));
      return createVNode("div", {
        "class": classes.value
      }, [createVNode("div", {
        "class": `${mergedPrefixCls.value}-nav-wrapper ${hasScroll.value ? `${mergedPrefixCls.value}-nav-wrapper-has-scroll` : ""}`,
        "ref": navWrapperElRef
      }, [hasScroll.value && createVNode(IxIcon, {
        "class": navPreClasses.value,
        "name": isHorizontal.value ? "left" : "up",
        "onClick": handlePreClick,
        "ref": navPreElRef
      }, null), createVNode("div", {
        "class": `${mergedPrefixCls.value}-nav`,
        "ref": navElRef
      }, [
        tabVNodes.map((vnode) => {
          var _a2;
          return createVNode(TabNav, vnode.props, {
            title: (_a2 = vnode.children) == null ? void 0 : _a2.title
          });
        })
      ]), hasScroll.value && createVNode(IxIcon, {
        "class": navNextClasses.value,
        "name": isHorizontal.value ? "right" : "down",
        "onClick": handleNextClick
      }, null), !isSegmentType.value && createVNode("div", {
        "class": `${mergedPrefixCls.value}-nav-border`
      }, null), isLineType.value && createVNode("div", {
        "class": `${mergedPrefixCls.value}-nav-bar`,
        "ref": navBarElRef
      }, null)]), createVNode("div", {
        "class": `${mergedPrefixCls.value}-pane-wrapper`
      }, [filterTabVNodes(props, tabVNodes, selectedKey)])]);
    };
  }
});
function useNavPreNextClasses(props, mergedPrefixCls, type, disabled) {
  return computed(() => {
    const {
      placement
    } = props;
    const prefixCls = mergedPrefixCls.value;
    return normalizeClass({
      [`${prefixCls}-nav-${type}`]: true,
      [`${prefixCls}-nav-${type}-disabled`]: disabled.value,
      [`${prefixCls}-nav-${type}-${placement}`]: true
    });
  });
}
function flattenTabVNodes(tabVNodes) {
  return flattenNode(tabVNodes, {
    key: "__IDUX_TAB"
  });
}
function filterTabVNodes(props, tabVNodes, selectedKey) {
  const renderTabVNodes = [];
  tabVNodes.forEach((vNode) => {
    const {
      key
    } = vNode;
    const {
      forceRender
    } = vNode.props;
    const useVShow = forceRender != null ? forceRender : props.forceRender;
    const show = selectedKey.value === key;
    if (vNode.key !== void 0) {
      vNode.key = key;
    }
    if (useVShow) {
      renderTabVNodes.push(withDirectives(vNode, [[vShow, show]]));
    } else if (show) {
      renderTabVNodes.push(vNode);
    }
  });
  return renderTabVNodes;
}
const IxTabs = Tabs;
const IxTab = Tab;

const tagProps = {
  color: IxPropTypes.string,
  icon: IxPropTypes.string,
  number: IxPropTypes.number,
  shape: IxPropTypes.oneOf(["round", "rect"])
};
var Tag = defineComponent({
  name: "IxTag",
  props: tagProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-tag`);
    const config = useGlobalConfig$1("tag");
    const isPresetOrStatusColor = computed(() => {
      const color = props.color;
      if (!color) {
        return false;
      }
      return isPresetColor(color) || isStatusColor(color);
    });
    const classes = computed(() => {
      const {
        shape = config.shape,
        color,
        number
      } = props;
      const prefixCls = mergedPrefixCls.value;
      const isPreset = isPresetOrStatusColor.value;
      const isNumeric = !isNil(number);
      return normalizeClass({
        [`${prefixCls}`]: true,
        [`${prefixCls}-${shape}`]: !isNumeric && shape,
        [`${prefixCls}-${color}`]: isPreset,
        [`${prefixCls}-numeric`]: isNumeric,
        [`${prefixCls}-has-color`]: !isPreset && color
      });
    });
    const style = computed(() => ({
      backgroundColor: isPresetOrStatusColor.value ? void 0 : props.color
    }));
    return () => {
      var _a;
      const prefixCls = mergedPrefixCls.value;
      const {
        icon,
        number
      } = props;
      const icoNode = slots.icon ? slots.icon() : icon && createVNode(IxIcon, {
        "name": icon
      }, null);
      return createVNode("span", {
        "class": classes.value,
        "style": style.value
      }, [renderNumericPrefix(prefixCls, number, style.value), icoNode, createVNode("span", {
        "class": `${prefixCls}-content`
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
function renderNumericPrefix(prefixCls, number, style) {
  if (isNil(number)) {
    return null;
  }
  return createVNode("span", {
    "class": `${prefixCls}-numeric-prefix`,
    "style": style
  }, [number]);
}
const IxTag = Tag;

var __defProp$8 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$3.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$3)
    for (var prop of __getOwnPropSymbols$1$3(b)) {
      if (__propIsEnum$1$3.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const textareaProps = __spreadProps$3(__spreadValues$8({}, commonProps), {
  autoRows: IxPropTypes.oneOfType([Boolean, IxPropTypes.shape({ minRows: Number, maxRows: Number })]),
  computeCount: IxPropTypes.func(),
  maxCount: IxPropTypes.oneOfType([Number, String]),
  resize: IxPropTypes.oneOf(["none", "both", "horizontal", "vertical"]),
  showCount: IxPropTypes.bool
});
const isAutoRowsObject = (value) => {
  return isObject(value) && isNumber(value.minRows) && isNumber(value.maxRows);
};
function useAutoRows(textareaRef, autoRows, accessor) {
  let enabled = false;
  let minRows = null;
  let maxRows = null;
  let previousValue;
  let previousMinRows = null;
  let initialHeight;
  let cachedLineHeight;
  const textareaBoxHeight = 10;
  const measuringClass = isFirefox ? "ix-textarea-autosize-measuring-firefox" : "ix-textarea-autosize-measuring";
  let isDestroyed = false;
  function resizeToFitContent(force = false) {
    if (!enabled) {
      return;
    }
    cacheTextareaLineHeight();
    if (!cachedLineHeight) {
      return;
    }
    const textarea = textareaRef.value;
    const value = textarea.value;
    if (!force && minRows === previousMinRows && value === previousValue) {
      return;
    }
    const placeholderText = textarea.placeholder;
    textarea.classList.add(measuringClass);
    textarea.placeholder = "";
    const height = Math.round((textarea.scrollHeight - textareaBoxHeight) / cachedLineHeight) * cachedLineHeight + textareaBoxHeight;
    textarea.style.height = `${height}px`;
    textarea.classList.remove(measuringClass);
    textarea.placeholder = placeholderText;
    nextTick(() => rAF(() => scrollToCaretPosition(textarea)));
    previousValue = value;
    previousMinRows = minRows;
  }
  function cacheTextareaLineHeight() {
    if (cachedLineHeight) {
      return;
    }
    const textarea = textareaRef.value;
    const textareaClone = textarea.cloneNode(false);
    textareaClone.rows = 1;
    textareaClone.style.position = "absolute";
    textareaClone.style.visibility = "hidden";
    textareaClone.style.border = "none";
    textareaClone.style.padding = "0";
    textareaClone.style.height = "";
    textareaClone.style.minHeight = "";
    textareaClone.style.maxHeight = "";
    textareaClone.style.overflow = "hidden";
    textarea.parentNode.appendChild(textareaClone);
    cachedLineHeight = textareaClone.clientHeight;
    textarea.parentNode.removeChild(textareaClone);
    setMinHeight();
    setMaxHeight();
  }
  function setMinHeight() {
    const minHeight = minRows && cachedLineHeight ? `${minRows * cachedLineHeight + textareaBoxHeight}px` : null;
    if (minHeight) {
      textareaRef.value.style.minHeight = minHeight;
    }
  }
  function setMaxHeight() {
    const maxHeight = maxRows && cachedLineHeight ? `${maxRows * cachedLineHeight + textareaBoxHeight}px` : null;
    if (maxHeight) {
      textareaRef.value.style.maxHeight = maxHeight;
    }
  }
  function scrollToCaretPosition(textarea) {
    const { selectionStart, selectionEnd } = textarea;
    if (!isDestroyed && document.activeElement === textarea) {
      textarea.setSelectionRange(selectionStart, selectionEnd);
    }
  }
  function reset() {
    if (initialHeight !== void 0) {
      textareaRef.value.style.height = initialHeight;
    }
  }
  const onResize = throttle(() => resizeToFitContent(true), 16);
  onMounted(() => {
    initialHeight = textareaRef.value.style.height;
    watchEffect(() => {
      const _autoRows = autoRows.value;
      if (isAutoRowsObject(_autoRows)) {
        enabled = true;
        minRows = _autoRows.minRows;
        maxRows = _autoRows.maxRows;
      } else {
        enabled = _autoRows;
        minRows = null;
        maxRows = null;
      }
      enabled ? resizeToFitContent(true) : reset();
    });
    watch(() => accessor.valueRef.value, () => resizeToFitContent());
    on(window, "resize", onResize);
  });
  onUnmounted(() => {
    off(window, "resize", onResize);
    isDestroyed = true;
  });
}
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Textarea = defineComponent({
  name: "IxTextarea",
  inheritAttrs: false,
  props: textareaProps,
  setup(props, {
    slots,
    expose,
    attrs
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-textarea`);
    const config = useGlobalConfig$1("textarea");
    const {
      elementRef,
      accessor,
      clearable,
      clearIcon,
      clearVisible,
      isFocused,
      focus,
      blur,
      handleInput,
      handleCompositionStart,
      handleCompositionEnd,
      handleFocus,
      handleBlur,
      handleClear,
      syncValue
    } = useInput(props, config);
    expose({
      focus,
      blur
    });
    onMounted(() => {
      syncValue();
    });
    const classes = computed(() => {
      const {
        showCount = config.showCount,
        size = config.size
      } = props;
      const prefixCls = mergedPrefixCls.value;
      const classes2 = {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: accessor.disabled.value,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-with-count`]: showCount,
        [`${prefixCls}-${size}`]: true
      };
      return normalizeClass([classes2, attrs.class]);
    });
    const dataCount = useDataCount(props, config, accessor);
    const autoRows = computed(() => {
      var _a;
      return (_a = props.autoRows) != null ? _a : config.autoRows;
    });
    const resize = computed(() => {
      var _a;
      const resize2 = (_a = props.resize) != null ? _a : config.resize;
      if (autoRows.value) {
        return resize2 === "horizontal" ? "horizontal" : "none";
      } else {
        return resize2;
      }
    });
    const textareaStyle = computed(() => ({
      resize: resize.value
    }));
    useAutoRows(elementRef, autoRows, accessor);
    return () => {
      const _a = attrs, {
        class: className,
        style
      } = _a, rest = __objRest$1(_a, [
        "class",
        "style"
      ]);
      const prefixCls = mergedPrefixCls.value;
      return createVNode("span", {
        "class": classes.value,
        "style": style,
        "data-count": dataCount.value
      }, [createVNode("textarea", mergeProps(rest, {
        "ref": elementRef,
        "class": `${prefixCls}-inner`,
        "style": textareaStyle.value,
        "disabled": accessor.disabled.value,
        "readonly": props.readonly,
        "onInput": handleInput,
        "onCompositionstart": handleCompositionStart,
        "onCompositionend": handleCompositionEnd,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }), null), renderSuffix(clearable.value, slots.clearIcon, clearIcon.value, clearVisible.value, handleClear, prefixCls)]);
    };
  }
});
function useDataCount(props, config, accessor) {
  return computed(() => {
    var _a, _b, _c, _d;
    const showCount = (_a = props.showCount) != null ? _a : config.showCount;
    const computeCount = (_b = props.computeCount) != null ? _b : config.computeCount;
    const maxCount = (_c = props.maxCount) != null ? _c : config.maxCount;
    let dataCount = "";
    if (showCount) {
      const value = (_d = accessor.valueRef.value) != null ? _d : "";
      dataCount = value.length;
      if (computeCount) {
        dataCount = computeCount(value);
      } else if (maxCount) {
        dataCount += " / " + maxCount;
      }
    }
    return dataCount;
  });
}
function renderSuffix(isClearable, clearIconSlot, clearIcon, clearVisible, onClear, prefixCls) {
  var _a;
  if (!isClearable) {
    return null;
  }
  let classes = `${prefixCls}-suffix`;
  if (!clearVisible) {
    classes += ` ${prefixCls}-suffix-hidden`;
  }
  const children = (_a = clearIconSlot == null ? void 0 : clearIconSlot({
    onClear
  })) != null ? _a : createVNode(IxIcon, {
    "name": clearIcon,
    "onClick": onClear
  }, null);
  return createVNode("span", {
    "class": classes
  }, [children]);
}
const IxTextarea = Textarea;

const timePanelContext = Symbol("timePanelContext");
var __defProp$7 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const baseTimePanelProps = {
  disabledHours: IxPropTypes.func().def(() => []),
  disabledMinutes: IxPropTypes.func().def(() => []),
  disabledSeconds: IxPropTypes.func().def(() => []),
  hideDisabledOptions: IxPropTypes.bool.def(false),
  hourStep: IxPropTypes.number.def(1),
  minuteStep: IxPropTypes.number.def(1),
  secondStep: IxPropTypes.number.def(1)
};
const timePanelProps = __spreadProps$2(__spreadValues$7({}, baseTimePanelProps), {
  value: IxPropTypes.object(),
  defaultOpenValue: IxPropTypes.object(),
  visible: IxPropTypes.bool,
  hourEnabled: IxPropTypes.bool.def(true),
  minuteEnabled: IxPropTypes.bool.def(true),
  secondEnabled: IxPropTypes.bool.def(true),
  use12Hours: IxPropTypes.bool.def(false),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
});
const timePanelColumnProps = {
  selectedValue: IxPropTypes.oneOfType([IxPropTypes.number, IxPropTypes.string]).isRequired,
  options: IxPropTypes.arrayOf(IxPropTypes.object()).isRequired,
  visible: IxPropTypes.bool,
  onChange: IxPropTypes.emit()
};
const timePanelCellProps = {
  disabled: IxPropTypes.bool.def(false),
  selected: IxPropTypes.bool.def(false),
  value: IxPropTypes.oneOfType([Number, String]).isRequired,
  onChange: IxPropTypes.emit()
};
var PanelCell = defineComponent({
  props: timePanelCellProps,
  setup(props) {
    const {
      mergedPrefixCls
    } = inject(timePanelContext);
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-cell`;
      return {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-selected`]: props.selected
      };
    });
    const onClick = () => {
      if (!props.disabled && !props.selected) {
        callEmit(props.onChange, props.value);
      }
    };
    const displayValue = computed(() => displayFormat(props.value));
    return () => createVNode("li", {
      "class": classes.value,
      "onClick": onClick
    }, [displayValue.value]);
  }
});
function displayFormat(val) {
  return isNumeric(val) ? val.toString().padStart(2, "0") : val;
}
function usePanelScroll(props, listRef, mergedPrefixCls) {
  let scrollHandlerLocked = false;
  let isScrolling = false;
  let scrollTargetIndex;
  function getCellHeight() {
    var _a, _b, _c;
    return (_c = (_b = (_a = listRef.value) == null ? void 0 : _a.querySelector(`li.${mergedPrefixCls.value}-cell`)) == null ? void 0 : _b.offsetHeight) != null ? _c : 0;
  }
  function adjustPanel(selectedIndex, duration = 200) {
    const target = listRef.value;
    if (!target || isScrolling || scrollHandlerLocked) {
      return;
    }
    const top = Math.max(selectedIndex * getCellHeight(), 0);
    if (top === getScroll(target).scrollTop) {
      return;
    }
    scrollHandlerLocked = true;
    scrollToTop({ top, target, duration, callback: () => scrollHandlerLocked = false });
  }
  function scrollToSelected(duration) {
    const selectedIndex = props.options.findIndex((item) => item.value === props.selectedValue);
    adjustPanel(selectedIndex, duration);
  }
  function handleScrollAdjust() {
    isNil(scrollTargetIndex) || scrollTargetIndex < 0 ? scrollToSelected() : adjustPanel(scrollTargetIndex);
  }
  function handleScroll() {
    const target = listRef.value;
    if (!target || scrollHandlerLocked) {
      return;
    }
    isScrolling = true;
    scrollTargetIndex = Math.min(Math.round(getScroll(target).scrollTop / getCellHeight()), props.options.length - 1);
    const targetItem = props.options[scrollTargetIndex];
    if (!targetItem.disabled) {
      callEmit(props.onChange, targetItem.value);
    }
    nextTick(() => {
      isScrolling = false;
    });
  }
  watchEffect(() => {
    if (props.visible) {
      nextTick(() => scrollToSelected(0));
    }
  });
  watch(() => props.selectedValue, (value) => {
    const newScrollTargetIndex = props.options.findIndex((item) => item.value === value);
    if (scrollTargetIndex !== newScrollTargetIndex) {
      scrollTargetIndex = newScrollTargetIndex;
      !isScrolling && nextTick(scrollToSelected);
    }
  });
  return {
    adjustPanel,
    scrollToSelected,
    handleScrollAdjust,
    handleScroll
  };
}
var PanelColumn = defineComponent({
  props: timePanelColumnProps,
  setup(props) {
    const {
      mergedPrefixCls
    } = inject(timePanelContext);
    const listRef = ref(null);
    const {
      scrollToSelected,
      handleScroll,
      handleScrollAdjust
    } = usePanelScroll(props, listRef, mergedPrefixCls);
    function onChange(value) {
      callEmit(props.onChange, value);
      nextTick(scrollToSelected);
    }
    return () => createVNode("ul", {
      "ref": listRef,
      "class": `${mergedPrefixCls.value}-column`,
      "onScroll": handleScroll,
      "onMousemove": handleScrollAdjust,
      "onMouseenter": handleScrollAdjust
    }, [props.options.map((item, index) => {
      const {
        disabled,
        value
      } = item;
      return createVNode(PanelCell, {
        "key": index,
        "disabled": disabled,
        "selected": props.selectedValue === value,
        "value": value,
        "onChange": onChange
      }, null);
    })]);
  }
});
function normalizeAmPm(hour, is12Hours = false) {
  if (!is12Hours) {
    return "";
  }
  return hour >= 12 ? "pm" : "am";
}
function calculateViewHour(hour, is12Hours) {
  if (is12Hours) {
    hour > 12 && (hour -= 12);
    hour === 0 && (hour = 12);
  }
  return hour;
}
function getHourValue(hour, ampm) {
  if (ampm) {
    ampm = ampm.toLowerCase();
    if (ampm === "am") {
      hour >= 12 && (hour -= 12);
    }
    if (ampm === "pm") {
      hour < 12 && (hour += 12);
    }
  }
  return hour;
}
function calculateValue(dateConfig, dateNow, type, is12Hours, value) {
  const { get, set } = dateConfig;
  const selectNumber = Number(value);
  const newDate = new Date(dateNow);
  switch (type) {
    case "hour":
      return set(newDate, getHourValue(selectNumber, normalizeAmPm(get(dateNow, "hour"), is12Hours)), "hour");
    case "minute":
      return set(newDate, selectNumber, "minute");
    case "second":
      return set(newDate, selectNumber, "second");
    case "AM/PM":
      return set(newDate, getHourValue(get(newDate, "hour"), value.toString()), "hour");
  }
}
function useOptions(props, dateConfig) {
  const { get } = dateConfig;
  const defaultOpenValue = computed(() => {
    var _a;
    return (_a = props.defaultOpenValue) != null ? _a : dateConfig.startOf(dateConfig.now(), "date");
  });
  const selectedValue = computed(() => {
    var _a;
    return (_a = props.value) != null ? _a : defaultOpenValue.value;
  });
  const viewHours = computed(() => calculateViewHour(get(selectedValue.value, "hour"), props.use12Hours));
  const ampm = computed(() => normalizeAmPm(get(selectedValue.value, "hour"), props.use12Hours));
  function getOptions(type) {
    const getHourOptions = () => {
      const options = generateNumericOptions(props.use12Hours ? 12 : 24, props.hourStep, props.disabledHours(ampm.value), props.hideDisabledOptions);
      if (props.use12Hours) {
        const zeroOpt = options.find((opt) => opt.value === 0);
        zeroOpt && (zeroOpt.value = 12);
      }
      return options;
    };
    switch (type) {
      case "AM/PM":
        return generateAmPmOptions("", props.hideDisabledOptions);
      case "second":
        return generateNumericOptions(60, props.secondStep, props.disabledSeconds(viewHours.value, get(selectedValue.value, "minute"), ampm.value), props.hideDisabledOptions);
      case "minute":
        return generateNumericOptions(60, props.minuteStep, props.disabledMinutes(viewHours.value, ampm.value), props.hideDisabledOptions);
      case "hour":
        return getHourOptions();
      default:
        return [];
    }
  }
  function getSelectedValue(type) {
    switch (type) {
      case "AM/PM":
        return ampm.value;
      case "hour":
      default:
        return get(selectedValue.value, "hour");
      case "minute":
        return get(selectedValue.value, "minute");
      case "second":
        return get(selectedValue.value, "second");
    }
  }
  function getOnChange(type) {
    const onChange = (type2, value) => {
      const newValue = calculateValue(dateConfig, selectedValue.value, type2, props.use12Hours, value);
      callEmit(props["onUpdate:value"], newValue);
      callEmit(props.onChange, newValue);
    };
    return (value) => onChange(type, value);
  }
  const getProps = (type) => {
    return computed(() => ({
      selectedValue: getSelectedValue(type),
      options: getOptions(type),
      onChange: getOnChange(type)
    }));
  };
  return {
    hourOptionsProps: getProps("hour"),
    minuteOptionsProps: getProps("minute"),
    secondOptionsProps: getProps("second"),
    amPmOptionsProps: getProps("AM/PM")
  };
}
function generateNumericOptions(total, step, disabledOption, hideDisabledOptions) {
  const options = [];
  for (let index = 0; index < total; index += step) {
    const isDisabled = disabledOption.includes(index);
    if (!isDisabled || !hideDisabledOptions) {
      options.push({
        value: index,
        disabled: isDisabled
      });
    }
  }
  return options;
}
function generateAmPmOptions(disabledOption, hideDisabledOptions) {
  disabledOption = disabledOption.toLowerCase();
  return ["am", "pm"].map((item) => ({
    disabled: disabledOption === item,
    value: item
  })).filter((item) => !hideDisabledOptions || !item.disabled);
}
var TimePanel = defineComponent({
  props: timePanelProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-panel`);
    const dateConfig = useDateConfig();
    const {
      hourOptionsProps,
      minuteOptionsProps,
      secondOptionsProps,
      amPmOptionsProps
    } = useOptions(props, dateConfig);
    provide(timePanelContext, {
      mergedPrefixCls
    });
    const columns = computed(() => {
      const result = [];
      props.hourEnabled && result.push(hourOptionsProps.value);
      props.minuteEnabled && result.push(minuteOptionsProps.value);
      props.secondEnabled && result.push(secondOptionsProps.value);
      props.use12Hours && result.push(amPmOptionsProps.value);
      return result;
    });
    return () => createVNode("div", {
      "class": `${mergedPrefixCls.value}`
    }, [columns.value.map((item, index) => createVNode(PanelColumn, mergeProps({
      "key": index
    }, item, {
      "visible": props.visible
    }), null))]);
  }
});
const \u0275TimePanel = TimePanel;

function useInputEnableStatus(props, config) {
  return computed(() => {
    var _a;
    const allowInput = (_a = props.allowInput) != null ? _a : config.allowInput;
    return {
      enableExternalInput: allowInput === true,
      enableInternalInput: allowInput === "overlay"
    };
  });
}
function convertToDate(dateConfig, value, format) {
  if (!value) {
    return void 0;
  }
  return dateConfig.convert(value, format);
}
function usePickerControl(valueProp, dateConfig, format, inputPreProcessors, validateInput, onChange) {
  const [inputValue, setInputValue] = useState$1(void 0);
  const [panelValue, setPanelValue] = useState$1(void 0);
  const { parse, format: formatDate } = dateConfig;
  const dateValue = computed(() => convertToDate(dateConfig, valueProp.value, format.value));
  const formatedDateValue = computed(() => isString(valueProp.value) ? valueProp.value : dateValue.value ? formatDate(dateValue.value, format.value) : "");
  function init() {
    var _a;
    if (!inputValue.value || parse(inputValue.value, format.value).valueOf() !== ((_a = dateValue.value) == null ? void 0 : _a.valueOf())) {
      setInputValue(formatedDateValue.value);
    }
    setPanelValue(dateValue.value);
  }
  init();
  watch(valueProp, () => {
    init();
  });
  function handleInputChange(value) {
    const processedValue = preProcessInputValue(value, inputPreProcessors);
    setInputValue(value);
    if (validateInput(processedValue)) {
      onChange(inputValue.value ? parse(inputValue.value, format.value) : void 0);
    }
  }
  function handlePanelChange(value) {
    onChange(value);
  }
  return {
    inputValue,
    panelValue,
    setInputValue,
    setPanelValue,
    init,
    handleInputChange,
    handlePanelChange
  };
}
function preProcessInputValue(value, inputPreProcessors) {
  return inputPreProcessors.reduce((result, processor) => processor(result), value);
}
function useRangePickerControl(valueProp, dateConfig, format, inputPreProcessors, validateInput, onChange) {
  const rangeValueRef = computed(() => {
    if (!isArray$1(valueProp.value)) {
      return [void 0, void 0];
    }
    return valueProp.value.map((v) => convertToDate(dateConfig, v, format.value));
  });
  const fromValue = computed(() => rangeValueRef.value[0]);
  const toValue = computed(() => rangeValueRef.value[1]);
  const fromControl = usePickerControl(fromValue, dateConfig, format, inputPreProcessors, validateInput, (value) => {
    onChange([value, toValue.value]);
  });
  const toControl = usePickerControl(toValue, dateConfig, format, inputPreProcessors, validateInput, (value) => {
    onChange([fromValue.value, value]);
  });
  return [fromControl, toControl];
}
function useCommonInputProps(props, config, formContext) {
  return computed(() => {
    var _a, _b, _c, _d, _e;
    return {
      borderless: (_a = props.borderless) != null ? _a : config.borderless,
      clearable: (_b = props.clearable) != null ? _b : config.clearable,
      clearIcon: (_c = props.clearIcon) != null ? _c : config.clearIcon,
      size: (_e = (_d = props.size) != null ? _d : formContext == null ? void 0 : formContext.size.value) != null ? _e : config.size
    };
  });
}
function useCommonTriggerProps(props, timePickerContext2) {
  const {
    props: pickerProps,
    config,
    overlayOpened,
    formContext,
    commonBindings: { isDisabled, isFocused, handleBlur, handleFocus }
  } = timePickerContext2;
  return computed(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const pickerClearable = (_a = pickerProps.clearable) != null ? _a : config.clearable;
    const enableExternalInput = ((_b = pickerProps.allowInput) != null ? _b : config.allowInput) === true;
    const valueNotEmpty = isArray$1(props.value) ? props.value.some((v) => !!v) : !!props.value;
    return {
      disabled: (_c = isDisabled == null ? void 0 : isDisabled.value) != null ? _c : pickerProps.disabled,
      focused: (isFocused == null ? void 0 : isFocused.value) || overlayOpened.value,
      readonly: pickerProps.readonly,
      borderless: (_d = pickerProps.borderless) != null ? _d : config.borderless,
      clearable: (enableExternalInput || !(overlayOpened == null ? void 0 : overlayOpened.value)) && !pickerProps.readonly && pickerClearable && valueNotEmpty,
      clearIcon: (_e = pickerProps.clearIcon) != null ? _e : config.clearIcon,
      size: (_g = (_f = pickerProps.size) != null ? _f : formContext == null ? void 0 : formContext.size.value) != null ? _g : config.size,
      suffix: (_h = pickerProps.suffix) != null ? _h : config.suffix,
      onFocus: handleFocus,
      onBlur: handleBlur
    };
  });
}
function useCommonPanelProps(props, config) {
  return computed(() => {
    const {
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      format,
      hideDisabledOptions,
      hourStep,
      minuteStep,
      secondStep
    } = props;
    const _format = format != null ? format : config.format;
    return {
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      hideDisabledOptions,
      hourStep,
      minuteStep,
      secondStep,
      hourEnabled: /[hH]/.test(_format),
      minuteEnabled: /m/.test(_format),
      secondEnabled: /s/.test(_format),
      use12Hours: /[aA]/.test(_format),
      amPmCapital: /A/.test(_format)
    };
  });
}
const defaultOffset$1 = [0, 8];
function useCommonOverlayProps(props, config, mergedPrefixCls, setVisibility) {
  return computed(() => {
    var _a, _b;
    return {
      class: props.overlayClassName,
      clickOutside: true,
      offset: defaultOffset$1,
      placement: "bottomStart",
      transitionName: "ix-fade",
      target: (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-overlay-container`,
      trigger: "manual",
      ["onUpdate:visible"]: setVisibility
    };
  });
}
function valueIsRange(value) {
  return isArray$1(value);
}
function useTimePickerCommonBindings(props) {
  const accessor = useFormAccessor();
  const isDisabled = computed(() => accessor.disabled.value);
  const [isFocused, setFocused] = useState$1(false);
  function handleChange(value) {
    let newValue;
    if (valueIsRange(value)) {
      newValue = getValidDateRangeValue(value, props.autoSwap);
    } else {
      newValue = value;
    }
    callEmit(props.onChange, newValue);
    accessor.setValue(newValue);
  }
  function handleClear(evt) {
    callEmit(props.onClear, evt);
    accessor.setValue(void 0);
  }
  function handleFocus(evt) {
    callEmit(props.onFocus, evt);
    setFocused(true);
  }
  function handleBlur(evt) {
    callEmit(props.onBlur, evt);
    accessor.markAsBlurred();
    setFocused(false);
  }
  return {
    accessor,
    isDisabled,
    isFocused,
    handleChange,
    handleClear,
    handleFocus,
    handleBlur
  };
}
function getValidDateRangeValue(value, autoSwap) {
  const [fromDate, toDate] = value;
  if (!fromDate || !toDate || fromDate.valueOf() <= toDate.valueOf()) {
    return value;
  }
  return autoSwap ? value.reverse() : value;
}
const timePickerContext = Symbol("timePickerContext");
const timeRangePickerContext = Symbol("timeRangePickerContext");
const timePickerControl = Symbol("timePickerControl");
const timeRangePickerControl = Symbol("timeRangePickerControl");
var Overlay = defineComponent({
  name: "IxTimePickerOverlay",
  setup() {
    const {
      slots,
      props,
      config,
      format,
      dateConfig,
      formContext,
      inputEnableStatus,
      mergedPrefixCls,
      overlayOpened,
      commonBindings: {
        isDisabled,
        handleClear
      }
    } = inject(timePickerContext);
    const {
      inputValue,
      panelValue,
      setInputValue,
      handleInputChange,
      handlePanelChange
    } = inject(timePickerControl);
    const locale = getLocale("timePicker");
    const handleInputClear = (evt) => {
      evt.stopPropagation();
      handleClear(evt);
      setInputValue("");
    };
    const inputProps = useCommonInputProps(props, config, formContext);
    const panelProps = useCommonPanelProps(props, config);
    const inputSlots = {
      clearIcon: slots.clearIcon
    };
    const inputRef = ref();
    watch(overlayOpened, (opened) => {
      if (opened) {
        nextTick(() => {
          var _a;
          return (_a = inputRef.value) == null ? void 0 : _a.focus();
        });
      }
    });
    return () => {
      var _a;
      const prefixCls = `${mergedPrefixCls.value}-overlay`;
      return createVNode("div", {
        "class": prefixCls
      }, [inputEnableStatus.value.enableInternalInput && createVNode(IxInput, mergeProps({
        "ref": inputRef,
        "class": `${prefixCls}-input`
      }, inputProps.value, {
        "value": inputValue.value,
        "disabled": isDisabled.value,
        "readonly": props.readonly,
        "placeholder": (_a = props.placeholder) != null ? _a : locale.value.placeholder,
        "onChange": handleInputChange,
        "onClear": handleInputClear
      }), inputSlots), createVNode(\u0275TimePanel, mergeProps(panelProps.value, {
        "visible": overlayOpened.value,
        "defaultOpenValue": convertToDate(dateConfig, props.defaultOpenValue, format.value),
        "value": panelValue.value,
        "onChange": handlePanelChange
      }), null)]);
    };
  }
});
var __defProp$2$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$1 = (obj, key, value) => key in obj ? __defProp$2$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2$1.call(b, prop))
      __defNormalProp$2$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$2$1)
    for (var prop of __getOwnPropSymbols$2$1(b)) {
      if (__propIsEnum$2$1.call(b, prop))
        __defNormalProp$2$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const basePickerProps = __spreadProps$1(__spreadValues$2$1({}, baseTimePanelProps), {
  open: IxPropTypes.bool,
  control: controlPropDef,
  allowInput: IxPropTypes.oneOfType([Boolean, IxPropTypes.oneOf(["overlay"])]),
  autoSwap: IxPropTypes.bool.def(true),
  autofocus: IxPropTypes.bool,
  borderless: IxPropTypes.bool,
  clearable: IxPropTypes.bool,
  clearIcon: IxPropTypes.string,
  clearText: IxPropTypes.string,
  format: IxPropTypes.string,
  overlayClassName: IxPropTypes.string,
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  target: portalTargetDef,
  "onUpdate:open": IxPropTypes.emit(),
  onClear: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit()
});
const timePickerProps = __spreadProps$1(__spreadValues$2$1({}, basePickerProps), {
  value: IxPropTypes.oneOfType([Number, String, Date]),
  defaultOpenValue: IxPropTypes.oneOfType([Number, String, Date]),
  disabled: IxPropTypes.bool.def(false),
  placeholder: IxPropTypes.string,
  readonly: IxPropTypes.bool.def(false),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
});
const timeRangePickerProps = __spreadProps$1(__spreadValues$2$1({}, basePickerProps), {
  value: IxPropTypes.object(),
  defaultOpenValue: IxPropTypes.object(),
  disabled: IxPropTypes.bool.def(false),
  placeholder: IxPropTypes.object(),
  readonly: IxPropTypes.bool.def(false),
  separator: IxPropTypes.oneOfType([String, IxPropTypes.vNode]),
  "onUpdate:value": IxPropTypes.emit(),
  onChange: IxPropTypes.emit()
});
const baseTriggerProps = {
  borderless: IxPropTypes.bool,
  clearable: IxPropTypes.bool,
  clearIcon: IxPropTypes.string,
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  disabled: IxPropTypes.bool.def(false),
  readonly: IxPropTypes.bool.def(false),
  focused: IxPropTypes.bool,
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onClick: IxPropTypes.emit(),
  onClear: IxPropTypes.emit()
};
const timePickerTriggerProps = {
  value: IxPropTypes.object()
};
const timeRangePickerTriggerProps = {
  value: IxPropTypes.object()
};
var BaseTrigger = defineComponent({
  name: "IxTimePickerBaseTrigger",
  props: baseTriggerProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-picker-trigger`);
    const isDisabled = computed(() => props.disabled);
    const focusMonitor = useSharedFocusMonitor();
    const triggerRef = ref();
    onMounted(() => {
      watch(focusMonitor.monitor(triggerRef.value, true), (evt) => {
        const {
          origin,
          event
        } = evt;
        if (event) {
          if (origin) {
            callEmit(props.onFocus, event);
          } else {
            callEmit(props.onBlur, event);
          }
        }
      });
    });
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: isDisabled.value,
        [`${prefixCls}-borderless`]: props.borderless,
        [`${prefixCls}-readonly`]: props.readonly,
        [`${prefixCls}-focused`]: props.focused,
        [`${prefixCls}-${props.size}`]: props.size
      });
    });
    const handkeClick = (evt) => {
      if (isDisabled.value) {
        return;
      }
      callEmit(props.onClick, evt);
    };
    const onClear = (evt) => {
      evt.stopPropagation();
      callEmit(props.onClear, evt);
    };
    const renderSuffix = () => {
      var _a, _b;
      if (!(props.clearable || slots.clearIcon || props.suffix)) {
        return null;
      }
      return createVNode("div", {
        "class": `${mergedPrefixCls.value}-suffix`
      }, [(_b = (_a = slots.suffix) == null ? void 0 : _a.call(slots)) != null ? _b : props.suffix && createVNode(IxIcon, {
        "name": props.suffix
      }, null)]);
    };
    const renderClearIcon = () => {
      var _a, _b;
      if (!props.clearable || isDisabled.value) {
        return null;
      }
      return createVNode("span", {
        "class": `${mergedPrefixCls.value}-clear-icon`
      }, [(_b = (_a = slots.clearIcon) == null ? void 0 : _a.call(slots, {
        onClear
      })) != null ? _b : props.clearIcon && createVNode(IxIcon, {
        "name": props.clearIcon,
        "onClick": onClear
      }, null)]);
    };
    return () => {
      var _a;
      return createVNode("div", {
        "ref": triggerRef,
        "class": classes.value,
        "onClick": handkeClick
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots), renderSuffix(), renderClearIcon()]);
    };
  }
});
var __defProp$1$1 = Object.defineProperty;
var __getOwnPropSymbols$1$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$1 = (obj, key, value) => key in obj ? __defProp$1$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$2.call(b, prop))
      __defNormalProp$1$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$2)
    for (var prop of __getOwnPropSymbols$1$2(b)) {
      if (__propIsEnum$1$2.call(b, prop))
        __defNormalProp$1$1(a, prop, b[prop]);
    }
  return a;
};
var Trigger$1 = defineComponent({
  name: "IxTimePickerTrigger",
  props: timePickerTriggerProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-picker-trigger`);
    const locale = getLocale("timePicker");
    const context = inject(timePickerContext);
    const {
      dateConfig,
      props: pickerProps,
      format,
      slots,
      inputEnableStatus,
      setOverlayOpened,
      commonBindings: {
        isDisabled,
        handleClear
      }
    } = context;
    const {
      inputValue,
      handleInputChange
    } = inject(timePickerControl);
    const handleClick = () => {
      if (pickerProps.readonly) {
        return;
      }
      setOverlayOpened(true);
    };
    const placeholder = computed(() => {
      var _a;
      return (_a = pickerProps.placeholder) != null ? _a : locale.value.placeholder;
    });
    const triggerProps = useCommonTriggerProps(props, context);
    const renderContent = () => {
      const prefixCls = mergedPrefixCls.value;
      if (inputEnableStatus.value.enableExternalInput) {
        const onInput = (evt) => {
          const {
            value
          } = evt.target;
          handleInputChange(value);
        };
        const onKeydown = withKeys(() => {
          setOverlayOpened(false);
        }, ["enter"]);
        return createVNode("input", {
          "class": `${prefixCls}-input`,
          "autocomplete": "off",
          "disabled": isDisabled.value || pickerProps.readonly,
          "value": inputValue.value,
          "placeholder": placeholder.value,
          "onInput": onInput,
          "onKeydown": onKeydown
        }, null);
      }
      return props.value ? dateConfig.format(props.value, format.value) : createVNode("span", {
        "class": `${mergedPrefixCls.value}-placeholder`
      }, [placeholder.value]);
    };
    return () => createVNode(BaseTrigger, mergeProps(triggerProps.value, {
      "onClick": handleClick,
      "onClear": handleClear
    }), __spreadValues$1$1({
      default: () => [renderContent()]
    }, slots));
  }
});
var TimePicker = defineComponent({
  name: "IxTimePicker",
  props: timePickerProps,
  setup(props, {
    slots
  }) {
    const config = useGlobalConfig$1("timePicker");
    const dateConfig = useDateConfig();
    const {
      isValid,
      parse
    } = dateConfig;
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-picker`);
    const [visibility, setVisibility] = useControlledProp(props, "open", false);
    const format = computed(() => {
      var _a;
      return (_a = props.format) != null ? _a : config.format;
    });
    const commonBindings = useTimePickerCommonBindings(props);
    const {
      accessor,
      isDisabled,
      handleChange
    } = commonBindings;
    const pickerControl = usePickerControl(accessor.valueRef, dateConfig, format, [], (value) => !value || isValid(parse(value, format.value)), handleChange);
    const {
      init
    } = pickerControl;
    const inputEnableStatus = useInputEnableStatus(props, config);
    const changeVisible = (visible) => {
      setVisibility(visible);
      if (!visible) {
        init();
      }
    };
    const formContext = inject(FORM_TOKEN, null);
    provide(timePickerControl, pickerControl);
    provide(timePickerContext, {
      dateConfig,
      config,
      props,
      format,
      formContext,
      slots,
      overlayOpened: visibility,
      mergedPrefixCls,
      inputEnableStatus,
      commonBindings,
      setOverlayOpened: changeVisible
    });
    const overlayProps = useCommonOverlayProps(props, config, mergedPrefixCls, changeVisible);
    return () => {
      const renderTrigger = () => createVNode(Trigger$1, {
        "class": mergedPrefixCls.value,
        "value": convertToDate(dateConfig, accessor.valueRef.value, format.value)
      }, null);
      const renderContent = () => createVNode(Overlay, null, null);
      return createVNode(\u0275Overlay, mergeProps(overlayProps.value, {
        "visible": visibility.value,
        "disabled": isDisabled.value || props.readonly
      }), {
        default: renderTrigger,
        content: renderContent
      });
    };
  }
});
var RangeOverlay = defineComponent({
  name: "IxTimeRangePickerOverlay",
  setup() {
    const {
      props,
      config,
      dateConfig,
      format,
      slots,
      inputEnableStatus,
      overlayOpened,
      formContext,
      mergedPrefixCls,
      bufferValue,
      commonBindings: {
        isDisabled,
        handleChange
      },
      renderSeparator,
      setOverlayOpened
    } = inject(timeRangePickerContext);
    const [fromPickerControl, toPickerControl] = inject(timeRangePickerControl);
    const locale = getLocale("timeRangePicker");
    const inputProps = useCommonInputProps(props, config, formContext);
    const panelProps = useCommonPanelProps(props, config);
    const handleConfirm = () => {
      handleChange(bufferValue.value);
      setOverlayOpened(false);
    };
    function renderSide2(pickerControl, placeholder, defaultOpenValue) {
      const {
        inputValue,
        panelValue,
        handleInputChange,
        handlePanelChange
      } = pickerControl;
      const prefixCls = `${mergedPrefixCls.value}-overlay-side`;
      const inputSlots = {
        clearIcon: slots.clearIcon
      };
      const handleInputClear = (evt) => {
        evt.stopPropagation();
        handleInputChange("");
      };
      return createVNode("div", {
        "class": prefixCls
      }, [inputEnableStatus.value.enableInternalInput && createVNode(IxInput, mergeProps({
        "class": `${prefixCls}-input`
      }, inputProps.value, {
        "value": inputValue.value,
        "disabled": isDisabled.value,
        "readonly": props.readonly,
        "placeholder": placeholder,
        "onChange": handleInputChange,
        "onClear": handleInputClear
      }), inputSlots), createVNode(\u0275TimePanel, mergeProps(panelProps.value, {
        "visible": overlayOpened.value,
        "defaultOpenValue": convertToDate(dateConfig, defaultOpenValue, format.value),
        "value": panelValue.value,
        "onChange": handlePanelChange
      }), null)]);
    }
    const renderFooter = () => {
      var _a, _b;
      return (_b = (_a = slots.footer) == null ? void 0 : _a.call(slots, {
        onConfirm: handleConfirm
      })) != null ? _b : createVNode(IxButton, {
        "mode": "primary",
        "size": "sm",
        "onClick": handleConfirm
      }, {
        default: () => [locale.value.okText]
      });
    };
    return () => {
      var _a, _b, _c, _d, _e, _f;
      const prefixCls = `${mergedPrefixCls.value}-overlay`;
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("div", {
        "class": `${prefixCls}-content`
      }, [renderSide2(fromPickerControl, (_b = (_a = props.placeholder) == null ? void 0 : _a[0]) != null ? _b : locale.value.placeholder[0], (_c = props.defaultOpenValue) == null ? void 0 : _c[0]), createVNode("div", {
        "class": `${prefixCls}-gap`
      }, [renderSeparator()]), renderSide2(toPickerControl, (_e = (_d = props.placeholder) == null ? void 0 : _d[1]) != null ? _e : locale.value.placeholder[1], (_f = props.defaultOpenValue) == null ? void 0 : _f[1])]), createVNode("div", {
        "class": `${prefixCls}-footer`
      }, [renderFooter()])]);
    };
  }
});
var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var RangeTrigger = defineComponent({
  name: "IxTimeRangePickerTrigger",
  props: timeRangePickerTriggerProps,
  setup(props) {
    const common = useGlobalConfig$1("common");
    const commonPrefixCls = computed(() => common.prefixCls);
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-range-picker-trigger`);
    const locale = getLocale("timeRangePicker");
    const context = inject(timeRangePickerContext);
    const {
      dateConfig,
      props: pickerProps,
      format,
      slots,
      inputEnableStatus,
      setOverlayOpened,
      renderSeparator,
      commonBindings: {
        isDisabled,
        handleClear
      }
    } = context;
    const [fromPickerControl, toPickerControl] = inject(timeRangePickerControl);
    const handleClick = () => {
      if (pickerProps.readonly) {
        return;
      }
      setOverlayOpened(true);
    };
    const placeholder = computed(() => {
      var _a, _b, _c, _d;
      return [(_b = (_a = pickerProps.placeholder) == null ? void 0 : _a[0]) != null ? _b : locale.value.placeholder[0], (_d = (_c = pickerProps.placeholder) == null ? void 0 : _c[1]) != null ? _d : locale.value.placeholder[1]];
    });
    const triggerProps = useCommonTriggerProps(props, context);
    const renderContent = () => {
      var _a, _b;
      const prefixCls = mergedPrefixCls.value;
      const enableInput = inputEnableStatus.value.enableExternalInput;
      const disabled = isDisabled.value || pickerProps.readonly;
      return createVNode("span", {
        "class": `${prefixCls}-content`
      }, [createVNode("span", {
        "class": `${prefixCls}-content-side`
      }, [renderSide((_a = props.value) == null ? void 0 : _a[0], format.value, dateConfig, fromPickerControl, enableInput, disabled, placeholder.value[0], commonPrefixCls.value)]), createVNode("span", {
        "class": `${prefixCls}-content-separator`
      }, [renderSeparator()]), createVNode("span", {
        "class": `${prefixCls}-content-side`
      }, [renderSide((_b = props.value) == null ? void 0 : _b[1], format.value, dateConfig, toPickerControl, enableInput, disabled, placeholder.value[1], commonPrefixCls.value)])]);
    };
    return () => createVNode(BaseTrigger, mergeProps(triggerProps.value, {
      "onClick": handleClick,
      "onClear": handleClear
    }), __spreadValues$6({
      default: () => [renderContent()]
    }, slots));
  }
});
function renderSide(value, format, dateConfig, pickerControl, enableInput, disabled, placeholder, prefixCls) {
  if (!enableInput) {
    return value ? dateConfig.format(value, format) : createVNode("span", {
      "class": `${prefixCls}-time-picker-trigger-placeholder`
    }, [placeholder]);
  }
  const {
    inputValue,
    handleInputChange
  } = pickerControl;
  const onInput = (evt) => {
    const {
      value: value2
    } = evt.target;
    handleInputChange(value2);
  };
  return createVNode("input", {
    "class": `${prefixCls}-time-picker-trigger-input`,
    "autocomplete": "off",
    "disabled": disabled,
    "value": inputValue.value,
    "placeholder": placeholder,
    "onInput": onInput
  }, null);
}
var TimeRangePicker = defineComponent({
  name: "IxTimeRangePicker",
  props: timeRangePickerProps,
  setup(props, {
    slots
  }) {
    const config = useGlobalConfig$1("timeRangePicker");
    const dateConfig = useDateConfig();
    const {
      isValid,
      parse
    } = dateConfig;
    const locale = getLocale("timeRangePicker");
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-time-range-picker`);
    const [visibility, setVisibility] = useControlledProp(props, "open", false);
    const format = computed(() => {
      var _a;
      return (_a = props.format) != null ? _a : config.format;
    });
    const commonBindings = useTimePickerCommonBindings(props);
    const {
      accessor,
      isDisabled
    } = commonBindings;
    const accessorDateValue = computed(() => {
      if (!isArray$1(accessor.valueRef.value)) {
        return [void 0, void 0];
      }
      return accessor.valueRef.value.map((v) => convertToDate(dateConfig, v, format.value));
    });
    const [bufferValue, setBufferValue] = useState$1(accessorDateValue.value);
    watch(accessorDateValue, setBufferValue);
    const rangePickerControl = useRangePickerControl(bufferValue, dateConfig, format, [], (value) => !value || isValid(parse(value, format.value)), setBufferValue);
    const inputEnableStatus = useInputEnableStatus(props, config);
    const changeVisible = (visible) => {
      setVisibility(visible);
      if (!visible) {
        setBufferValue(accessorDateValue.value);
      }
    };
    const formContext = inject(FORM_TOKEN, null);
    const renderSeparator = () => {
      var _a, _b, _c;
      return (_c = (_b = (_a = slots.separator) == null ? void 0 : _a.call(slots)) != null ? _b : props.separator) != null ? _c : locale.value.separator;
    };
    provide(timeRangePickerControl, rangePickerControl);
    provide(timeRangePickerContext, {
      dateConfig,
      config,
      props,
      format,
      formContext,
      slots,
      overlayOpened: visibility,
      mergedPrefixCls,
      inputEnableStatus,
      commonBindings,
      bufferValue,
      setOverlayOpened: changeVisible,
      renderSeparator
    });
    const overlayProps = useCommonOverlayProps(props, config, mergedPrefixCls, changeVisible);
    return () => {
      const renderTrigger = () => createVNode(RangeTrigger, {
        "class": mergedPrefixCls.value,
        "value": accessorDateValue.value
      }, null);
      const renderContent = () => createVNode(RangeOverlay, null, null);
      return createVNode(\u0275Overlay, mergeProps(overlayProps.value, {
        "visible": visibility.value,
        "disabled": isDisabled.value || props.readonly
      }), {
        default: renderTrigger,
        content: renderContent
      });
    };
  }
});
const IxTimePicker = TimePicker;
const IxTimeRangePicker = TimeRangePicker;

const timelineProps = {
  pending: IxPropTypes.oneOfType([String, Boolean]).def(false),
  pendingDot: IxPropTypes.string,
  reverse: IxPropTypes.bool.def(false),
  position: IxPropTypes.oneOf(["left", "alternate", "right"]).def("right")
};
const timelineItemProps = {
  color: IxPropTypes.string.def("primary"),
  dot: IxPropTypes.string,
  position: IxPropTypes.oneOf(["left", "right"])
};
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = defineComponent({
  name: "IxTimelineItem",
  props: timelineItemProps,
  setup(props, { slots }) {
    const isPresetOrStatus = computed(() => isPresetColor(props.color) || isStatusColor(props.color));
    const dotStyle = useStyle(props, isPresetOrStatus);
    const dotClass = useClasses$1(props, slots, isPresetOrStatus);
    return {
      dotStyle,
      dotClass
    };
  }
});
const useClasses$1 = (props, slots, isPresetOrStatus) => {
  return computed(() => {
    const hasCustomDot = hasSlot(slots, "dot") || !!props.dot;
    return {
      "ix-timeline-item-dot": true,
      "ix-timeline-item-dot-custom": hasCustomDot,
      [`ix-timeline-item-dot-${props.color}`]: isPresetOrStatus.value
    };
  });
};
const useStyle = (props, isPresetOrStatus) => {
  return computed(() => {
    if (isPresetOrStatus.value) {
      return {};
    }
    return {
      color: props.color,
      "border-color": props.color
    };
  });
};
const _hoisted_1 = { class: "ix-timeline-item" };
const _hoisted_2 = /* @__PURE__ */ createElementVNode("div", { class: "ix-timeline-item-line" }, null, -1);
const _hoisted_3 = { class: "ix-timeline-item-content" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1, [
    _hoisted_2,
    createElementVNode("div", {
      class: normalizeClass(_ctx.dotClass),
      style: normalizeStyle(_ctx.dotStyle)
    }, [
      renderSlot(_ctx.$slots, "dot", {}, () => [
        createTextVNode(toDisplayString(_ctx.dot), 1)
      ])
    ], 6),
    createElementVNode("div", _hoisted_3, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
var TimelineItem = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render]]);
const timelinePrefixCls = "ix-timeline";
const itemPrefixCls = "ix-timeline-item";
const _sfc_main = defineComponent({
  name: "IxTimeline",
  props: timelineProps,
  render() {
    var _a, _b, _c, _d, _e, _f;
    const pendingSlots = (_b = (_a = this.$slots) == null ? void 0 : _a.pending) == null ? void 0 : _b.call(_a);
    const pendingDotSlots = (_d = (_c = this.$slots) == null ? void 0 : _c.pendingDot) == null ? void 0 : _d.call(_c);
    const defaultSlots = ((_f = (_e = this.$slots) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e)) || [];
    const pendingNode = pendingSlots || this.$props.pending;
    const pendingDotNode = pendingDotSlots || this.$props.pendingDot || h$1(IxIcon, { name: "loading" });
    let penddingItem = null;
    if (pendingNode) {
      penddingItem = h$1(TimelineItem, { class: `${itemPrefixCls}-pending-dot` }, { default: () => pendingNode, dot: () => pendingDotNode });
    }
    const timelineItems = this.$props.reverse ? [penddingItem, ...defaultSlots.reverse()] : [...defaultSlots, penddingItem];
    const nonNullItems = timelineItems.filter((item) => !!item);
    const itemsLength = nonNullItems.length;
    const items = [];
    const itemPositionArr = [];
    nonNullItems.forEach((item, index) => {
      const position = getItemPosition(item, index, this.$props.position);
      itemPositionArr.push(position);
      items.push(cloneVNode(item, {
        class: useItemClasses({
          hasPendingNode: !!pendingNode,
          position,
          index,
          itemsLength,
          props: this.$props
        })
      }));
    });
    return h$1("ul", {
      class: useClasses(itemPositionArr, this.$props)
    }, items);
  }
});
const getItemPosition = (node, index, position) => {
  var _a;
  const itemPosition = (_a = node.props) == null ? void 0 : _a.position;
  if (itemPosition) {
    return itemPosition;
  }
  if (position === "alternate") {
    return index % 2 ? "left" : "right";
  }
  return position;
};
const getRealPosition = (itemPositionArr) => {
  return itemPositionArr.reduce((result, nextPosition, index) => {
    if (!index) {
      result = nextPosition;
    } else if (result !== nextPosition) {
      result = "alternate";
    }
    return result;
  }, "right");
};
const useClasses = (itemPositionArr, props) => {
  const realPosition = getRealPosition(itemPositionArr);
  const positionCls = `${timelinePrefixCls}-${realPosition}`;
  let cls = `${timelinePrefixCls} ${positionCls}`;
  if (props.reverse) {
    cls += ` ${timelinePrefixCls}-reverse`;
  }
  return cls;
};
const useItemClasses = ({
  hasPendingNode,
  position,
  index,
  itemsLength,
  props
}) => {
  let cls = `${itemPrefixCls}-${position}`;
  if (hasPendingNode) {
    const isReversePending = props.reverse && index === 0;
    const isPending = !props.reverse && index === itemsLength - 2;
    if (isReversePending || isPending) {
      cls += ` ${itemPrefixCls}-pending`;
    }
  }
  return cls;
};
const IxTimeline = _sfc_main;
const IxTimelineItem = TimelineItem;

function callChange(mergedNodeMap, newKeys, onChange) {
  if (onChange) {
    const selectedNodes = [];
    const nodeMap = mergedNodeMap.value;
    newKeys.forEach((key) => {
      const currNode = nodeMap.get(key);
      currNode && selectedNodes.push(currNode.rawNode);
    });
    callEmit(onChange, newKeys, selectedNodes);
  }
}
function getChildrenKeys(currNode, disabledKeys) {
  const keys = [];
  const { children } = currNode || {};
  children && children.forEach((item) => {
    const { key } = item;
    if (!(disabledKeys == null ? void 0 : disabledKeys.includes(key))) {
      keys.push(item.key);
    }
    keys.push(...getChildrenKeys(item, disabledKeys));
  });
  return keys;
}
function getParentKeys(nodeMap, currNode, disabledKeys) {
  const keys = [];
  while (currNode == null ? void 0 : currNode.parentKey) {
    const { parentKey } = currNode;
    if (!(disabledKeys == null ? void 0 : disabledKeys.includes(currNode.parentKey))) {
      keys.push(parentKey);
    }
    currNode = nodeMap.get(parentKey);
  }
  return keys;
}
function useCheckable(props, mergedNodeMap) {
  const [checkedKeys, setCheckedKeys] = useControlledProp(props, "checkedKeys", () => []);
  const checkDisabledKeys = computed(() => {
    const disabledKeys = [];
    if (props.checkable) {
      mergedNodeMap.value.forEach((node, key) => {
        if (node.checkDisabled) {
          disabledKeys.push(key);
        }
      });
    }
    return disabledKeys;
  });
  const allCheckedKeys = computed(() => {
    if (props.cascade) {
      return findAllCheckedKeys(mergedNodeMap.value, checkedKeys.value, checkDisabledKeys.value);
    } else {
      return checkedKeys.value;
    }
  });
  const indeterminateKeys = computed(() => {
    const _checkedKeys = allCheckedKeys.value;
    if (_checkedKeys.length === 0 || !props.cascade) {
      return [];
    }
    const indeterminateKeySet = /* @__PURE__ */ new Set();
    const disabledKeys = checkDisabledKeys.value;
    const nodeMap = mergedNodeMap.value;
    _checkedKeys.forEach((key) => {
      const { parentKey } = nodeMap.get(key) || {};
      if (parentKey) {
        let parent = nodeMap.get(parentKey);
        if (parent && !_checkedKeys.includes(parent.key)) {
          if (!disabledKeys.includes(parentKey)) {
            indeterminateKeySet.add(parentKey);
          }
          while (parent == null ? void 0 : parent.parentKey) {
            if (!disabledKeys.includes(parent.parentKey)) {
              indeterminateKeySet.add(parent.parentKey);
            }
            parent = nodeMap.get(parent.parentKey);
          }
        }
      }
    });
    return [...indeterminateKeySet];
  });
  const handleCheck = (node) => {
    const currKey = node.key;
    const nodeMap = mergedNodeMap.value;
    const disabledKeys = checkDisabledKeys.value;
    const childrenKeys = props.cascade ? getChildrenKeys(node, disabledKeys) : [];
    const index = allCheckedKeys.value.indexOf(currKey);
    const checked = index > -1;
    let tempKeys = [...allCheckedKeys.value];
    if (checked || childrenKeys.length && childrenKeys.every((key) => tempKeys.includes(key) || indeterminateKeys.value.includes(key))) {
      const parentKeys = props.cascade ? getParentKeys(nodeMap, node, disabledKeys) : [];
      tempKeys.splice(index, 1);
      tempKeys = tempKeys.filter((key) => !parentKeys.includes(key) && !childrenKeys.includes(key));
    } else {
      tempKeys.push(currKey);
      props.cascade && setParentChecked(nodeMap, node, tempKeys, disabledKeys);
      tempKeys.push(...childrenKeys);
    }
    tempKeys = [...new Set(tempKeys)];
    if (props.cascade) {
      tempKeys = processAllCheckedKeysByCheckStrategy(nodeMap, tempKeys, disabledKeys, props.checkStrategy);
    }
    handleChange(checked, node.rawNode, tempKeys);
  };
  const handleChange = (checked, rawNode, newKeys) => {
    const { onCheck, onCheckedChange } = props;
    callEmit(onCheck, !checked, rawNode);
    setCheckedKeys(newKeys);
    callChange(mergedNodeMap, newKeys, onCheckedChange);
  };
  return {
    checkedKeys,
    allCheckedKeys,
    checkDisabledKeys,
    indeterminateKeys,
    handleCheck
  };
}
function setParentChecked(dataMap, currNode, tempKeys, disabledKeys) {
  let parentSelected = true;
  while (parentSelected && (currNode == null ? void 0 : currNode.parentKey)) {
    const parent = dataMap.get(currNode.parentKey);
    if (parent && !disabledKeys.includes(currNode.parentKey)) {
      parentSelected = parent.children.every((item) => disabledKeys.includes(item.key) || tempKeys.includes(item.key));
      if (parentSelected) {
        tempKeys.push(currNode.parentKey);
      }
    }
    currNode = parent;
  }
}
function processAllCheckedKeysByCheckStrategy(dataMap, checkedKys, disabledKeys, checkStrategy) {
  let res = [];
  checkedKys = filterCheckedKeysWithDisabled(dataMap, checkedKys, disabledKeys);
  if (disabledKeys.length) {
    res = checkedKys.filter((item) => disabledKeys.includes(item));
  }
  for (const checkedKey of checkedKys) {
    const currNode = dataMap.get(checkedKey);
    if (currNode) {
      const selfKey = currNode.key;
      const parentKey = currNode.parentKey;
      if (checkStrategy === "parent") {
        if (!checkedKys.includes(parentKey)) {
          res.push(selfKey);
        }
      } else if (checkStrategy === "child") {
        if (currNode.isLeaf) {
          res.push(selfKey);
        }
      } else {
        res.push(selfKey);
      }
    }
  }
  return [...new Set(res)];
}
function findAllCheckedKeys(dataMap, checkedKys, disabledKeys) {
  let res = [...checkedKys];
  let lastParentKey;
  for (const checkedKey of checkedKys) {
    const currNode = dataMap.get(checkedKey);
    const parentKey = currNode == null ? void 0 : currNode.parentKey;
    const childrenKeys = getChildrenKeys(currNode, disabledKeys);
    res = res.concat(childrenKeys);
    if (parentKey && lastParentKey !== parentKey) {
      setParentChecked(dataMap, currNode, res, disabledKeys);
      lastParentKey = parentKey;
    }
  }
  res = filterCheckedKeysWithDisabled(dataMap, [...new Set(res)], disabledKeys);
  return res;
}
function filterCheckedKeysWithDisabled(dataMap, tempKeys, disabledKeys) {
  let res = [...tempKeys];
  if (disabledKeys.length) {
    for (const disabledKey of disabledKeys) {
      if (!res.includes(disabledKey)) {
        const currNode = dataMap.get(disabledKey);
        const parentKeys = getParentKeys(dataMap, currNode, disabledKeys);
        res = res.filter((key) => !parentKeys.includes(key));
      }
    }
  }
  return res;
}
function useMergeNodes$1(props, getNodeKey) {
  const mergedNodes = computed(() => covertMergeNodes$1(props, getNodeKey, props.dataSource));
  const mergedNodeMap = computed(() => {
    const map = /* @__PURE__ */ new Map();
    covertMergedNodeMap$1(mergedNodes.value, map);
    return map;
  });
  return { mergedNodes, mergedNodeMap };
}
function useFlattedNodes(mergedNodes, { expandedKeys }) {
  return computed(() => {
    const _expandedKeysMap = new Map(expandedKeys.value.map((item, index) => [item, index]));
    if (_expandedKeysMap.size > 0) {
      const nodes = flatNode(mergedNodes.value, _expandedKeysMap);
      return nodes;
    }
    return mergedNodes.value;
  });
}
function covertMergeNodes$1(props, getNodeKey, nodes, parentKey) {
  const getKey = getNodeKey.value;
  const { childrenKey, labelKey, disabled, loadChildren } = props;
  return nodes.map((node, index) => covertMergeNode$1(node, getKey, disabled, childrenKey, labelKey, !!loadChildren, index === 0, index === nodes.length - 1, -1, parentKey));
}
function covertMergeNode$1(rawNode, getKey, disabled, childrenKey, labelKey, hasLoad, isFirst, isLast, level, parentKey) {
  var _a;
  const key = getKey(rawNode);
  const { check, drag, drop, select } = covertDisabled$1(rawNode, disabled);
  const subNodes = rawNode[childrenKey];
  const label = rawNode[labelKey];
  level++;
  const children = subNodes == null ? void 0 : subNodes.map((subNode, index) => covertMergeNode$1(subNode, getKey, disabled, childrenKey, labelKey, hasLoad, index === 0, index === subNodes.length - 1, level, key));
  return {
    children,
    label,
    key,
    isFirst,
    isLeaf: (_a = rawNode.isLeaf) != null ? _a : !((children == null ? void 0 : children.length) || hasLoad),
    isLast,
    parentKey,
    expanded: false,
    level,
    rawNode,
    checkDisabled: check,
    dragDisabled: drag,
    dropDisabled: drop,
    selectDisabled: select
  };
}
function covertDisabled$1(node, disabled) {
  const nodeDisabled = node.disabled;
  if (isBoolean(nodeDisabled)) {
    return { check: nodeDisabled, drag: nodeDisabled, drop: nodeDisabled, select: nodeDisabled };
  } else {
    let { check, drag, drop, select } = nodeDisabled != null ? nodeDisabled : {};
    if (disabled) {
      const treeDisabled = disabled(node);
      if (isBoolean(treeDisabled)) {
        check != null ? check : check = treeDisabled;
        drag != null ? drag : drag = treeDisabled;
        drop != null ? drop : drop = treeDisabled;
        select != null ? select : select = treeDisabled;
      } else {
        check != null ? check : check = treeDisabled.check;
        drag != null ? drag : drag = treeDisabled.drag;
        drop != null ? drop : drop = treeDisabled.drop;
        select != null ? select : select = treeDisabled.select;
      }
    }
    return { check, drag, drop, select };
  }
}
function covertMergedNodeMap$1(mergedNodes, map) {
  mergedNodes.forEach((item) => {
    const { key, children } = item;
    map.set(key, item);
    if (children) {
      covertMergedNodeMap$1(children, map);
    }
  });
}
function flatNode(mergedNodes, expandedKeysMap) {
  const flattedNodes = [];
  const stack = [];
  mergedNodes.forEach((node) => {
    stack.push(node);
    while (stack.length) {
      const _node = stack.pop();
      if (_node) {
        const { children, key } = _node;
        const expanded = expandedKeysMap.has(key);
        _node.expanded = expanded;
        flattedNodes.push(_node);
        if (children && expanded) {
          for (let i = children.length; i > 0; i--) {
            stack.push(children[i - 1]);
          }
        }
      }
    }
  });
  return flattedNodes;
}
var __async$1$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useDragDrop(props, { expandedKeys }) {
  const dragNodeRef = ref();
  const dragChildrenKeys = ref();
  const dropNodeRef = ref();
  const dropParentKey = ref();
  const dropType = ref();
  let dragTimer;
  const clearTimer = () => {
    if (dragTimer) {
      clearTimeout(dragTimer);
      dragTimer = void 0;
    }
  };
  onBeforeUnmount(() => clearTimer());
  const cleanDragState = () => {
    if (!isNil(dragNodeRef.value)) {
      dragNodeRef.value = void 0;
      dragChildrenKeys.value = void 0;
    }
  };
  const cleanDropState = () => {
    if (!isNil(dropNodeRef.value)) {
      dropNodeRef.value = void 0;
      dropParentKey.value = void 0;
      dropType.value = void 0;
    }
  };
  const getDragDropOptions = (evt, node) => {
    var _a, _b;
    return {
      evt,
      node: node.rawNode,
      dragNode: (_a = dragNodeRef.value) == null ? void 0 : _a.rawNode,
      dropNode: (_b = dropNodeRef.value) == null ? void 0 : _b.rawNode,
      dropType: dropType.value
    };
  };
  const handleWindowDragend = (evt) => {
    handleDragend(evt, void 0);
    window.removeEventListener("dragend", handleWindowDragend);
  };
  const handleDragstart = (evt, node) => {
    dragNodeRef.value = node;
    dragChildrenKeys.value = getChildrenKeys(node);
    delKey(expandedKeys, node.key);
    window.addEventListener("dragend", handleWindowDragend);
    callEmit(props.onDragstart, getDragDropOptions(evt, node));
  };
  const handleDragend = (evt, node) => {
    if (node) {
      callEmit(props.onDragend, getDragDropOptions(evt, node));
    }
    cleanDragState();
    cleanDropState();
  };
  const handleDragenter = (evt, node) => __async$1$1(this, null, function* () {
    const dragNode = dragNodeRef.value;
    if (dragNode) {
      clearTimer();
      if (dragNode.key !== node.key) {
        dragTimer = setTimeout(() => {
          var _a;
          if (dragNodeRef.value && ((_a = node.children) == null ? void 0 : _a.length)) {
            addKey(expandedKeys, node.key);
          }
          dragTimer = void 0;
        }, 1e3);
      }
      const type = yield calcDropType(node, dragNode, dragChildrenKeys.value, evt, props.droppable);
      if (type) {
        dropNodeRef.value = node;
        dropParentKey.value = type !== "inside" ? node.parentKey : void 0;
        dropType.value = type;
      } else {
        cleanDropState();
      }
    }
    callEmit(props.onDragenter, getDragDropOptions(evt, node));
  });
  const handleDragover = (evt, node) => __async$1$1(this, null, function* () {
    const dragNode = dragNodeRef.value;
    if (dragNode) {
      const type = yield calcDropType(node, dragNode, dragChildrenKeys.value, evt, props.droppable);
      if (type) {
        dropNodeRef.value = node;
        dropParentKey.value = type !== "inside" ? node.parentKey : void 0;
        dropType.value = type;
      } else {
        cleanDropState();
      }
    }
    callEmit(props.onDragover, getDragDropOptions(evt, node));
  });
  const handleDragleave = (evt, node) => {
    const dropNode = dropNodeRef.value;
    if ((dropNode == null ? void 0 : dropNode.key) === node.key && !evt.currentTarget.contains(evt.relatedTarget)) {
      cleanDropState();
    }
    callEmit(props.onDragleave, getDragDropOptions(evt, node));
  };
  const handleDrop = (evt, node) => {
    if (!dropType.value) {
      cleanDropState();
    }
    callEmit(props.onDrop, getDragDropOptions(evt, node));
    cleanDragState();
    cleanDropState();
  };
  return {
    dragKey: computed(() => {
      var _a;
      return (_a = dragNodeRef.value) == null ? void 0 : _a.key;
    }),
    dropKey: computed(() => {
      var _a;
      return (_a = dropNodeRef.value) == null ? void 0 : _a.key;
    }),
    dropParentKey,
    dropType,
    handleDragstart,
    handleDragend,
    handleDragenter,
    handleDragover,
    handleDragleave,
    handleDrop
  };
}
function addKey(keysRef, key) {
  const index = keysRef.value.indexOf(key);
  if (index === -1) {
    keysRef.value = [...keysRef.value, key];
  }
}
function delKey(keysRef, key) {
  const index = keysRef.value.indexOf(key);
  if (index !== -1) {
    const tempKeys = [...keysRef.value];
    tempKeys.splice(index, 1);
    keysRef.value = tempKeys;
  }
}
function calcDropType(dropNode, dragNode, dragChildrenKeys, evt, droppable) {
  return __async$1$1(this, null, function* () {
    const { key: dropKey, children: dropChildren = [] } = dropNode;
    if (dragNode.key === dropKey || dragChildrenKeys && dragChildrenKeys.includes(dropKey)) {
      return false;
    }
    const { clientY } = evt;
    const { top, height } = evt.target.getBoundingClientRect();
    const isTopHalf = clientY < top + height / 2;
    const dragRawNode = dragNode.rawNode;
    const dropRawNode = dropNode.rawNode;
    let dropType;
    if (droppable) {
      const dropOptions = { evt, isTopHalf, dragNode: dragRawNode, dropNode: dropRawNode };
      dropType = yield droppable(dropOptions);
    }
    if (dropType === void 0 || dropType === true) {
      if (dropChildren.length > 0) {
        dropType = "inside";
      } else if (isTopHalf) {
        dropType = "before";
      } else {
        dropType = "after";
      }
    }
    return dropType;
  });
}
function useEvents(props, mergedNodeMap, flattedNodes, { expandedKeys, handleExpand }, { activeKey, handleSelect }) {
  const focused = ref(false);
  const handleFocus = (evt) => {
    focused.value = true;
    callEmit(props.onFocus, evt);
  };
  const handleBlur = (evt) => {
    focused.value = true;
    callEmit(props.onBlur, evt);
  };
  const handleKeydown = (evt) => {
    switch (evt.code) {
      case "ArrowUp":
      case "ArrowDown":
        evt.preventDefault();
    }
    callEmit(props.onKeydown, evt);
  };
  const handleKeyup = (evt) => {
    const eventCode = evt.code;
    const _activeKey = activeKey.value;
    const _flattedNodes = flattedNodes.value;
    const nodeSize = _flattedNodes.length;
    if (_activeKey === void 0) {
      if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(eventCode)) {
        changeActiveKey(activeKey, _flattedNodes, 0, nodeSize);
      }
    } else {
      const _flattedNodes2 = flattedNodes.value;
      const currIndex = _flattedNodes2.findIndex((node) => node.key === _activeKey);
      if (currIndex === -1) {
        return;
      }
      switch (eventCode) {
        case "Enter":
        case "NumpadEnter":
          handleSelect(_activeKey);
          break;
        case "ArrowDown":
          changeActiveKey(activeKey, _flattedNodes2, currIndex + 1, nodeSize);
          break;
        case "ArrowUp":
          changeActiveKey(activeKey, _flattedNodes2, currIndex - 1, 0, true);
          break;
        case "ArrowLeft":
          {
            const { rawNode, key, parentKey } = _flattedNodes2[currIndex];
            if (rawNode.isLeaf || !expandedKeys.value.includes(key)) {
              const parentNode = parentKey ? mergedNodeMap.value.get(parentKey) : void 0;
              if (parentNode) {
                activeKey.value = parentNode.key;
              }
            } else {
              handleExpand(key, rawNode);
            }
          }
          break;
        case "ArrowRight":
          {
            const { rawNode, key } = _flattedNodes2[currIndex];
            if (!expandedKeys.value.includes(key)) {
              handleExpand(key, rawNode);
            } else {
              for (let index = currIndex + 1; index < nodeSize; index++) {
                const currNode = _flattedNodes2[index];
                activeKey.value = currNode.key;
                break;
              }
            }
          }
          break;
      }
    }
    callEmit(props.onKeyup, evt);
  };
  return {
    focused,
    handleFocus,
    handleBlur,
    handleKeydown,
    handleKeyup
  };
}
function changeActiveKey(activeKey, flattedNodes, start, end, isUp = false) {
  let index = start;
  while (isUp ? index >= end : index < end) {
    const currNode = flattedNodes[index];
    if (!currNode.selectDisabled) {
      activeKey.value = currNode.key;
      return;
    } else {
      isUp ? index-- : index++;
    }
  }
}
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useExpandable(props, config, getNodeKey, mergedNodeMap, searchedKeys, lastEffectiveSearchedKeys) {
  const expandIcon = computed(() => {
    var _a;
    return (_a = props.expandIcon) != null ? _a : config.expandIcon;
  });
  const [expandedKeys, setExpandedKeys] = useControlledProp(props, "expandedKeys", () => []);
  const [loadedKeys, setLoadedKeys] = useControlledProp(props, "loadedKeys", () => []);
  const loadingKeys = ref([]);
  watch(searchedKeys, (currKeys) => {
    const { searchValue } = props;
    setExpandWithSearch(!searchValue ? lastEffectiveSearchedKeys.value : currKeys);
  });
  const setExpandWithSearch = (searchedKeys2) => {
    const { onExpandedChange } = props;
    const nodeMap = mergedNodeMap.value;
    const keySet = /* @__PURE__ */ new Set();
    searchedKeys2.forEach((key) => {
      getParentKeys(nodeMap, nodeMap.get(key)).forEach((parentKey) => keySet.add(parentKey));
    });
    const newKeys = [...keySet];
    setExpandedKeys(newKeys);
    callChange(mergedNodeMap, newKeys, onExpandedChange);
  };
  const handleExpand = (key, rawNode) => __async$4(this, null, function* () {
    var _a;
    const { childrenKey, loadChildren } = props;
    if (loadingKeys.value.includes(key)) {
      return;
    }
    if (!((_a = rawNode == null ? void 0 : rawNode[childrenKey]) == null ? void 0 : _a.length)) {
      if (!loadChildren || loadingKeys.value.includes(key) || loadedKeys.value.includes(key)) {
        return;
      }
      loadingKeys.value.push(key);
      const childrenNodes = yield loadChildren(rawNode);
      loadingKeys.value.splice(loadingKeys.value.indexOf(key), 1);
      const nodeMap = mergedNodeMap.value;
      const currNode = nodeMap.get(key);
      if (childrenNodes.length) {
        const mergedChildren = covertMergeNodes$1(props, getNodeKey, childrenNodes, key);
        covertMergedNodeMap$1(mergedChildren, nodeMap);
        currNode.rawNode[childrenKey] = childrenNodes;
        currNode.children = mergedChildren;
        const newLoadedKeys = [...loadedKeys.value, key];
        setLoadedKeys(newLoadedKeys);
        callEmit(props.onLoaded, newLoadedKeys, rawNode);
      } else {
        return;
      }
    }
    const index = expandedKeys.value.indexOf(key);
    const expanded = index >= 0;
    const tempKeys = [...expandedKeys.value];
    expanded ? tempKeys.splice(index, 1) : tempKeys.push(key);
    handleChange(expanded, rawNode, tempKeys);
  });
  const handleChange = (expanded, rawNode, newKeys) => {
    const { onExpand, onExpandedChange } = props;
    callEmit(onExpand, !expanded, rawNode);
    setExpandedKeys(newKeys);
    callChange(mergedNodeMap, newKeys, onExpandedChange);
  };
  if (searchedKeys.value.length) {
    setExpandWithSearch(searchedKeys.value);
  }
  return { expandIcon, expandedKeys, handleExpand, loadingKeys };
}
function useGetNodeKey$1(props, config) {
  return computed(() => {
    var _a;
    const nodeKey = (_a = props.nodeKey) != null ? _a : config.nodeKey;
    if (isString(nodeKey)) {
      return (rawNode) => {
        const key = rawNode[nodeKey];
        if (process.env.NODE_ENV !== "production" && key === void 0) {
          Logger.warn("components/tree", "Each node in tree should have a unique `key` prop.");
        }
        return key;
      };
    }
    return nodeKey;
  });
}
const defaultSearchedKeys = [];
function useSearchable(props, mergedNodeMap) {
  const lastEffectiveSearchedKeys = ref([]);
  const searchedKeys = computed(() => {
    const { searchValue, searchFn } = props;
    if (!searchValue && !searchFn) {
      return defaultSearchedKeys;
    }
    const keys = [];
    mergedNodeMap.value.forEach((node) => {
      if (checkNodeIsMatched(node.rawNode, searchValue, searchFn)) {
        keys.push(node.key);
      }
    });
    if (keys.length) {
      lastEffectiveSearchedKeys.value = keys;
    }
    return keys;
  });
  watch(searchedKeys, (currKeys) => callChange(mergedNodeMap, currKeys, props.onSearchedChange));
  return { searchedKeys, lastEffectiveSearchedKeys };
}
function checkNodeIsMatched(node, searchValue, searchFn) {
  if (searchFn) {
    return searchFn(node, searchValue);
  }
  if (!searchValue || !node.label) {
    return false;
  }
  return node.label.toLowerCase().includes(searchValue.toLowerCase());
}
function useSelectable(props, mergedNodeMap) {
  const [selectedKeys, setSelectedKeys] = useControlledProp(props, "selectedKeys", () => []);
  const isMultiple = computed(() => props.selectable === "multiple");
  const activeKey = ref();
  watchEffect(() => {
    const currKeys = selectedKeys.value;
    const keySize = currKeys.length;
    activeKey.value = keySize > 0 ? currKeys[keySize - 1] : void 0;
  });
  const activeNode = computed(() => {
    const currKey = activeKey.value;
    return currKey !== void 0 ? mergedNodeMap.value.get(currKey) : void 0;
  });
  const handleSelect = (key) => {
    const nodeMap = mergedNodeMap.value;
    const currNode = nodeMap.get(key);
    if (!currNode) {
      return;
    }
    const index = selectedKeys.value.indexOf(key);
    const selected = index > -1;
    let tempKeys = [...selectedKeys.value];
    if (isMultiple.value) {
      selected ? tempKeys.splice(index, 1) : tempKeys.push(key);
    } else {
      tempKeys = selected ? [] : [key];
    }
    handleChange(selected, currNode.rawNode, tempKeys);
  };
  const handleChange = (selected, rawNode, newKeys) => {
    const { onSelect, onSelectedChange } = props;
    callEmit(onSelect, !selected, rawNode);
    setSelectedKeys(newKeys);
    callChange(mergedNodeMap, newKeys, onSelectedChange);
  };
  return { activeKey, activeNode, selectedKeys, handleSelect };
}
const treeToken = Symbol("treeToken");
const treeProps = {
  checkedKeys: IxPropTypes.array(),
  expandedKeys: IxPropTypes.array(),
  indeterminateKeys: IxPropTypes.array(),
  loadedKeys: IxPropTypes.array(),
  selectedKeys: IxPropTypes.array(),
  blocked: IxPropTypes.bool,
  cascade: IxPropTypes.bool.def(false),
  checkable: IxPropTypes.bool.def(false),
  childrenKey: IxPropTypes.string.def("children"),
  checkStrategy: IxPropTypes.oneOf(["all", "parent", "child"]).def("all"),
  dataSource: IxPropTypes.array().def(() => []),
  disabled: IxPropTypes.func(),
  draggable: IxPropTypes.bool.def(false),
  droppable: IxPropTypes.func(),
  empty: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  expandIcon: IxPropTypes.string,
  height: IxPropTypes.number,
  labelKey: IxPropTypes.string.def("label"),
  leafLineIcon: IxPropTypes.string,
  loadChildren: IxPropTypes.func(),
  nodeKey: IxPropTypes.oneOfType([String, IxPropTypes.func()]),
  searchFn: IxPropTypes.func(),
  searchValue: IxPropTypes.string,
  selectable: IxPropTypes.oneOfType([Boolean, IxPropTypes.oneOf(["multiple"])]).def(true),
  showLine: IxPropTypes.bool,
  virtual: IxPropTypes.bool.def(false),
  "onUpdate:checkedKeys": IxPropTypes.emit(),
  "onUpdate:expandedKeys": IxPropTypes.emit(),
  "onUpdate:loadedKeys": IxPropTypes.emit(),
  "onUpdate:selectedKeys": IxPropTypes.emit(),
  onCheck: IxPropTypes.emit(),
  onCheckedChange: IxPropTypes.emit(),
  onDragstart: IxPropTypes.emit(),
  onDragend: IxPropTypes.emit(),
  onDragenter: IxPropTypes.emit(),
  onDragleave: IxPropTypes.emit(),
  onDragover: IxPropTypes.emit(),
  onDrop: IxPropTypes.emit(),
  onExpand: IxPropTypes.emit(),
  onExpandedChange: IxPropTypes.emit(),
  onLoaded: IxPropTypes.emit(),
  onSearchedChange: IxPropTypes.emit(),
  onSelect: IxPropTypes.emit(),
  onSelectedChange: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onKeydown: IxPropTypes.emit(),
  onKeyup: IxPropTypes.emit(),
  onNodeClick: IxPropTypes.emit(),
  onNodeContextmenu: IxPropTypes.emit(),
  onScroll: IxPropTypes.emit(),
  onScrolledChange: IxPropTypes.emit(),
  onScrolledBottom: IxPropTypes.emit()
};
({
  expanded: IxPropTypes.bool,
  expandedNodes: IxPropTypes.array(),
  node: IxPropTypes.object(),
  prefixCls: IxPropTypes.string.isRequired
});
const treeNodeProps = {
  node: IxPropTypes.object().isRequired,
  isLeaf: IxPropTypes.bool.isRequired,
  isFirst: IxPropTypes.bool.isRequired,
  isLast: IxPropTypes.bool.isRequired,
  label: IxPropTypes.string.isRequired,
  level: IxPropTypes.number.isRequired,
  rawNode: IxPropTypes.object().isRequired,
  expanded: IxPropTypes.bool.isRequired,
  children: IxPropTypes.array(),
  parentKey: IxPropTypes.oneOfType([String, Number, Symbol]),
  checkDisabled: IxPropTypes.bool,
  dragDisabled: IxPropTypes.bool,
  dropDisabled: IxPropTypes.bool,
  selectDisabled: IxPropTypes.bool
};
const treeNodeCheckboxProps = {
  node: IxPropTypes.object().isRequired,
  checkDisabled: IxPropTypes.bool
};
const treeNodeExpandProps = {
  expanded: IxPropTypes.bool.isRequired,
  hasTopLine: IxPropTypes.bool,
  isLeaf: IxPropTypes.bool,
  nodeKey: IxPropTypes.oneOfType([String, Number, Symbol]).isRequired,
  rawNode: IxPropTypes.object().isRequired
};
const treeNodeContentProps = {
  disabled: IxPropTypes.bool,
  nodeKey: IxPropTypes.oneOfType([String, Number, Symbol]).isRequired,
  label: IxPropTypes.string.isRequired,
  rawNode: IxPropTypes.object().isRequired,
  selected: IxPropTypes.bool
};
var Checkbox = defineComponent({
  props: treeNodeCheckboxProps,
  setup(props) {
    const {
      mergedPrefixCls,
      allCheckedKeys,
      indeterminateKeys,
      handleCheck
    } = inject(treeToken);
    const isChecked = computed(() => {
      return allCheckedKeys.value.includes(props.node.key);
    });
    const isIndeterminate = computed(() => indeterminateKeys.value.includes(props.node.key));
    const onChange = () => handleCheck(props.node);
    return () => createVNode(IxCheckbox, {
      "class": `${mergedPrefixCls.value}-node-checkbox`,
      "checked": isChecked.value,
      "disabled": props.checkDisabled,
      "indeterminate": isIndeterminate.value,
      "onChange": onChange
    }, null);
  }
});
var Content$1 = defineComponent({
  props: treeNodeContentProps,
  setup(props) {
    const {
      props: treeProps2,
      mergedPrefixCls,
      slots,
      handleSelect,
      searchedKeys
    } = inject(treeToken);
    const searched = computed(() => searchedKeys.value.includes(props.nodeKey));
    const onClick = (evt) => {
      if (!props.disabled) {
        handleSelect(props.nodeKey);
      }
      callEmit(treeProps2.onNodeClick, evt, props.rawNode);
    };
    const onContextmenu = (evt) => {
      callEmit(treeProps2.onNodeContextmenu, evt, props.rawNode);
    };
    return () => {
      var _a, _b;
      const {
        nodeKey,
        label,
        rawNode,
        selected
      } = props;
      const {
        prefix,
        suffix
      } = rawNode;
      const iconProps = {
        key: nodeKey,
        selected,
        node: rawNode
      };
      const prefixIcon = ((_a = slots.prefix) == null ? void 0 : _a.call(slots, iconProps)) || prefix && createVNode(IxIcon, {
        "name": prefix
      }, null);
      const suffixIcon = ((_b = slots.suffix) == null ? void 0 : _b.call(slots, iconProps)) || suffix && createVNode(IxIcon, {
        "name": suffix
      }, null);
      const prefixCls = `${mergedPrefixCls.value}-node-content`;
      return createVNode("span", {
        "class": prefixCls,
        "onClick": onClick,
        "onContextmenu": onContextmenu
      }, [prefixIcon && createVNode("span", {
        "class": `${prefixCls}-prefix`
      }, [prefixIcon]), createVNode("span", {
        "class": `${prefixCls}-label`
      }, [renderLabel(slots.label, label, rawNode, treeProps2.searchValue, searched.value, prefixCls)]), suffixIcon && createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [suffixIcon])]);
    };
  }
});
function renderLabel(labelSlot, label, node, searchValue, searched, prefixCls) {
  if (labelSlot) {
    return labelSlot({
      node,
      searchValue,
      searched
    });
  }
  if (searched && label && searchValue) {
    const index = label.indexOf(searchValue);
    if (index > -1) {
      const beforeLabel = label.substr(0, index);
      const afterLabel = label.substr(index + searchValue.length);
      const highlightLabel = createVNode("span", {
        "class": `${prefixCls}-label-highlight`
      }, [searchValue]);
      return [beforeLabel, highlightLabel, afterLabel];
    }
  }
  return label;
}
var Expand = defineComponent({
  props: treeNodeExpandProps,
  setup(props) {
    const {
      mergedPrefixCls,
      slots,
      expandIcon,
      loadingKeys,
      handleExpand
    } = inject(treeToken);
    const isLoading = computed(() => loadingKeys.value.includes(props.nodeKey));
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-node-expand`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-noop`]: props.isLeaf
      });
    });
    const onClick = (evt) => {
      handleExpand(props.nodeKey, props.rawNode);
      evt.stopPropagation();
    };
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-node-expand`;
      let children;
      if (isLoading.value) {
        children = createVNode(IxIcon, {
          "name": "loading"
        }, null);
      } else if (!props.isLeaf) {
        if (slots.expandIcon) {
          const {
            nodeKey: key,
            expanded,
            rawNode: node
          } = props;
          children = slots.expandIcon({
            key,
            expanded,
            node
          });
        } else {
          children = createVNode(IxIcon, {
            "name": expandIcon.value,
            "rotate": props.expanded ? 90 : 0
          }, null);
        }
      }
      return createVNode("span", {
        "class": classes.value,
        "onClick": onClick
      }, [props.hasTopLine && createVNode("div", {
        "class": `${prefixCls}-top-line`
      }, null), children]);
    };
  }
});
const Indent = ({
  level,
  noopIdentUnitArr,
  prefixCls
}) => {
  const children = [];
  for (let index = 0; index < level; index++) {
    children.push(createVNode("span", {
      "key": index,
      "class": noopIdentUnitArr.includes(index) ? `${prefixCls}-node-indent-noop-unit` : `${prefixCls}-node-indent-unit`
    }, null));
  }
  return createVNode("span", {
    "aria-hidden": true,
    "class": `${prefixCls}-node-indent`
  }, [children]);
};
var LeafLine = defineComponent({
  setup() {
    const {
      props,
      mergedPrefixCls,
      slots
    } = inject(treeToken);
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-node-leaf`;
      let children;
      if (slots.leafLineIcon) {
        children = slots.leafLineIcon();
      } else if (props.leafLineIcon) {
        children = createVNode(IxIcon, {
          "name": props.leafLineIcon
        }, null);
      } else {
        children = createVNode("span", {
          "class": `${prefixCls}-line`
        }, null);
      }
      return createVNode("span", {
        "class": prefixCls
      }, [children]);
    };
  }
});
var TreeNode = defineComponent({
  props: treeNodeProps,
  setup(props) {
    const {
      props: treeProps2,
      mergedPrefixCls,
      mergedNodeMap,
      activeKey,
      selectedKeys,
      dragKey,
      dropKey,
      dropParentKey,
      dropType,
      handleDragstart,
      handleDragend,
      handleDragenter,
      handleDragover,
      handleDragleave,
      handleDrop
    } = inject(treeToken);
    const key = useKey();
    const isActive = computed(() => activeKey.value === key);
    const isLast = computed(() => treeProps2.showLine && props.isLast);
    const hasTopLine = computed(() => treeProps2.showLine && !props.isLeaf && props.level !== 0 && props.isFirst);
    const selected = computed(() => selectedKeys.value.includes(key));
    const disabled = computed(() => props.selectDisabled || !treeProps2.selectable);
    const dragging = computed(() => dragKey.value === key);
    const dropping = computed(() => dropKey.value === key);
    const dropParent = computed(() => dropParentKey.value === key);
    const dropBefore = computed(() => dropping.value && dropType.value === "before");
    const dropInside = computed(() => dropping.value && dropType.value === "inside");
    const dropAfter = computed(() => dropping.value && dropType.value === "after");
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-node`;
      return {
        [prefixCls]: true,
        [`${prefixCls}-active`]: isActive.value,
        [`${prefixCls}-last`]: isLast.value,
        [`${prefixCls}-disabled`]: disabled.value,
        [`${prefixCls}-selected`]: selected.value,
        [`${prefixCls}-expanded`]: props.expanded,
        [`${prefixCls}-dragging`]: dragging.value,
        [`${prefixCls}-dropping`]: dropping.value,
        [`${prefixCls}-drop-parent`]: dropParent.value,
        [`${prefixCls}-drop-before`]: dropBefore.value,
        [`${prefixCls}-drop-inside`]: dropInside.value,
        [`${prefixCls}-drop-after`]: dropAfter.value
      };
    });
    const onDragstart = (evt) => {
      var _a;
      evt.stopPropagation();
      handleDragstart(evt, props.node);
      (_a = evt.dataTransfer) == null ? void 0 : _a.setData("text/plain", "");
    };
    const onDragend = (evt) => {
      evt.stopPropagation();
      handleDragend(evt, props.node);
    };
    const onDragenter = (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      handleDragenter(evt, props.node);
    };
    const onDragover = (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      handleDragover(evt, props.node);
    };
    const onDragleave = (evt) => {
      evt.stopPropagation();
      handleDragleave(evt, props.node);
    };
    const onDrop = (evt) => {
      evt.stopPropagation();
      handleDrop(evt, props.node);
    };
    return () => {
      const nodeMap = mergedNodeMap.value;
      const {
        isLeaf,
        label,
        level,
        rawNode,
        expanded,
        checkDisabled,
        dragDisabled,
        dropDisabled,
        node
      } = props;
      const {
        showLine,
        checkable,
        draggable
      } = treeProps2;
      const mergedDraggable = draggable && !dragDisabled;
      const currNode = nodeMap.get(key);
      const noopIdentUnitArr = [];
      if (treeProps2.showLine) {
        getParentKeys(nodeMap, currNode).reverse().forEach((parentKey, index) => {
          var _a;
          if ((_a = nodeMap.get(parentKey)) == null ? void 0 : _a.isLast) {
            noopIdentUnitArr.push(index);
          }
        });
      }
      return createVNode("div", mergeProps(rawNode.additional, {
        "class": classes.value,
        "aria-grabbed": dragging.value || void 0,
        "draggable": mergedDraggable || void 0,
        "onDragstart": mergedDraggable ? onDragstart : void 0,
        "onDragend": mergedDraggable ? onDragend : void 0,
        "onDragenter": mergedDraggable ? onDragenter : void 0,
        "onDragover": mergedDraggable ? onDragover : void 0,
        "onDragleave": mergedDraggable ? onDragleave : void 0,
        "onDrop": mergedDraggable && !dropDisabled ? onDrop : void 0
      }), [createVNode(Indent, {
        "level": level,
        "noopIdentUnitArr": noopIdentUnitArr,
        "prefixCls": mergedPrefixCls.value
      }, null), isLeaf && showLine ? createVNode(LeafLine, null, null) : createVNode(Expand, {
        "expanded": expanded,
        "hasTopLine": hasTopLine.value,
        "isLeaf": isLeaf,
        "nodeKey": key,
        "rawNode": rawNode
      }, null), checkable && createVNode(Checkbox, {
        "checkDisabled": checkDisabled,
        "node": node
      }, null), createVNode(Content$1, {
        "disabled": disabled.value,
        "nodeKey": key,
        "label": label,
        "rawNode": rawNode,
        "selected": selected.value
      }, null)]);
    };
  }
});
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
const hiddenStyle = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var Tree = defineComponent({
  name: "IxTree",
  props: treeProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-tree`);
    const config = useGlobalConfig$1("tree");
    const getNodeKey = useGetNodeKey$1(props, config);
    const {
      mergedNodes,
      mergedNodeMap
    } = useMergeNodes$1(props, getNodeKey);
    const {
      searchedKeys,
      lastEffectiveSearchedKeys
    } = useSearchable(props, mergedNodeMap);
    const expandableContext = useExpandable(props, config, getNodeKey, mergedNodeMap, searchedKeys, lastEffectiveSearchedKeys);
    const flattedNodes = useFlattedNodes(mergedNodes, expandableContext);
    const checkableContext = useCheckable(props, mergedNodeMap);
    const dragDropContext = useDragDrop(props, expandableContext);
    const selectableContext = useSelectable(props, mergedNodeMap);
    provide(treeToken, __spreadValues$5(__spreadValues$5(__spreadValues$5(__spreadValues$5({
      props,
      slots,
      config,
      mergedPrefixCls,
      mergedNodeMap,
      getNodeKey,
      searchedKeys
    }, checkableContext), expandableContext), dragDropContext), selectableContext));
    const inputRef = ref();
    const virtualScrollRef = ref();
    const {
      activeKey
    } = selectableContext;
    const {
      focused,
      handleFocus,
      handleBlur,
      handleKeydown,
      handleKeyup
    } = useEvents(props, mergedNodeMap, flattedNodes, expandableContext, selectableContext);
    const classes = computed(() => {
      const prefixCls = mergedPrefixCls.value;
      const {
        blocked = config.blocked,
        showLine = config.showLine
      } = props;
      return {
        [prefixCls]: true,
        [`${prefixCls}-active`]: activeKey.value !== void 0,
        [`${prefixCls}-blocked`]: blocked,
        [`${prefixCls}-focused`]: focused.value,
        [`${prefixCls}-show-line`]: showLine
      };
    });
    const accessibilityPath = computed(() => {
      var _a, _b;
      const _activeKey = activeKey.value;
      if (isNil(_activeKey)) {
        return "";
      }
      const nodeMap = mergedNodeMap.value;
      let path = String(_activeKey);
      let parentKey = (_a = nodeMap.get(_activeKey)) == null ? void 0 : _a.parentKey;
      while (parentKey) {
        path = `${String(parentKey)} > ${path}`;
        parentKey = (_b = nodeMap.get(parentKey)) == null ? void 0 : _b.parentKey;
      }
      return path;
    });
    const focus = (options) => {
      var _a;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus(options);
    };
    const blur = () => {
      var _a;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
    };
    const scrollTo = (option) => {
      var _a;
      (_a = virtualScrollRef == null ? void 0 : virtualScrollRef.value) == null ? void 0 : _a.scrollTo(option);
    };
    expose({
      focus,
      blur,
      scrollTo
    });
    const handleScrolledChange = (startIndex, endIndex, visibleNodes) => {
      callEmit(props.onScrolledChange, startIndex, endIndex, visibleNodes.map((item) => item.rawNode));
    };
    return () => {
      var _a;
      const nodes = flattedNodes.value;
      let children;
      if (nodes.length > 0) {
        const itemRender = ({
          item
        }) => createVNode(TreeNode, mergeProps({
          "node": item
        }, item), null);
        const {
          height,
          virtual,
          onScroll,
          onScrolledBottom
        } = props;
        children = createVNode(CdkVirtualScroll, {
          "ref": virtualScrollRef,
          "dataSource": nodes,
          "height": height,
          "itemHeight": 28,
          "itemKey": "key",
          "itemRender": itemRender,
          "virtual": virtual,
          "onScroll": onScroll,
          "onScrolledBottom": onScrolledBottom,
          "onScrolledChange": handleScrolledChange
        }, null);
      } else {
        children = createVNode(\u0275Empty, {
          "empty": props.empty
        }, slots);
      }
      return createVNode("div", {
        "class": classes.value,
        "role": "tree"
      }, [focused.value && createVNode("span", {
        "style": hiddenStyle,
        "aria-live": "assertive"
      }, [accessibilityPath.value]), createVNode("input", {
        "ref": inputRef,
        "style": hiddenStyle,
        "tabindex": (_a = attrs.tabIndex) != null ? _a : 0,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onKeydown": handleKeydown,
        "onKeyup": handleKeyup,
        "value": "",
        "aria-label": "for screen reader"
      }, null), children]);
    };
  }
});
const IxTree = Tree;

function useMergeNodes(props, getNodeKey, config) {
  const mergedNodeMap = computed(() => {
    const map = /* @__PURE__ */ new Map();
    const nodes = covertMergeNodes(props, getNodeKey, props.dataSource, config);
    covertMergedNodeMap(nodes, map);
    return map;
  });
  return { mergedNodeMap };
}
function covertMergeNodes(props, getNodeKey, nodes, config, parentKey) {
  const getKey = getNodeKey.value;
  const { childrenKey = config.childrenKey, labelKey = config.labelKey, treeDisabled, loadChildren } = props;
  return nodes.map((option) => covertMergeNode(option, getKey, treeDisabled, childrenKey, labelKey, !!loadChildren, parentKey));
}
function covertMergeNode(rawNode, getKey, disabled, childrenKey, labelKey, hasLoad, parentKey) {
  var _a;
  const key = getKey(rawNode);
  const { check, drag, drop, select } = covertDisabled(rawNode, disabled);
  const subNodes = rawNode[childrenKey];
  const label = rawNode[labelKey];
  const children = subNodes == null ? void 0 : subNodes.map((subNode) => covertMergeNode(subNode, getKey, disabled, childrenKey, labelKey, hasLoad, key));
  return {
    children,
    label,
    key,
    isLeaf: (_a = rawNode.isLeaf) != null ? _a : !((children == null ? void 0 : children.length) || hasLoad),
    parentKey,
    rawNode,
    checkDisabled: check,
    dragDisabled: drag,
    dropDisabled: drop,
    selectDisabled: select
  };
}
function covertDisabled(option, disabled) {
  const optionDisabled = option.disabled;
  if (isBoolean(optionDisabled)) {
    return { check: optionDisabled, drag: optionDisabled, drop: optionDisabled, select: optionDisabled };
  } else {
    let { drag, drop, select } = optionDisabled != null ? optionDisabled : {};
    let check;
    if (disabled) {
      const treeDisabled = disabled(option);
      if (isBoolean(treeDisabled)) {
        check != null ? check : check = treeDisabled;
        drag != null ? drag : drag = treeDisabled;
        drop != null ? drop : drop = treeDisabled;
        select != null ? select : select = treeDisabled;
      } else {
        drag != null ? drag : drag = treeDisabled.drag;
        drop != null ? drop : drop = treeDisabled.drop;
        select != null ? select : select = treeDisabled.select;
        check != null ? check : check = treeDisabled.select;
      }
    }
    return { check, drag, drop, select };
  }
}
function covertMergedNodeMap(MergedNodes, map) {
  MergedNodes.forEach((item) => {
    const { key, children } = item;
    map.set(key, item);
    if (children) {
      covertMergedNodeMap(children, map);
    }
  });
}
function useGetNodeKey(props, config) {
  return computed(() => {
    var _a;
    const nodeKey = (_a = props.nodeKey) != null ? _a : config.nodeKey;
    if (isString(nodeKey)) {
      return (rawNode) => {
        const key = rawNode[nodeKey];
        if (process.env.NODE_ENV !== "production" && key === void 0) {
          Logger.warn("components/treeSelect", "Each data in dataSource should have a unique `key` prop.");
        }
        return key;
      };
    }
    return nodeKey;
  });
}
function useInputState(props, inputRef, accessor, searchValue) {
  const mirrorRef = ref();
  const inputWidth = ref("");
  const isFocused = ref(false);
  const syncMirrorWidth = () => {
    if (props.multiple) {
      const inputElement = inputRef.value;
      const mirrorElement = mirrorRef.value;
      if (inputElement && mirrorElement) {
        mirrorElement.innerText = ` ${inputElement.value}`;
        inputWidth.value = `${mirrorElement.scrollWidth}px`;
      }
    }
  };
  const handleInput = (evt) => {
    if (props.searchable === true) {
      const { value } = evt.target;
      if (value !== searchValue.value) {
        searchValue.value = value;
      }
      syncMirrorWidth();
    }
  };
  const handleFocus = (evt) => {
    isFocused.value = true;
    callEmit(props.onFocus, evt);
  };
  const handleBlur = (evt) => {
    var _a;
    isFocused.value = false;
    callEmit(props.onBlur, evt);
    (_a = accessor.markAsBlurred) == null ? void 0 : _a.call(accessor);
  };
  const clearInput = () => {
    const inputElement = inputRef.value;
    if (inputElement) {
      inputElement.value = "";
    }
    searchValue.value = "";
    syncMirrorWidth();
  };
  onMounted(() => syncMirrorWidth());
  return {
    mirrorRef,
    inputWidth,
    isFocused,
    handleInput,
    handleFocus,
    handleBlur,
    clearInput
  };
}
function useOverlayProps(props, triggerRef) {
  const overlayRef = ref();
  const overlayWidth = ref();
  const overlayStyle = computed(() => ({ width: overlayWidth.value }));
  const [overlayOpened, setOverlayOpened] = useControlledProp(props, "open", false);
  const updatePopper = () => {
    var _a, _b;
    overlayWidth.value = convertCssPixel((_a = triggerRef.value) == null ? void 0 : _a.getBoundingClientRect().width);
    (_b = overlayRef.value) == null ? void 0 : _b.updatePopper();
  };
  onMounted(() => {
    if (props.autofocus) {
      setOverlayOpened(true);
    }
    watchEffect(() => {
      if (overlayOpened.value) {
        updatePopper();
      }
    });
    onResize(triggerRef.value, updatePopper);
  });
  onBeforeUnmount(() => {
    offResize(triggerRef.value, updatePopper);
  });
  return { overlayRef, overlayStyle, overlayOpened, setOverlayOpened };
}
function useSelectedState(props, accessor, mergedNodeMap) {
  const selectedValue = computed(() => convertArray(accessor.valueRef.value));
  const selectedNodes = computed(() => {
    const nodesMap = mergedNodeMap.value;
    return selectedValue.value.map((value) => nodesMap.get(value)).filter(Boolean);
  });
  const setValue = (value, nodes) => {
    const currValue = props.multiple ? value : value[0];
    const node = props.multiple ? nodes : nodes == null ? void 0 : nodes[0];
    const oldValue = toRaw(accessor.valueRef.value);
    if (currValue !== oldValue) {
      accessor.setValue(currValue);
      callEmit(props.onChange, currValue, oldValue, node);
    }
  };
  const changeSelected = (value, nodes) => {
    setValue(value, nodes);
  };
  const handleItemRemove = (key) => {
    setValue(selectedValue.value.filter((item) => key !== item));
  };
  const handleClear = (evt) => {
    evt.stopPropagation();
    setValue([]);
    callEmit(props.onClear, evt);
  };
  return {
    selectedValue,
    selectedNodes,
    changeSelected,
    handleItemRemove,
    handleClear
  };
}
const treeSelectToken = Symbol("treeSelectToken");
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Content = defineComponent({
  setup() {
    const {
      config,
      props,
      slots: treeSelectSlots,
      getNodeKey,
      mergedPrefixCls,
      mergedNodeMap,
      selectedValue,
      searchValue,
      expandedKeys,
      treeRef,
      setExpandedKeys,
      setExpandAll,
      changeSelected,
      handleNodeClick
    } = inject(treeSelectToken);
    const [loadedKeys, setLoadedKeys] = useControlledProp(props, "loadedKeys", () => []);
    const expandAllBtnStatus = ref(false);
    const handleScrolledChange = (startIndex, endIndex, visibleNodes) => {
      const {
        onScrolledChange
      } = props;
      callEmit(onScrolledChange, startIndex, endIndex, visibleNodes.map((item) => item.rawNode));
    };
    const handleClick = (evt) => {
      evt.stopPropagation();
    };
    const handleCheck = (checked, node) => {
      const {
        onCheck
      } = props;
      callEmit(onCheck, checked, node);
      handleNodeClick();
    };
    const handleSelect = (selected, node) => {
      const {
        onSelect
      } = props;
      callEmit(onSelect, selected, node);
      handleNodeClick();
    };
    const handleExpand = (expanded, node) => {
      const {
        onExpand
      } = props;
      callEmit(onExpand, expanded, node);
    };
    const handleExpandedChange = (expendedKeys, expendedNodes) => {
      const {
        onExpandedChange
      } = props;
      callEmit(onExpandedChange, expendedKeys, expendedNodes);
      setExpandedKeys(expendedKeys);
    };
    const handleExpandAll = (evt) => {
      const currStatus = expandAllBtnStatus.value;
      setExpandAll(!currStatus);
      expandAllBtnStatus.value = !currStatus;
      evt.stopPropagation();
    };
    const onLoaded = (loadedKeys2, node) => __async$3(this, null, function* () {
      var _a;
      const childrenNodes = (_a = node.children) != null ? _a : [];
      const key = node.key;
      const nodeMap = mergedNodeMap.value;
      const currNode = nodeMap.get(key);
      if (childrenNodes.length && currNode) {
        const mergedChildren = covertMergeNodes(props, getNodeKey, childrenNodes, config, key);
        covertMergedNodeMap(mergedChildren, nodeMap);
        currNode.rawNode.children = childrenNodes;
        currNode.children = mergedChildren;
        setLoadedKeys(loadedKeys2);
        callEmit(props.onLoaded, loadedKeys2, node);
      }
    });
    const handleSearchInput = (evt) => {
      const {
        value
      } = evt.target;
      if (value !== searchValue.value) {
        searchValue.value = value;
      }
    };
    const handleSearchClear = (evt) => {
      searchValue.value = "";
      evt.stopPropagation();
    };
    const checkable = computed(() => props.multiple && props.checkable);
    const cascade = computed(() => checkable.value && props.cascade);
    return () => {
      const {
        checkStrategy,
        childrenKey,
        dataSource,
        draggable,
        empty,
        expandIcon,
        multiple,
        nodeKey,
        leafLineIcon,
        labelKey,
        virtual,
        searchable,
        showLine,
        onDragstart,
        onDragend,
        onDragenter,
        onDragleave,
        onDragover,
        onDrop,
        onNodeClick,
        onNodeContextmenu,
        onScroll,
        onScrolledBottom,
        onSearchedChange,
        droppable,
        treeDisabled,
        loadChildren,
        searchFn,
        overlayRender,
        overlayHeight
      } = props;
      const prefixCls = mergedPrefixCls.value;
      const treeSlots = {
        label: treeSelectSlots.treeLabel,
        prefix: treeSelectSlots.treePrefix,
        suffix: treeSelectSlots.treeSuffix,
        leafLineIcon: treeSelectSlots.leafLineIcon,
        empty: treeSelectSlots.empty,
        expandIcon: treeSelectSlots.expandIcon
      };
      const children = [createVNode(IxTree, {
        "ref": treeRef,
        "blocked": true,
        "checkedKeys": selectedValue.value,
        "expandedKeys": expandedKeys.value,
        "loadedKeys": loadedKeys.value,
        "labelKey": labelKey != null ? labelKey : config.labelKey,
        "checkable": checkable.value,
        "cascade": cascade.value,
        "childrenKey": childrenKey != null ? childrenKey : config.childrenKey,
        "checkStrategy": checkStrategy,
        "dataSource": dataSource,
        "draggable": draggable,
        "droppable": droppable,
        "disabled": treeDisabled,
        "empty": empty,
        "expandIcon": expandIcon,
        "height": overlayHeight,
        "nodeKey": nodeKey != null ? nodeKey : config.nodeKey,
        "loadChildren": loadChildren,
        "leafLineIcon": leafLineIcon,
        "virtual": virtual,
        "selectable": multiple ? "multiple" : true,
        "selectedKeys": selectedValue.value,
        "searchValue": searchValue.value,
        "searchFn": searchFn,
        "showLine": showLine,
        "onClick": handleClick,
        "onCheck": handleCheck,
        "onDragstart": onDragstart,
        "onDragend": onDragend,
        "onDragenter": onDragenter,
        "onDragleave": onDragleave,
        "onDragover": onDragover,
        "onDrop": onDrop,
        "onNodeClick": onNodeClick,
        "onNodeContextmenu": onNodeContextmenu,
        "onExpand": handleExpand,
        "onSelect": handleSelect,
        "onLoaded": onLoaded,
        "onCheckedChange": changeSelected,
        "onSelectedChange": changeSelected,
        "onSearchedChange": onSearchedChange,
        "onExpandedChange": handleExpandedChange,
        "onScroll": onScroll,
        "onScrolledBottom": onScrolledBottom,
        "onScrolledChange": handleScrolledChange
      }, treeSlots)];
      if (searchable === "overlay") {
        children.unshift(createVNode("div", {
          "class": `${prefixCls}-overlay-search-wrapper`
        }, [createVNode(IxButton, {
          "size": "md",
          "icon": expandAllBtnStatus.value ? "tree-expand" : "tree-unexpand",
          "onClick": handleExpandAll
        }, null), createVNode(IxInput, {
          "clearable": true,
          "suffix": "search",
          "value": searchValue.value,
          "onInput": handleSearchInput,
          "onClear": handleSearchClear
        }, null)]));
      }
      return overlayRender ? overlayRender(children) : createVNode("div", null, [children]);
    };
  }
});
const treeSelectProps = {
  value: IxPropTypes.any,
  expandedKeys: IxPropTypes.array(),
  loadedKeys: IxPropTypes.array(),
  control: controlPropDef,
  open: IxPropTypes.bool,
  autofocus: IxPropTypes.bool.def(false),
  childrenKey: IxPropTypes.string,
  cascade: IxPropTypes.bool.def(false),
  checkable: IxPropTypes.bool.def(false),
  clearable: IxPropTypes.bool.def(false),
  checkStrategy: IxPropTypes.oneOf(["all", "parent", "child"]).def("all"),
  dataSource: IxPropTypes.array().def(() => []),
  disabled: IxPropTypes.bool.def(false),
  draggable: IxPropTypes.bool.def(false),
  droppable: IxPropTypes.func(),
  empty: IxPropTypes.oneOfType([String, IxPropTypes.object()]),
  expandIcon: IxPropTypes.string,
  maxLabelCount: IxPropTypes.number.def(Number.MAX_SAFE_INTEGER),
  multiple: IxPropTypes.bool.def(false),
  labelKey: IxPropTypes.string,
  leafLineIcon: IxPropTypes.string,
  loadChildren: IxPropTypes.func(),
  nodeKey: IxPropTypes.oneOfType([String, IxPropTypes.func()]),
  overlayClassName: IxPropTypes.string,
  overlayRender: IxPropTypes.func(),
  placeholder: IxPropTypes.string,
  readonly: IxPropTypes.bool.def(false),
  searchable: IxPropTypes.oneOfType([Boolean, IxPropTypes.oneOf(["overlay"])]).def(false),
  searchFn: IxPropTypes.func(),
  size: IxPropTypes.oneOf(["sm", "md", "lg"]),
  suffix: IxPropTypes.string,
  showLine: IxPropTypes.bool,
  target: portalTargetDef,
  treeDisabled: IxPropTypes.func(),
  virtual: IxPropTypes.bool.def(false),
  "onUpdate:value": IxPropTypes.emit(),
  "onUpdate:expandedKeys": IxPropTypes.emit(),
  "onUpdate:loadedKeys": IxPropTypes.emit(),
  onCheck: IxPropTypes.emit(),
  onChange: IxPropTypes.emit(),
  onClear: IxPropTypes.emit(),
  onDragstart: IxPropTypes.emit(),
  onDragend: IxPropTypes.emit(),
  onDragenter: IxPropTypes.emit(),
  onDragleave: IxPropTypes.emit(),
  onDragover: IxPropTypes.emit(),
  onDrop: IxPropTypes.emit(),
  onExpand: IxPropTypes.emit(),
  onExpandedChange: IxPropTypes.emit(),
  onLoaded: IxPropTypes.emit(),
  onSelect: IxPropTypes.emit(),
  onBlur: IxPropTypes.emit(),
  onFocus: IxPropTypes.emit(),
  onNodeClick: IxPropTypes.emit(),
  onNodeContextmenu: IxPropTypes.emit(),
  onSearchedChange: IxPropTypes.emit(),
  onScroll: IxPropTypes.emit(),
  onScrolledChange: IxPropTypes.emit(),
  onScrolledBottom: IxPropTypes.emit(),
  overlayHeight: IxPropTypes.number.def(256)
};
const treeSelectorProps = {
  clearable: IxPropTypes.bool,
  suffix: IxPropTypes.string
};
var Input = defineComponent({
  setup() {
    const {
      props,
      mergedPrefixCls,
      isDisabled,
      inputRef,
      inputWidth,
      mirrorRef,
      searchValue,
      handleInput
    } = inject(treeSelectToken);
    const onClick = (evt) => {
      if (props.multiple) {
        evt.stopPropagation();
      }
    };
    const style = computed(() => ({
      width: inputWidth.value
    }));
    const innerStyle = computed(() => {
      const {
        searchable
      } = props;
      return {
        opacity: searchable === true ? void 0 : 0
      };
    });
    return () => {
      const {
        autofocus,
        multiple,
        readonly
      } = props;
      const prefixCls = `${mergedPrefixCls.value}-selector-input`;
      return createVNode("div", {
        "class": prefixCls,
        "style": style.value
      }, [createVNode("input", {
        "ref": inputRef,
        "class": `${prefixCls}-inner`,
        "style": innerStyle.value,
        "autocomplete": "off",
        "autofocus": autofocus,
        "disabled": isDisabled.value,
        "readonly": readonly,
        "value": searchValue.value,
        "onClick": onClick,
        "onInput": handleInput
      }, null), multiple && createVNode("span", {
        "ref": mirrorRef,
        "class": `${prefixCls}-mirror`,
        "aria-hidden": true
      }, null)]);
    };
  }
});
const Item = (props, {
  slots
}) => {
  const {
    disabled,
    prefixCls,
    removable,
    handleItemRemove
  } = props;
  const key = useKey();
  const classes = prefixCls + (disabled ? ` ${prefixCls}-disabled` : "");
  const handleClick = (evt) => {
    evt.stopPropagation();
    handleItemRemove(key);
  };
  return createVNode("div", {
    "class": classes
  }, [createVNode("span", {
    "class": `${prefixCls}-label`
  }, [slots.default()]), removable && createVNode("span", {
    "class": `${prefixCls}-remove`,
    "onClick": handleClick
  }, [createVNode(IxIcon, {
    "name": "close"
  }, null)])]);
};
var Selector = defineComponent({
  props: treeSelectorProps,
  setup(props) {
    const {
      props: treeSelectProps2,
      slots,
      mergedPrefixCls,
      isDisabled,
      selectedValue,
      selectedNodes,
      handleItemRemove,
      handleClear,
      searchValue
    } = inject(treeSelectToken);
    const selectedItems = computed(() => {
      const {
        maxLabelCount
      } = treeSelectProps2;
      const nodes = selectedNodes.value;
      const items = nodes.slice(0, maxLabelCount);
      if (nodes.length > maxLabelCount) {
        const label = `+ ${nodes.length - maxLabelCount} ...`;
        const key = nodes.slice(maxLabelCount).map((node) => node.rawNode);
        items.push({
          isMax: true,
          key,
          label
        });
      }
      return items;
    });
    const showItems = computed(() => {
      return treeSelectProps2.multiple || selectedValue.value.length > 0 && !searchValue.value;
    });
    const showPlaceholder = computed(() => {
      return selectedValue.value.length === 0 && (!searchValue.value || treeSelectProps2.searchable === "overlay");
    });
    return () => {
      var _a, _b, _c, _d;
      const {
        clearable,
        suffix
      } = props;
      const {
        multiple,
        readonly
      } = treeSelectProps2;
      const disabled = isDisabled.value;
      const prefixCls = `${mergedPrefixCls.value}-selector`;
      const itemPrefixCls = `${prefixCls}-item`;
      const itemNodes = selectedItems.value.map((item) => {
        var _a2, _b2, _c2, _d2;
        const {
          key,
          isMax,
          label
        } = item;
        const _disabled = disabled || item.selectDisabled;
        const removable = multiple && !_disabled && !readonly && !isMax;
        const itemProps = {
          key,
          disabled: _disabled,
          prefixCls: itemPrefixCls,
          removable,
          title: label,
          handleItemRemove
        };
        let labelNode;
        if (isMax) {
          labelNode = (_b2 = (_a2 = slots.maxLabel) == null ? void 0 : _a2.call(slots, item.key)) != null ? _b2 : label;
        } else {
          labelNode = (_d2 = (_c2 = slots.label) == null ? void 0 : _c2.call(slots, item.rawNode)) != null ? _d2 : label;
        }
        return createVNode(Item, itemProps, {
          default: () => [labelNode]
        });
      });
      return createVNode("label", {
        "class": prefixCls
      }, [showItems.value && itemNodes, createVNode(Input, null, null), showPlaceholder.value && createVNode("div", {
        "class": `${prefixCls}-placeholder`
      }, [createTextVNode(" "), (_b = (_a = slots.placeholder) == null ? void 0 : _a.call(slots)) != null ? _b : treeSelectProps2.placeholder]), (slots.suffix || suffix) && createVNode("div", {
        "class": `${prefixCls}-suffix`
      }, [(_d = (_c = slots.suffix) == null ? void 0 : _c.call(slots)) != null ? _d : createVNode(IxIcon, {
        "name": suffix
      }, null)]), clearable && createVNode("div", {
        "class": `${prefixCls}-clear`,
        "onClick": handleClear
      }, [createVNode(IxIcon, {
        "name": "close-circle"
      }, null)])]);
    };
  }
});
const hiddenBoxStyle = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0
};
var Trigger = defineComponent({
  setup() {
    const {
      props,
      slots,
      config,
      focusMonitor,
      mergedPrefixCls,
      triggerRef,
      isDisabled,
      selectedValue,
      isFocused,
      overlayOpened,
      handleFocus,
      handleBlur,
      setOverlayOpened
    } = inject(treeSelectToken);
    const formContext = inject(FORM_TOKEN, null);
    const clearable = computed(() => {
      return !isDisabled.value && !props.readonly && props.clearable && selectedValue.value.length > 0;
    });
    const searchable = computed(() => {
      return !isDisabled.value && !props.readonly && props.searchable;
    });
    const suffix = computed(() => {
      const {
        suffix: suffix2
      } = props;
      if (suffix2) {
        return suffix2;
      }
      return props.searchable === true && isFocused.value ? "search" : config.suffix;
    });
    const classes = computed(() => {
      var _a;
      const {
        multiple,
        readonly,
        size = (_a = formContext == null ? void 0 : formContext.size.value) != null ? _a : config.size
      } = props;
      const disabled = isDisabled.value;
      const prefixCls = mergedPrefixCls.value;
      return {
        [prefixCls]: true,
        [`${prefixCls}-clearable`]: clearable.value,
        [`${prefixCls}-readonly`]: readonly,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-readonly`]: readonly,
        [`${prefixCls}-focused`]: isFocused.value,
        [`${prefixCls}-opened`]: overlayOpened.value,
        [`${prefixCls}-multiple`]: multiple,
        [`${prefixCls}-single`]: !multiple,
        [`${prefixCls}-searchable`]: searchable.value === true,
        [`${prefixCls}-with-suffix`]: slots.suffix || suffix.value,
        [`${prefixCls}-${size}`]: true
      };
    });
    const handleClick = () => {
      const currOpened = overlayOpened.value;
      const notAllowedClick = isDisabled.value || props.readonly;
      if (notAllowedClick || currOpened && searchable.value) {
        return;
      }
      setOverlayOpened(!currOpened);
    };
    onMounted(() => {
      watch(focusMonitor.monitor(triggerRef.value, true), (evt) => {
        const {
          origin,
          event
        } = evt;
        if (event) {
          if (origin) {
            handleFocus(event);
          } else {
            handleBlur(event);
          }
        }
      });
    });
    onBeforeUnmount(() => focusMonitor.stopMonitoring(triggerRef.value));
    return () => {
      return createVNode("div", {
        "ref": triggerRef,
        "class": classes.value,
        "onClick": handleClick
      }, [isFocused.value && !overlayOpened.value && createVNode("span", {
        "style": hiddenBoxStyle,
        "aria-live": "polite"
      }, [selectedValue.value.join(", ")]), createVNode(Selector, {
        "clearable": clearable.value,
        "suffix": suffix.value
      }, null)]);
    };
  }
});
var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
const defaultOffset = [0, 8];
var TreeSelect = defineComponent({
  name: "IxTreeSelect",
  inheritAttrs: false,
  props: treeSelectProps,
  setup(props, {
    attrs,
    expose,
    slots
  }) {
    const common = useGlobalConfig$1("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-tree-select`);
    const config = useGlobalConfig$1("treeSelect");
    const getNodeKey = useGetNodeKey(props, config);
    const searchValue = ref("");
    const [expandedKeys, setExpandedKeys] = useControlledProp(props, "expandedKeys", () => []);
    const focusMonitor = useSharedFocusMonitor();
    const {
      elementRef: inputRef,
      focus,
      blur
    } = useFormElement();
    const accessor = useFormAccessor();
    const isDisabled = computed(() => accessor.disabled.value);
    const inputStateContext = useInputState(props, inputRef, accessor, searchValue);
    const {
      clearInput
    } = inputStateContext;
    const {
      mergedNodeMap
    } = useMergeNodes(props, getNodeKey, config);
    const selectedStateContext = useSelectedState(props, accessor, mergedNodeMap);
    const triggerRef = ref();
    const {
      overlayRef,
      overlayStyle,
      overlayOpened,
      setOverlayOpened
    } = useOverlayProps(props, triggerRef);
    const treeRef = ref();
    const scrollTo = (options) => {
      var _a;
      (_a = treeRef.value) == null ? void 0 : _a.scrollTo(options);
    };
    const setExpandAll = (isAll) => {
      const _expendedKeys = [];
      const _expendedNodes = [];
      if (isAll) {
        mergedNodeMap.value.forEach((node) => {
          if (!node.isLeaf) {
            _expendedKeys.push(node.key);
            _expendedNodes.push(node.rawNode);
          }
        });
      }
      callEmit(props.onExpandedChange, _expendedKeys, _expendedNodes);
      setExpandedKeys(_expendedKeys);
    };
    expose({
      focus,
      blur,
      scrollTo,
      setExpandAll
    });
    const handleNodeClick = () => {
      if (props.multiple) {
        focus();
        clearInput();
      } else {
        setOverlayOpened(false);
      }
    };
    provide(treeSelectToken, __spreadValues$4(__spreadValues$4({
      props,
      slots,
      config,
      getNodeKey,
      expandedKeys,
      mergedPrefixCls,
      mergedNodeMap,
      focusMonitor,
      triggerRef,
      treeRef,
      inputRef,
      overlayOpened,
      accessor,
      isDisabled,
      searchValue,
      setExpandedKeys,
      setExpandAll,
      handleNodeClick,
      setOverlayOpened
    }, selectedStateContext), inputStateContext));
    watch(overlayOpened, (opened) => {
      opened ? focus() : blur();
      clearInput();
    });
    const classes = computed(() => {
      const {
        overlayClassName
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [`${prefixCls}-overlay`]: true,
        [overlayClassName || ""]: !!overlayClassName
      });
    });
    const target = computed(() => {
      var _a, _b;
      return (_b = (_a = props.target) != null ? _a : config.target) != null ? _b : `${mergedPrefixCls.value}-overlay-container`;
    });
    return () => {
      const renderTrigger = () => createVNode(Trigger, attrs, null);
      const renderContent = () => createVNode(Content, null, null);
      const overlayProps = {
        "onUpdate:visible": setOverlayOpened
      };
      return createVNode(\u0275Overlay, mergeProps({
        "ref": overlayRef
      }, overlayProps, {
        "visible": overlayOpened.value,
        "class": classes.value,
        "style": overlayStyle.value,
        "target": target.value,
        "offset": defaultOffset,
        "disabled": isDisabled.value || props.readonly,
        "clickOutside": true,
        "placement": "bottom",
        "trigger": "manual"
      }), {
        default: renderTrigger,
        content: renderContent
      });
    };
  }
});
const IxTreeSelect = TreeSelect;

const typography = (el, binding) => {
  const className = ["ix-typography"];
  const { value, oldValue } = binding;
  const oldOptions = isObject(oldValue) ? oldValue : { type: oldValue != null ? oldValue : void 0 };
  const newOptions = isObject(value) ? value : { type: value };
  if (isLegality(oldOptions.type)) {
    removeClass(el, `ix-typography-${oldOptions.type}`);
  }
  if (oldOptions.disabled) {
    removeClass(el, "ix-typography-disabled");
  }
  if (isLegality(newOptions.type)) {
    className.push(`ix-typography-${newOptions.type}`);
  }
  if (newOptions.disabled) {
    className.push("ix-typography-disabled");
  }
  addClass(el, className);
};
function isLegality(type) {
  const types = ["success", "warning", "error", "secondary"];
  if (!type) {
    return false;
  }
  if (types.includes(type)) {
    return true;
  }
  process.env.NODE_ENV !== "production" && Logger.warn("components/typography", `${type} is not includes in ${types}.`);
  return false;
}

var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
function getFileInfo(file, options = {}) {
  const key = uniqueId();
  return __spreadValues$2({
    key,
    name: file.name,
    raw: file,
    percent: 0
  }, options);
}
function getTargetFile(file, files) {
  const matchKey = file.key !== void 0 ? "key" : "name";
  return files.find((item) => item[matchKey] === file[matchKey]);
}
function getTargetFileIndex(file, files) {
  const matchKey = file.key !== void 0 ? "key" : "name";
  return files.findIndex((item) => item[matchKey] === file[matchKey]);
}
function isImage(file) {
  return !!file.type && file.type.startsWith("image/");
}
function setFileStatus(file, status, onFileStatusChange) {
  file.status = status;
  onFileStatusChange && callEmit(onFileStatusChange, file);
}
function getFilesAcceptAllow(filesSelected, accept) {
  if (!accept || accept.length === 0) {
    return filesSelected;
  }
  return filesSelected.filter((file) => {
    const extension = file.name.indexOf(".") > -1 ? `.${file.name.split(".").pop()}` : "";
    const baseType = file.type.replace(/\/.*$/, "");
    return accept.some((type) => {
      if (type.startsWith(".")) {
        return extension === type;
      }
      if (/\/\*$/.test(type)) {
        return baseType === type.replace(/\/\*$/, "");
      }
      if (/^[^/]+\/[^/]+$/.test(type)) {
        return file.type === type;
      }
      return false;
    });
  });
}
function getFilesCountAllow(filesSelected, curFilesCount, maxCount) {
  if (!maxCount) {
    return filesSelected;
  }
  if (maxCount === 1) {
    return filesSelected.slice(0, 1);
  }
  const remainder = maxCount - curFilesCount;
  if (remainder <= 0) {
    return [];
  }
  if (remainder >= filesSelected.length) {
    return filesSelected;
  }
  return filesSelected.slice(0, remainder);
}
function useCmpClasses() {
  const commonPrefix = useGlobalConfig$1("common");
  return computed(() => `${commonPrefix.prefixCls}-upload`);
}
function useListClasses(props, type) {
  const cpmClasses = useCmpClasses();
  return computed(() => normalizeClass([
    `${cpmClasses.value}-list`,
    `${cpmClasses.value}-list-${type}`,
    { [`${cpmClasses.value}-list-disabled`]: props.disabled }
  ]));
}
function useIcon(props) {
  const uploadFilesConfig = useGlobalConfig$1("uploadFiles");
  return computed(() => {
    var _a;
    return (_a = props.icon) != null ? _a : uploadFilesConfig.icon;
  });
}
function useSelectorVisible(props, listType) {
  const outerSelector = computed(() => props.dragable || (isProxy(listType) ? listType.value !== "imageCard" : listType !== "imageCard"));
  const imageCardSelector = computed(() => !outerSelector.value);
  return [outerSelector, imageCardSelector];
}
function useThumb() {
  const revokeList = shallowRef([]);
  const getThumbNode = (file) => {
    if (!file.thumbUrl && file.raw && isImage(file.raw)) {
      file.thumbUrl = window.URL.createObjectURL(file.raw);
      revokeList.value.push(() => {
        window.URL.revokeObjectURL(file.thumbUrl);
        Reflect.deleteProperty(file, "thumbUrl");
      });
    }
    if (!file.thumbUrl) {
      return null;
    }
    return h$1("img", {
      src: file.thumbUrl,
      alt: file.name,
      style: { height: "100%", width: "100%" }
    });
  };
  const revokeAll = () => {
    revokeList.value.forEach((revokeFn) => revokeFn());
    revokeList.value = [];
  };
  return {
    revokeList,
    getThumbNode,
    revokeAll
  };
}
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useOperation(files, listProps, uploadProps2, opr) {
  const abort = (file) => {
    opr.abort(file);
  };
  const retry = (file) => {
    if (uploadProps2.disabled) {
      return;
    }
    opr.upload(file);
    callEmit(listProps.onRetry, file);
  };
  const download = (file) => {
    if (uploadProps2.disabled) {
      return;
    }
    callEmit(listProps.onDownload, file);
  };
  const preview = (file) => {
    if (uploadProps2.disabled) {
      return;
    }
    if (!listProps.onPreview && file.thumbUrl) {
      opr.setViewerVisible(true, file.thumbUrl);
      return;
    }
    callEmit(listProps.onPreview, file);
  };
  const remove = (file) => __async$2(this, null, function* () {
    if (uploadProps2.disabled) {
      return;
    }
    const curFile = getTargetFile(file, files.value);
    if (!curFile) {
      return;
    }
    const allRemove = callEmit(listProps.onRemove, curFile);
    if (allRemove === false) {
      return;
    }
    if (allRemove instanceof Promise) {
      const result = yield allRemove;
      if (result === false) {
        return;
      }
    }
    if (curFile.status === "uploading") {
      abort(curFile);
    }
    const preFiles = [...files.value];
    preFiles.splice(getTargetFileIndex(curFile, files.value), 1);
    opr.onUpdateFiles(preFiles);
  });
  return {
    abort,
    retry,
    download,
    preview,
    remove
  };
}
const uploadToken = Symbol("UploadToken");
const uploadProps = {
  files: IxPropTypes.array().isRequired,
  accept: IxPropTypes.string,
  action: IxPropTypes.oneOfType([String, IxPropTypes.func()]).isRequired,
  dragable: IxPropTypes.bool,
  directory: IxPropTypes.bool,
  disabled: IxPropTypes.bool,
  maxCount: IxPropTypes.number,
  multiple: IxPropTypes.bool,
  progress: IxPropTypes.object(),
  name: IxPropTypes.string,
  customRequest: IxPropTypes.func(),
  withCredentials: IxPropTypes.bool,
  requestData: IxPropTypes.oneOfType([
    Object,
    IxPropTypes.func()
  ]),
  requestHeaders: IxPropTypes.object(),
  requestMethod: IxPropTypes.oneOf(["POST", "PUT", "PATCH", "post", "put", "patch"]),
  "onUpdate:files": IxPropTypes.emit(),
  onSelect: IxPropTypes.emit(),
  onBeforeUpload: IxPropTypes.emit(),
  onFileStatusChange: IxPropTypes.emit(),
  onRequestChange: IxPropTypes.emit()
};
const uploadFilesProps = {
  type: IxPropTypes.oneOf(["text", "image", "imageCard"]),
  icon: IxPropTypes.object(),
  onDownload: IxPropTypes.emit(),
  onPreview: IxPropTypes.emit(),
  onRemove: IxPropTypes.emit(),
  onRetry: IxPropTypes.emit()
};
function getIconNode(icon) {
  if (!icon) {
    return null;
  }
  if (isString(icon)) {
    return h$1(IxIcon, { name: icon });
  }
  return icon;
}
function renderIcon(icon, props) {
  if (!icon) {
    return null;
  }
  return h$1("span", props, [getIconNode(icon)]);
}
function renderOprIcon(file, icons, cpmClasses, fileOperation, locale) {
  const previewNode = renderIcon(icons.value.preview, {
    class: `${cpmClasses.value}-icon-opr ${cpmClasses.value}-icon-preview`,
    onClick: () => fileOperation.preview(file),
    title: locale.value.preview
  });
  const retryNode = renderIcon(icons.value.retry, {
    class: `${cpmClasses.value}-icon-opr ${cpmClasses.value}-icon-retry`,
    onClick: () => fileOperation.retry(file),
    title: locale.value.retry
  });
  const downloadNode = renderIcon(icons.value.download, {
    class: `${cpmClasses.value}-icon-opr ${cpmClasses.value}-icon-download`,
    onClick: () => fileOperation.download(file),
    title: locale.value.download
  });
  const removeNode = renderIcon(icons.value.remove, {
    class: `${cpmClasses.value}-icon-opr ${cpmClasses.value}-icon-remove`,
    onClick: () => fileOperation.remove(file),
    title: locale.value.remove
  });
  return {
    previewNode,
    retryNode,
    downloadNode,
    removeNode
  };
}
function showProgress(status, percent) {
  return status === "uploading" && isNumber(percent);
}
function showErrorTip(status, errorTip) {
  return status === "error" && !!errorTip;
}
function showRetry(status) {
  return status === "error";
}
function showDownload(status) {
  return status === "success";
}
function showPreview(status) {
  return status === "success";
}
function useDrag(props) {
  const dragOver = ref(false);
  const filesSelected = shallowRef([]);
  const allowDrag = computed(() => !!props.dragable && !props.disabled);
  function onDrop(e) {
    var _a, _b;
    e.preventDefault();
    if (!allowDrag.value) {
      return;
    }
    dragOver.value = false;
    filesSelected.value = Array.prototype.slice.call((_b = (_a = e.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);
  }
  function onDragOver(e) {
    e.preventDefault();
    if (!allowDrag.value) {
      return;
    }
    dragOver.value = true;
  }
  function onDragLeave(e) {
    e.preventDefault();
    if (!allowDrag.value) {
      return;
    }
    dragOver.value = false;
  }
  return {
    allowDrag,
    dragOver,
    filesSelected,
    onDrop,
    onDragOver,
    onDragLeave
  };
}
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var FileSelector = defineComponent({
  name: "IxUploadSelector",
  setup(props, {
    slots
  }) {
    const {
      props: uploadProps2,
      files,
      onUpdateFiles,
      abort,
      startUpload
    } = inject(uploadToken);
    const cpmClasses = useCmpClasses();
    const config = useGlobalConfig$1("upload");
    const dir = useDir(uploadProps2, config);
    const multiple = useMultiple(uploadProps2, config);
    const dragable = useDragable(uploadProps2, config);
    const accept = useAccept(uploadProps2);
    const maxCount = computed(() => {
      var _a;
      return (_a = uploadProps2.maxCount) != null ? _a : 0;
    });
    const {
      allowDrag,
      dragOver,
      filesSelected: dragFilesSelected,
      onDrop,
      onDragOver,
      onDragLeave
    } = useDrag(uploadProps2);
    const [filesSelected, updateFilesSelected] = useFilesSelected(dragFilesSelected, allowDrag);
    const filesReady = useFilesAllowed(files, filesSelected, accept, maxCount);
    const fileInputRef = ref(null);
    const inputClasses = computed(() => `${cpmClasses.value}-input`);
    const selectorClasses = useSelectorClasses(uploadProps2, cpmClasses, dragable, dragOver);
    syncUploadHandle(uploadProps2, files, filesReady, onUpdateFiles, abort, startUpload);
    return () => {
      var _a;
      return createVNode("div", {
        "class": selectorClasses.value,
        "onClick": () => onClick(fileInputRef, uploadProps2),
        "onDragover": onDragOver,
        "onDrop": onDrop,
        "onDragleave": onDragLeave
      }, [createVNode("input", mergeProps(dir.value, {
        "class": inputClasses.value,
        "type": "file",
        "ref": fileInputRef,
        "accept": uploadProps2.accept,
        "multiple": multiple.value,
        "onClick": (e) => e.stopPropagation(),
        "onChange": () => onSelect(fileInputRef, updateFilesSelected)
      }), null), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
function useSelectorClasses(props, cpmClasses, dragable, dragOver) {
  return computed(() => normalizeClass({
    [`${cpmClasses.value}-selector`]: true,
    [`${cpmClasses.value}-selector-drag`]: dragable.value,
    [`${cpmClasses.value}-selector-disabled`]: props.disabled,
    [`${cpmClasses.value}-selector-dragover`]: dragOver.value
  }));
}
function useDir(props, config) {
  const directoryCfg = {
    directory: "directory",
    webkitdirectory: "webkitdirectory"
  };
  return computed(() => {
    var _a;
    return ((_a = props.directory) != null ? _a : config.directory) ? directoryCfg : {};
  });
}
function useAccept(props) {
  return computed(() => {
    var _a;
    return (_a = props.accept) == null ? void 0 : _a.split(",").map((type) => type.trim()).filter((type) => type);
  });
}
function useMultiple(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.multiple) != null ? _a : config.multiple;
  });
}
function useDragable(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.dragable) != null ? _a : config.dragable;
  });
}
function useFilesSelected(dragFilesSelected, allowDrag) {
  const filesSelected = shallowRef([]);
  watch(dragFilesSelected, (files) => {
    if (allowDrag.value) {
      filesSelected.value = files;
    }
  });
  function updateFilesSelected(files) {
    filesSelected.value = files;
  }
  return [filesSelected, updateFilesSelected];
}
function useFilesAllowed(files, filesSelected, accept, maxCount) {
  const filesAllowed = shallowRef([]);
  watch(filesSelected, (filesSelected$$) => {
    const filesCheckAccept = getFilesAcceptAllow(filesSelected$$, accept.value);
    filesAllowed.value = getFilesCountAllow(filesCheckAccept, files.value.length, maxCount.value);
  });
  return filesAllowed;
}
function syncUploadHandle(uploadProps2, files, filesReady, onUpdateFiles, abort, startUpload) {
  watch(filesReady, (filesReady$$) => __async$1(this, null, function* () {
    if (filesReady$$.length === 0) {
      return;
    }
    const filesAfterHandle = uploadProps2.onSelect ? yield callEmit(uploadProps2.onSelect, filesReady$$) : filesReady$$;
    const filesReadyUpload = getFilesHandled(filesAfterHandle, filesReady$$);
    const filesFormat = getFormatFiles(filesReadyUpload, uploadProps2, "selected");
    const filesIds = filesFormat.map((file) => file.key);
    if (uploadProps2.maxCount === 1) {
      files.value.forEach((file) => abort(file));
      callEmit(onUpdateFiles, filesFormat);
    } else {
      callEmit(onUpdateFiles, files.value.concat(filesFormat));
    }
    yield nextTick(() => {
      files.value.filter((item) => filesIds.includes(item.key)).forEach((file) => {
        startUpload(file);
      });
    });
  }));
}
function onClick(fileInputRef, props) {
  if (props.disabled || !fileInputRef.value) {
    return;
  }
  fileInputRef.value.value = "";
  fileInputRef.value.click();
}
function onSelect(fileInputRef, updateFilesSelected) {
  var _a, _b;
  const files = Array.prototype.slice.call((_b = (_a = fileInputRef.value) == null ? void 0 : _a.files) != null ? _b : []);
  updateFilesSelected(files);
}
function getFormatFiles(files, props, status) {
  return files.map((item) => {
    const fileInfo = getFileInfo(item, {
      status
    });
    callEmit(props.onFileStatusChange, fileInfo);
    return fileInfo;
  });
}
function getFilesHandled(handleResult, allowedFiles) {
  if (handleResult === true) {
    return allowedFiles;
  }
  if (handleResult === false) {
    return [];
  }
  return handleResult;
}
var IxUploadImageCardList = defineComponent({
  name: "IxUploadImageCardList",
  props: uploadFilesProps,
  setup(listProps) {
    const {
      props: uploadProps2,
      files,
      upload: upload2,
      abort,
      onUpdateFiles,
      setViewerVisible
    } = inject(uploadToken);
    const icons = useIcon(listProps);
    const cpmClasses = useCmpClasses();
    const listClasses = useListClasses(uploadProps2, "imageCard");
    const locale = getLocale("upload");
    const [, imageCardVisible] = useSelectorVisible(uploadProps2, "imageCard");
    const showSelector = useShowSelector$1(uploadProps2, files, imageCardVisible);
    const {
      getThumbNode,
      revokeAll
    } = useThumb();
    const fileOperation = useOperation(files, listProps, uploadProps2, {
      abort,
      upload: upload2,
      onUpdateFiles,
      setViewerVisible
    });
    const selectorNode = renderSelector(cpmClasses);
    onBeforeUnmount(revokeAll);
    return () => createVNode("ul", {
      "class": listClasses.value
    }, [showSelector.value && selectorNode, files.value.map((file) => renderItem$2(uploadProps2, file, icons, cpmClasses, fileOperation, locale, getThumbNode))]);
  }
});
function renderItem$2(uploadProps2, file, icons, cpmClasses, fileOperation, locale, getThumbNode) {
  const fileClasses = normalizeClass([`${cpmClasses.value}-file`, `${cpmClasses.value}-file-${file.status}`]);
  const uploadStatusNode = renderUploadStatus(uploadProps2, file, locale, cpmClasses);
  const thumbNode = getThumbNode(file);
  const {
    retryNode,
    downloadNode,
    removeNode,
    previewNode
  } = renderOprIcon(file, icons, cpmClasses, fileOperation, locale);
  return createVNode(IxTooltip, {
    "title": showErrorTip(file.status, file.errorTip) ? file.errorTip : ""
  }, {
    default: () => [createVNode("li", {
      "class": fileClasses
    }, [showUploadStatus(file.status) ? uploadStatusNode : thumbNode, createVNode("div", {
      "class": `${cpmClasses.value}-icon`
    }, [showPreview(file.status) && previewNode, showRetry(file.status) && retryNode, showDownload(file.status) && downloadNode, removeNode])])]
  });
}
function renderUploadStatus(uploadProps2, file, locale, cpmClasses) {
  var _a;
  const statusTitle = {
    error: locale.value.error,
    uploading: locale.value.uploading
  };
  const curTitle = file.status && statusTitle[file.status];
  return createVNode("div", {
    "class": `${cpmClasses.value}-status`
  }, [curTitle && createVNode("div", {
    "class": `${cpmClasses.value}-status-title`
  }, [curTitle]), showProgress(file.status, file.percent) && createVNode(IxProgress, mergeProps({
    "class": `${cpmClasses.value}-progress`,
    "strokeColor": "#20CC94",
    "percent": file.percent,
    "strokeWidth": 3,
    "hide-info": true
  }, (_a = uploadProps2.progress) != null ? _a : {}), null)]);
}
function renderSelector(cpmClasses) {
  return createVNode(FileSelector, {
    "class": `${cpmClasses.value}-selector`
  }, {
    default: () => [createVNode(IxIcon, {
      "name": "plus"
    }, null)]
  });
}
function showUploadStatus(status) {
  return status && ["uploading", "error"].includes(status);
}
function useShowSelector$1(uploadProps2, files, imageCardVisible) {
  return computed(() => {
    const countLimit = !uploadProps2.maxCount || files.value.length < uploadProps2.maxCount;
    return countLimit && imageCardVisible.value;
  });
}
var IxUploadImageList = defineComponent({
  name: "IxUploadImageList",
  props: uploadFilesProps,
  setup(listProps) {
    const {
      props: uploadProps2,
      files,
      upload: upload2,
      abort,
      onUpdateFiles,
      setViewerVisible
    } = inject(uploadToken);
    const icons = useIcon(listProps);
    const cpmClasses = useCmpClasses();
    const listClasses = useListClasses(uploadProps2, "image");
    const locale = getLocale("upload");
    const {
      getThumbNode,
      revokeAll
    } = useThumb();
    const fileOperation = useOperation(files, listProps, uploadProps2, {
      abort,
      upload: upload2,
      onUpdateFiles,
      setViewerVisible
    });
    onBeforeUnmount(revokeAll);
    return () => files.value.length > 0 && createVNode("ul", {
      "class": listClasses.value
    }, [files.value.map((file) => renderItem$1(uploadProps2, file, icons, cpmClasses, fileOperation, locale, getThumbNode))]);
  }
});
function renderItem$1(uploadProps2, file, icons, cpmClasses, fileOperation, locale, getThumbNode) {
  var _a;
  const fileClasses = normalizeClass([`${cpmClasses.value}-file`, `${cpmClasses.value}-file-${file.status}`]);
  const fileNameClasses = normalizeClass([`${cpmClasses.value}-name`, `${cpmClasses.value}-name-pointer`]);
  const errorTipNode = renderIcon("exclamation-circle", {
    class: `${cpmClasses.value}-icon-error`
  });
  const {
    retryNode,
    downloadNode,
    removeNode
  } = renderOprIcon(file, icons, cpmClasses, fileOperation, locale);
  return createVNode("li", {
    "class": fileClasses
  }, [createVNode("div", {
    "class": `${cpmClasses.value}-thumb-info`
  }, [createVNode("span", {
    "class": `${cpmClasses.value}-thumb`
  }, [getThumbNode(file)]), createVNode("span", {
    "class": fileNameClasses,
    "onClick": () => showPreview(file.status) && fileOperation.preview(file),
    "title": file.name
  }, [file.name])]), createVNode("div", {
    "class": `${cpmClasses.value}-icon-wrap`
  }, [showErrorTip(file.status, file.errorTip) && createVNode(IxTooltip, {
    "title": file.errorTip
  }, {
    default: () => [errorTipNode]
  }), showRetry(file.status) && retryNode, showDownload(file.status) && downloadNode, removeNode]), showProgress(file.status, file.percent) && createVNode(IxProgress, mergeProps({
    "class": `${cpmClasses.value}-progress`,
    "percent": file.percent,
    "strokeColor": "#20CC94",
    "strokeWidth": 2,
    "hide-info": true
  }, (_a = uploadProps2.progress) != null ? _a : {}), null)]);
}
var IxUploadTextList = defineComponent({
  name: "IxUploadTextList",
  props: uploadFilesProps,
  setup(listProps) {
    const {
      props: uploadProps2,
      files,
      upload: upload2,
      abort,
      onUpdateFiles,
      setViewerVisible
    } = inject(uploadToken);
    const icons = useIcon(listProps);
    const cpmClasses = useCmpClasses();
    const listClasses = useListClasses(uploadProps2, "text");
    const locale = getLocale("upload");
    const fileOperation = useOperation(files, listProps, uploadProps2, {
      abort,
      upload: upload2,
      onUpdateFiles,
      setViewerVisible
    });
    return () => files.value.length > 0 && createVNode("ul", {
      "class": listClasses.value
    }, [files.value.map((file) => renderItem(uploadProps2, file, icons, cpmClasses, fileOperation, locale))]);
  }
});
function renderItem(uploadProps2, file, icons, cpmClasses, fileOperation, locale) {
  var _a;
  const fileClasses = normalizeClass([`${cpmClasses.value}-file`, `${cpmClasses.value}-file-${file.status}`]);
  const fileNameClasses = normalizeClass([`${cpmClasses.value}-name`, `${cpmClasses.value}-name-pointer`]);
  const errorTipNode = renderIcon("exclamation-circle", {
    class: `${cpmClasses.value}-icon-error`
  });
  const {
    retryNode,
    downloadNode,
    removeNode
  } = renderOprIcon(file, icons, cpmClasses, fileOperation, locale);
  return createVNode("li", {
    "class": fileClasses
  }, [createVNode("span", {
    "class": `${cpmClasses.value}-text-info`
  }, [renderIcon(icons.value.file, {
    class: `${cpmClasses.value}-icon-file`
  }), createVNode("span", {
    "class": fileNameClasses,
    "onClick": () => showPreview(file.status) && fileOperation.preview(file),
    "title": file.name
  }, [file.name])]), createVNode("span", {
    "class": `${cpmClasses.value}-icon-wrap`
  }, [showErrorTip(file.status, file.errorTip) && createVNode(IxTooltip, {
    "title": file.errorTip
  }, {
    default: () => [errorTipNode]
  }), showRetry(file.status) && retryNode, showDownload(file.status) && downloadNode, removeNode]), showProgress(file.status, file.percent) && createVNode(IxProgress, mergeProps({
    "class": `${cpmClasses.value}-progress`,
    "percent": file.percent,
    "strokeColor": "#20CC94",
    "strokeWidth": 2,
    "hide-info": true
  }, (_a = uploadProps2.progress) != null ? _a : {}), null)]);
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$1)
    for (var prop of __getOwnPropSymbols$1$1(b)) {
      if (__propIsEnum$1$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
const cpmMap = {
  text: IxUploadTextList,
  image: IxUploadImageList,
  imageCard: IxUploadImageCardList
};
var UploadFiles = defineComponent({
  name: "IxUploadFiles",
  props: uploadFilesProps,
  setup(props) {
    const config = useGlobalConfig$1("uploadFiles");
    const listType = useListType(props, config);
    const {
      props: uploadProps2,
      setSelectorVisible
    } = inject(uploadToken);
    const [outerSelector] = useSelectorVisible(uploadProps2, listType);
    watchEffect(() => setSelectorVisible(outerSelector.value));
    return () => h$1(cpmMap[listType.value], __spreadValues$1({}, props));
  }
});
function useListType(props, config) {
  return computed(() => {
    var _a;
    return (_a = props.type) != null ? _a : config.type;
  });
}
function getError(option, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to ${option.requestMethod} ${option.action} ${xhr.status}`;
  }
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.requestMethod;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option.onProgress(e);
    };
  }
  const formData = new FormData();
  if (option.requestData) {
    Object.keys(option.requestData).forEach((key) => {
      const value = option.requestData[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key}[]`, item);
        });
        return;
      }
      formData.append(key, value);
    });
  }
  formData.append(option.name, option.file, option.file.name);
  xhr.onerror = function error() {
    var _a;
    (_a = option.onError) == null ? void 0 : _a.call(option, getError(option, xhr));
  };
  xhr.onload = function onload() {
    var _a, _b;
    if (xhr.status < 200 || xhr.status >= 300) {
      return (_a = option.onError) == null ? void 0 : _a.call(option, getError(option, xhr));
    }
    return (_b = option.onSuccess) == null ? void 0 : _b.call(option, getBody(xhr));
  };
  xhr.open(option.requestMethod, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.requestHeaders || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h2) => {
    if (headers[h2] !== null) {
      xhr.setRequestHeader(h2, headers[h2]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useRequest(props, files) {
  const fileUploading = ref([]);
  const aborts = /* @__PURE__ */ new Map([]);
  const config = useGlobalConfig$1("upload");
  function abort(file) {
    const curFile = getTargetFile(file, files.value);
    if (!curFile) {
      return;
    }
    const curAbort = aborts.get(curFile.key);
    curAbort == null ? void 0 : curAbort();
    setFileStatus(curFile, "abort", props.onFileStatusChange);
    fileUploading.value.splice(getTargetFileIndex(curFile, fileUploading.value), 1);
    aborts.delete(curFile.key);
    props.onRequestChange && callEmit(props.onRequestChange, {
      status: "abort",
      file: __spreadValues$3({}, curFile)
    });
  }
  function startUpload(file) {
    return __async(this, null, function* () {
      if (isUndefined(props.onBeforeUpload)) {
        yield upload$1(file);
        return;
      }
      const before = callEmit(props.onBeforeUpload, file);
      if (before instanceof Promise) {
        try {
          const result = yield before;
          if (result === true) {
            yield upload$1(file);
            return;
          }
          if (typeof result === "object" && result) {
            yield upload$1(result);
          }
        } catch (e) {
          setFileStatus(file, "error", props.onFileStatusChange);
        }
      } else if (before === true) {
        yield upload$1(file);
      } else if (typeof before === "object") {
        yield upload$1(before);
      }
    });
  }
  function upload$1(file) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!file.raw) {
        file.error = new Error("file error");
        setFileStatus(file, "error", props.onFileStatusChange);
      }
      const action = yield getAction(props, file);
      const requestData = yield getRequestData(props, file);
      const requestOption = {
        file: file.raw,
        name: (_a = props.name) != null ? _a : config.name,
        withCredentials: (_b = props.withCredentials) != null ? _b : config.withCredentials,
        action,
        requestHeaders: (_c = props.requestHeaders) != null ? _c : {},
        requestMethod: (_d = props.requestMethod) != null ? _d : config.requestMethod,
        requestData,
        onProgress: (event) => _onProgress(event, file),
        onError: (error) => _onError(error, file),
        onSuccess: (res) => _onSuccess(res, file)
      };
      const uploadHttpRequest = (_f = (_e = props.customRequest) != null ? _e : config.customRequest) != null ? _f : upload;
      props.onRequestChange && callEmit(props.onRequestChange, {
        status: "loadstart",
        file: __spreadValues$3({}, file)
      });
      setFileStatus(file, "uploading", props.onFileStatusChange);
      file.percent = 0;
      aborts.set(file.key, (_h = (_g = uploadHttpRequest(requestOption)) == null ? void 0 : _g.abort) != null ? _h : () => {
      });
      fileUploading.value.push(file);
    });
  }
  function _onProgress(event, file) {
    var _a;
    const curFile = getTargetFile(file, files.value);
    if (!curFile) {
      return;
    }
    curFile.percent = (_a = event.percent) != null ? _a : 0;
    props.onRequestChange && callEmit(props.onRequestChange, {
      status: "progress",
      file: __spreadValues$3({}, curFile),
      event
    });
  }
  function _onError(error, file) {
    const curFile = getTargetFile(file, files.value);
    if (!curFile) {
      return;
    }
    fileUploading.value.splice(getTargetFileIndex(curFile, fileUploading.value), 1);
    curFile.error = error;
    props.onRequestChange && callEmit(props.onRequestChange, {
      file: __spreadValues$3({}, curFile),
      status: "error",
      error
    });
    setFileStatus(curFile, "error", props.onFileStatusChange);
  }
  function _onSuccess(res, file) {
    const curFile = getTargetFile(file, files.value);
    if (!curFile) {
      return;
    }
    curFile.response = res;
    props.onRequestChange && callEmit(props.onRequestChange, {
      status: "loadend",
      file: __spreadValues$3({}, curFile),
      response: res
    });
    setFileStatus(curFile, "success", props.onFileStatusChange);
    fileUploading.value.splice(getTargetFileIndex(curFile, fileUploading.value), 1);
  }
  return {
    fileUploading,
    abort,
    startUpload,
    upload: upload$1
  };
}
function getAction(props, file) {
  return __async(this, null, function* () {
    if (!props.action) {
      throwError("components/upload", "action not found.");
    }
    const action = isFunction(props.action) ? yield props.action(file) : props.action;
    return action;
  });
}
function getRequestData(props, file) {
  return __async(this, null, function* () {
    var _a;
    const requestData = isFunction(props.requestData) ? yield props.requestData(file) : (_a = props.requestData) != null ? _a : {};
    return requestData;
  });
}
var Upload = defineComponent({
  name: "IxUpload",
  props: uploadProps,
  setup(props, {
    slots
  }) {
    const cpmClasses = useCmpClasses();
    const [showSelector, setSelectorVisible] = useShowSelector();
    const [files, onUpdateFiles] = useControlledProp(props, "files", []);
    const {
      fileUploading,
      abort,
      startUpload,
      upload: upload2
    } = useRequest(props, files);
    const {
      viewerVisible,
      images,
      setViewerVisible
    } = useImageViewer();
    provide(uploadToken, {
      props,
      files,
      fileUploading,
      onUpdateFiles,
      abort,
      startUpload,
      upload: upload2,
      setViewerVisible,
      setSelectorVisible
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": cpmClasses.value
      }, [showSelector.value && createVNode(FileSelector, null, {
        default: () => {
          var _a2;
          return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      }), (_a = slots.list) == null ? void 0 : _a.call(slots, {
        abort,
        upload: upload2
      }), createVNode(IxImageViewer, {
        "visible": viewerVisible.value,
        "onUpdate:visible": ($event) => viewerVisible.value = $event,
        "images": images.value
      }, null), createVNode("div", {
        "class": `${cpmClasses.value}-tip`
      }, [(_b = slots.tip) == null ? void 0 : _b.call(slots)])]);
    };
  }
});
function useShowSelector() {
  const showSelector = ref(true);
  function setSelectorVisible(isShow) {
    showSelector.value = isShow;
  }
  return [showSelector, setSelectorVisible];
}
function useImageViewer() {
  const viewerVisible = ref(false);
  const images = shallowRef([]);
  function setViewerVisible(visible, imageSrc) {
    images.value = visible && imageSrc ? [imageSrc] : [];
    viewerVisible.value = visible;
  }
  return {
    viewerVisible,
    images,
    setViewerVisible
  };
}
const IxUpload = Upload;
const IxUploadFiles = UploadFiles;

const version$1 = '1.0.0-alpha.6';

const components$1 = [
    IxAffix,
    IxAlert,
    IxAnchor,
    IxAnchorLink,
    IxAvatar,
    IxBackTop,
    IxBadge,
    IxBreadcrumb,
    IxBreadcrumbItem,
    IxButton,
    IxButtonGroup,
    IxCard,
    IxCardGrid,
    IxCarousel,
    IxCheckbox,
    IxCheckboxGroup,
    IxCollapse,
    IxCollapsePanel,
    IxDatePicker,
    IxDivider,
    IxDrawer,
    IxDrawerProvider,
    IxDropdown,
    IxEmpty,
    IxForm,
    IxFormItem,
    IxFormWrapper,
    IxCol,
    IxRow,
    IxHeader,
    IxIcon,
    IxImage,
    IxImageViewer,
    IxInput,
    IxInputNumber,
    IxLayout,
    IxLayoutContent,
    IxLayoutFooter,
    IxLayoutHeader,
    IxLayoutSider,
    IxList,
    IxListItem,
    IxMenu,
    IxMenuDivider,
    IxMenuItem,
    IxMenuItemGroup,
    IxMenuSub,
    IxMessage,
    IxMessageProvider,
    IxModal,
    IxModalProvider,
    IxNotification,
    IxNotificationProvider,
    IxPagination,
    IxPopconfirm,
    IxPopover,
    IxProgress,
    IxRadio,
    IxRadioGroup,
    IxRate,
    IxResult,
    IxSelect,
    IxSelectOption,
    IxSelectOptionGroup,
    IxSkeleton,
    IxSlider,
    IxSpace,
    IxSpin,
    IxStatistic,
    IxStepper,
    IxStepperItem,
    IxSwitch,
    IxTable,
    IxTableColumn,
    IxTab,
    IxTabs,
    IxTag,
    IxTextarea,
    IxTimePicker,
    IxTimeRangePicker,
    IxTimeline,
    IxTimelineItem,
    IxTooltip,
    IxTree,
    IxTreeSelect,
    IxUpload,
    IxUploadFiles,
];
const directives$1 = {
    typography: typography,
};
const install$2 = (app) => {
    components$1.forEach(component => {
        var _a;
        app.component((_a = component.displayName) !== null && _a !== void 0 ? _a : component.name, component);
    });
    Object.keys(directives$1).forEach(key => {
        app.directive(key, directives$1[key]);
    });
};
var index$1 = {
    install: install$2,
    version: version$1,
};

const common = { prefixCls: "ix-pro" };
const defaultConfig = {
  common
};
const tokens = Object.keys(defaultConfig).map((key) => [key, Symbol(key)]);
const tokenMap = new Map(tokens);
function useGlobalConfig(compName, config) {
  const token = tokenMap.get(compName);
  const currConfig = inject(token, defaultConfig[compName]);
  if (!config) {
    return currConfig;
  }
  const cloneConfig = reactive(merge$1(cloneDeep(currConfig), config));
  provide(token, cloneConfig);
  return [cloneConfig, (config2) => merge$1(cloneConfig, config2)];
}

function getMenuChildren(menu) {
  if (!menu || !("children" in menu)) {
    return NoopArray;
  }
  return menu.children;
}
function getTargetPaths(menus, target) {
  if (!target) {
    return getDefaultPaths(menus);
  }
  let result = [];
  for (let i = 0; i < menus.length; i++) {
    const curMenu = menus[i];
    if (curMenu.key === target) {
      result = [curMenu];
      break;
    } else {
      const activeChildren = getTargetPaths(getMenuChildren(curMenu), target);
      if (activeChildren.length > 0) {
        result = [curMenu, ...activeChildren];
        break;
      }
    }
  }
  return result;
}
function getDefaultPaths(menus) {
  if (!menus || menus.length === 0) {
    return NoopArray;
  }
  const currMenu = menus.find((menu) => menu.type !== "divider" && !menu.disabled);
  if (!currMenu) {
    return NoopArray;
  }
  const paths = [currMenu];
  const children = getMenuChildren(currMenu);
  if (children.length > 0) {
    paths.push(...getDefaultPaths(children));
  }
  return paths;
}
function useActiveKey(props) {
  var _a;
  let defaultActiveKey = props.activeKey;
  const [activeKey, setActiveKey] = useControlledProp(props, "activeKey", defaultActiveKey);
  if (isNil(defaultActiveKey)) {
    const defaultPaths = getDefaultPaths(props.menus);
    defaultActiveKey = (_a = defaultPaths[defaultPaths.length - 1]) == null ? void 0 : _a.key;
    if (defaultActiveKey) {
      setActiveKey(defaultActiveKey);
    }
  }
  return { activeKey, setActiveKey };
}
function useActiveHeaderKey(props, activePaths, headerMenus) {
  return computed(() => {
    const { type } = props;
    const currActivePaths = activePaths.value;
    if (type === "both") {
      if (currActivePaths.length === 0) {
        const [firstMenu] = headerMenus.value;
        return firstMenu == null ? void 0 : firstMenu.key;
      }
      return currActivePaths[0].key;
    }
    if (type === "header") {
      const lastPath = currActivePaths[currActivePaths.length - 1];
      return lastPath == null ? void 0 : lastPath.key;
    }
    return void 0;
  });
}
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useHeaderMenus(props) {
  return computed(() => {
    const { type, menus } = props;
    if (type === "header") {
      return menus;
    }
    if (type === "both") {
      return menus.map((menu) => {
        if (!menu.type || menu.type === "item" || menu.type === "divider") {
          return menu;
        }
        const _a = menu, rest = __objRest(_a, ["children"]);
        rest.type = "item";
        return rest;
      });
    }
    return NoopArray;
  });
}
function useSiderMenus(props, activeHeaderKey) {
  return computed(() => {
    const { type, menus } = props;
    if (["mixin", "sider"].includes(type)) {
      return menus;
    }
    if (type === "both") {
      const currActiveMenu = menus.find((menu) => menu.key === activeHeaderKey.value);
      return getMenuChildren(currActiveMenu);
    }
    return NoopArray;
  });
}
const proLayoutToken = Symbol("proLayout");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var Header = defineComponent({
  name: "ProLayoutHeader",
  setup() {
    const {
      props,
      slots,
      mergedPrefixCls,
      setActiveKey,
      headerMenus,
      activeHeaderKey
    } = inject(proLayoutToken);
    const theme = computed(() => {
      const {
        theme: theme2
      } = props;
      return isObject(theme2) ? theme2.header : theme2;
    });
    const fixed = computed(() => {
      const {
        fixed: fixed2
      } = props;
      return isObject(fixed2) ? fixed2.header : fixed2;
    });
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-header`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${theme.value}`]: true,
        [`${prefixCls}-fixed`]: fixed.value
      });
    });
    const menuSelectedKeys = computed(() => activeHeaderKey.value ? [activeHeaderKey.value] : []);
    const onMenuClick = (menuClickOption) => {
      var _a;
      if (props.type === "both") {
        const targetMenu = props.menus.find((menu) => menu.key === menuClickOption.key);
        if (targetMenu && "children" in targetMenu && !!((_a = targetMenu.children) == null ? void 0 : _a.length)) {
          const activePaths = getDefaultPaths(targetMenu.children);
          setActiveKey(activePaths.pop().key);
          callEmit(props["onMenuClick"], __spreadProps(__spreadValues({}, menuClickOption), {
            type: targetMenu.type
          }));
          return;
        }
      }
      if (menuClickOption.type === "item") {
        setActiveKey(menuClickOption.key);
      }
      callEmit(props["onMenuClick"], menuClickOption);
    };
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-header`;
      const menuProps = {
        overlayClassName: `${prefixCls}-menu-overlay`,
        dataSource: headerMenus.value,
        selectedKeys: menuSelectedKeys.value,
        mode: "horizontal",
        theme: theme.value,
        onClick: onMenuClick
      };
      const contentNode = slots.headerContent ? slots.headerContent(menuProps) : createVNode(IxMenu, menuProps, slots);
      return createVNode(IxLayoutHeader, {
        "class": classes.value
      }, {
        default: () => [slots.logo && createVNode("div", {
          "class": `${prefixCls}-logo`
        }, [slots.logo()]), createVNode("div", {
          "class": `${prefixCls}-content`
        }, [contentNode]), slots.headerExtra && createVNode("div", {
          "class": `${prefixCls}-extra`
        }, [slots.headerExtra()])]
      });
    };
  }
});
var Sider = defineComponent({
  name: "ProLayoutSider",
  setup() {
    const {
      props,
      slots,
      mergedPrefixCls,
      activeKey,
      setActiveKey,
      activePaths,
      siderMenus,
      collapsed,
      setCollapsed
    } = inject(proLayoutToken);
    const {
      expandedKeys,
      setExpandedKeys
    } = useExpandedKeys(activePaths, siderMenus);
    const theme = computed(() => {
      const {
        theme: theme2
      } = props;
      return isObject(theme2) ? theme2.sider : theme2;
    });
    const fixed = computed(() => {
      const {
        fixed: fixed2
      } = props;
      return isObject(fixed2) ? fixed2.sider : fixed2;
    });
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-sider`;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-${theme.value}`]: true,
        [`${prefixCls}-collapsed`]: collapsed.value,
        [`${prefixCls}-fixed`]: fixed.value
      });
    });
    const menuSelectedKeys = computed(() => [activeKey.value]);
    const onMenuClick = (menuClickOption) => {
      callEmit(props["onMenuClick"], menuClickOption);
    };
    return () => {
      const prefixCls = `${mergedPrefixCls.value}-sider`;
      const menuProps = {
        overlayClassName: `${prefixCls}-menu-overlay`,
        collapsed: collapsed.value,
        dataSource: siderMenus.value,
        expandedKeys: expandedKeys.value,
        "onUpdate:expandedKeys": setExpandedKeys,
        selectedKeys: menuSelectedKeys.value,
        "onUpdate:selectedKeys": (keys) => setActiveKey(keys[0]),
        mode: "inline",
        theme: theme.value,
        onClick: onMenuClick
      };
      const contentNode = slots.siderContent ? slots.siderContent(menuProps) : createVNode(IxMenu, mergeProps(menuProps, props.siderMenu), slots);
      return createVNode(IxLayoutSider, mergeProps({
        "class": classes.value,
        "onCollapse": setCollapsed
      }, props.sider), {
        default: () => [slots.siderHeader && createVNode("div", {
          "class": `${mergedPrefixCls.value}-sider-header`
        }, [slots.siderHeader()]), createVNode("div", {
          "class": `${prefixCls}-content`
        }, [contentNode]), slots.siderFooter && createVNode("div", {
          "class": `${mergedPrefixCls.value}-sider-footer`
        }, [slots.siderFooter()])]
      });
    };
  }
});
function useExpandedKeys(activePaths, siderMenus) {
  const [expandedKeys, _setExpandedKeys] = useState$1(getExpandedKeys(activePaths.value));
  watch(activePaths, (paths) => _setExpandedKeys(getExpandedKeys(paths)));
  const setExpandedKeys = (keys) => {
    const oldKeys = expandedKeys.value;
    if (oldKeys.length > keys.length) {
      _setExpandedKeys(keys);
      return;
    }
    let targetPaths;
    const lastKey = keys[keys.length - 1];
    const targetIndex = activePaths.value.findIndex((menu) => menu.key === lastKey);
    if (targetIndex > -1) {
      targetPaths = activePaths.value.slice(0, targetIndex + 1);
    } else {
      targetPaths = getTargetPaths(siderMenus.value, lastKey);
    }
    _setExpandedKeys(getExpandedKeys(targetPaths));
  };
  return {
    expandedKeys,
    setExpandedKeys
  };
}
function getExpandedKeys(menus) {
  return menus.filter((menu) => {
    var _a;
    return menu.type === "sub" && !!((_a = menu.children) == null ? void 0 : _a.length);
  }).map((menu) => menu.key);
}
const proLayoutProps = {
  activeKey: IxPropTypes.oneOfType([String, Number, Symbol]),
  collapsed: IxPropTypes.bool,
  fixed: IxPropTypes.oneOfType([Boolean, IxPropTypes.object()]).def(false),
  menus: IxPropTypes.array().def(() => []),
  sider: IxPropTypes.object(),
  siderMenu: IxPropTypes.object(),
  theme: IxPropTypes.oneOfType([
    IxPropTypes.oneOf(["light", "dark"]),
    IxPropTypes.object()
  ]).def("light"),
  type: IxPropTypes.oneOf(["header", "sider", "both", "mixin"]).def("mixin"),
  "onUpdate:activeKey": IxPropTypes.emit(),
  "onUpdate:collapsed": IxPropTypes.emit(),
  onMenuClick: IxPropTypes.emit()
};
const proLayoutSiderTriggerProps = {
  icon: IxPropTypes.arrayOf(IxPropTypes.oneOfType([String, IxPropTypes.vNode]))
};
var ProLayout = defineComponent({
  name: "IxProLayout",
  props: proLayoutProps,
  setup(props, {
    slots
  }) {
    const common = useGlobalConfig("common");
    const mergedPrefixCls = computed(() => `${common.prefixCls}-layout`);
    const {
      activeKey,
      setActiveKey
    } = useActiveKey(props);
    const activePaths = computed(() => getTargetPaths(props.menus, activeKey.value));
    const headerMenus = useHeaderMenus(props);
    const activeHeaderKey = useActiveHeaderKey(props, activePaths, headerMenus);
    const siderMenus = useSiderMenus(props, activeHeaderKey);
    const [collapsed, setCollapsed] = useControlledProp(props, "collapsed", false);
    provide(proLayoutToken, {
      props,
      slots,
      mergedPrefixCls,
      activeKey,
      setActiveKey,
      activePaths,
      headerMenus,
      activeHeaderKey,
      siderMenus,
      collapsed,
      setCollapsed
    });
    const layoutClasses = computed(() => {
      const {
        type,
        fixed
      } = props;
      const prefixCls = mergedPrefixCls.value;
      return normalizeClass({
        [prefixCls]: true,
        [`${prefixCls}-is-${type}`]: true,
        [`${prefixCls}-fixed`]: fixed
      });
    });
    const showSider = computed(() => {
      const {
        type
      } = props;
      return type === "both" && siderMenus.value.length > 0 || type === "sider" || type === "mixin";
    });
    return () => {
      const prefixCls = mergedPrefixCls.value;
      return createVNode(IxLayout, {
        "class": layoutClasses.value
      }, {
        default: () => [props.type !== "sider" && createVNode(Header, null, null), showSider.value && createVNode(Sider, null, null), createVNode(IxLayoutContent, {
          "class": `${prefixCls}-content`
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        }), slots.footer && createVNode(IxLayoutFooter, {
          "class": `${prefixCls}-footer`
        }, {
          default: () => [slots.footer()]
        })]
      });
    };
  }
});
var ProLayoutSiderTrigger = defineComponent({
  name: "IxProLayoutSiderTrigger",
  props: proLayoutSiderTriggerProps,
  setup(props, {
    slots
  }) {
    const {
      mergedPrefixCls,
      collapsed,
      setCollapsed
    } = inject(proLayoutToken);
    const icon = computed(() => {
      const [fold = "menu-fold", unfold = "menu-unfold"] = props.icon || [];
      return collapsed.value ? fold : unfold;
    });
    const classes = computed(() => {
      const prefixCls = `${mergedPrefixCls.value}-sider-trigger`;
      return {
        [prefixCls]: true,
        [`${prefixCls}-collapsed`]: collapsed.value
      };
    });
    const handleClick = () => setCollapsed(!collapsed.value);
    return () => {
      let children;
      if (slots.default) {
        children = slots.default({
          collapsed: collapsed.value
        });
      } else {
        const iconValue = icon.value;
        children = isString(iconValue) ? createVNode(IxIcon, {
          "name": iconValue
        }, null) : iconValue;
      }
      return createVNode("div", {
        "class": classes.value,
        "onClick": handleClick
      }, [children]);
    };
  }
});
const IxProLayout = ProLayout;
const IxProLayoutSiderTrigger = ProLayoutSiderTrigger;

const version = '1.0.0-alpha.6';

const directives = {};
const components = [IxProLayout, IxProLayoutSiderTrigger];
const install$1 = (app) => {
    components.forEach(component => {
        var _a;
        app.component((_a = component.name) !== null && _a !== void 0 ? _a : component.displayName, component);
    });
    Object.keys(directives).forEach(key => {
        app.directive(key, directives[key]);
    });
};
var index = {
    install: install$1,
    version,
};

// : `IDUX_ICON_DEPENDENCIES`  `@idux` 
addIconDefinitions(IDUX_ICON_DEPENDENCIES);

//  http 
//  svg  `public/idux-icons` 
// const loadIconDynamically = (iconName) => {
//   return fetch(`/idux-icons/${iconName}.svg`).then((res) => res.text())
// }

// const globalConfig = createGlobalConfig({
//   icon: { loadIconDynamically },
// })

const install = (app) => {
  app.use(index$2).use(index$1).use(index);
};

var idux = { install };

export { idux as default };
